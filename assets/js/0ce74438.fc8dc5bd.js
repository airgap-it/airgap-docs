/*! For license information please see 0ce74438.fc8dc5bd.js.LICENSE.txt */
(self.webpackChunkairgap_docs=self.webpackChunkairgap_docs||[]).push([[6342],{62405:function(e,n,t){"use strict";var r;t.d(n,{T:function(){return r}}),function(e){e[e.INIT=0]="INIT",e[e.STARTED=1]="STARTED",e[e.ENDED=2]="ENDED"}(r||(r={}))},44433:function(e,n,t){"use strict";t.d(n,{Z:function(){return c}});var r=t(87462),o=t(67294),s=t(29548),a=[{name:"@airgap/coinlib-core/actions/Action.d.ts",dts:"export declare enum ActionState {\n    READY = 0,\n    EXECUTING = 1,\n    COMPLETED = 2,\n    CANCELLED = 3\n}\nexport declare abstract class Action<Result, Context> {\n    get identifier(): string;\n    readonly context: Context;\n    result?: Result;\n    error?: Error;\n    onComplete?: (result: Result) => Promise<void>;\n    onError?: (error: Error) => Promise<void>;\n    onCancel?: () => Promise<void>;\n    private readonly stateMachine;\n    constructor(context: Context);\n    getState(): ActionState;\n    start(): Promise<void>;\n    cancel(): void;\n    protected abstract perform(): Promise<Result>;\n    protected addValidTransition(from: ActionState, to: ActionState): void;\n    private handleSuccess;\n    private handleError;\n}\n"},{name:"@airgap/coinlib-core/actions/GetKtAccountsAction.d.ts",dts:"import { Action } from './Action';\nexport interface ImportAccoutActionContext {\n    publicKey: string;\n}\nexport declare class ImportAccountAction extends Action<string[], ImportAccoutActionContext> {\n    get identifier(): string;\n    protected perform(): Promise<string[]>;\n}\n"},{name:"@airgap/coinlib-core/actions/LinkedAction.d.ts",dts:"import { Action } from './Action';\nexport declare class LinkedAction<Result, Context> extends Action<Result, void> {\n    private readonly linkedActionType;\n    readonly action: Action<Context, void>;\n    private linkedAction?;\n    constructor(action: Action<Context, void>, linkedActionType: new (context: Context) => Action<Result, Context>);\n    getLinkedAction(): Action<Result, Context> | undefined;\n    protected perform(): Promise<Result>;\n    cancel(): void;\n}\n"},{name:"@airgap/coinlib-core/actions/RepeatableAction.d.ts",dts:"import { Action } from './Action';\nexport declare class RepeatableAction<Result, InnerContext, Context> extends Action<Result, Context> {\n    private readonly actionFactory;\n    private innerAction?;\n    constructor(context: Context, actionFactory: () => Action<Result, InnerContext>);\n    protected perform(): Promise<Result>;\n    cancel(): void;\n}\n"},{name:"@airgap/coinlib-core/actions/SimpleAction.d.ts",dts:"import { Action } from './Action';\nexport declare class SimpleAction<Result> extends Action<Result, void> {\n    get identifier(): string;\n    private readonly promise;\n    constructor(promise: () => Promise<Result>);\n    protected perform(): Promise<Result>;\n}\n"},{name:"@airgap/coinlib-core/actions/StateMachine.d.ts",dts:"export declare class StateMachine<S> {\n    private state;\n    private readonly validTransitions;\n    constructor(initialState: S, validTransitions: Map<S, S[]>);\n    transitionTo(state: S): void;\n    getState(): S;\n    addValidStateTransition(from: S, to: S): void;\n    private canTransitionTo;\n}\n"},{name:"@airgap/coinlib-core/data/KeyPair.d.ts",dts:'/// <reference types="node" />\nexport interface KeyPair {\n    publicKey: Buffer;\n    privateKey: Buffer;\n}\n'},{name:"@airgap/coinlib-core/data/Lazy.d.ts",dts:"export declare class Lazy<T> {\n    private readonly init;\n    private isInitialized;\n    private value?;\n    constructor(init: () => T);\n    get(): T;\n}\nexport declare class LazyAsync<T> {\n    private readonly init;\n    private isInitialized;\n    private value?;\n    constructor(init: () => Promise<T>);\n    get(): Promise<T>;\n}\n"},{name:"@airgap/coinlib-core/data/RPCBody.d.ts",dts:"export declare class RPCBody {\n    readonly method: string;\n    readonly params: any[];\n    readonly id: number;\n    readonly jsonrpc: string;\n    constructor(method: string, params: any[], id?: number, jsonrpc?: string);\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito/src/forger/interface.d.ts",dts:"import { OperationContents } from '../../../taquito-rpc/src/types';\nexport interface ForgeParams {\n    branch: string;\n    contents: OperationContents[];\n}\nexport declare type ForgeResponse = string;\nexport interface Forger {\n    forge(params: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/michelson/codec.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { Encoder } from '../taquito-local-forging';\ndeclare type PrimValue = {\n    prim: string;\n    args?: MichelsonValue[];\n    annots?: string[];\n};\ndeclare type BytesValue = {\n    bytes: string;\n};\ndeclare type StringValue = {\n    string: string;\n};\ndeclare type IntValue = {\n    int: string;\n};\nexport declare type MichelsonValue = PrimValue | BytesValue | StringValue | IntValue | (PrimValue | BytesValue | StringValue | IntValue)[];\nexport declare const isPrim: (value: MichelsonValue) => value is PrimValue;\nexport declare const isBytes: (value: MichelsonValue) => value is BytesValue;\nexport declare const isString: (value: MichelsonValue) => value is StringValue;\nexport declare const isInt: (value: MichelsonValue) => value is IntValue;\nexport declare const scriptEncoder: Encoder<{\n    code: MichelsonValue;\n    storage: MichelsonValue;\n}>;\nexport declare const scriptDecoder: Decoder;\nexport declare const valueEncoder: Encoder<MichelsonValue>;\nexport declare const valueDecoder: Decoder;\nexport declare const extractRequiredLen: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array;\nexport declare const bytesEncoder: Encoder<BytesValue>;\nexport declare const bytesDecoder: Decoder;\nexport declare const stringEncoder: Encoder<StringValue>;\nexport declare const stringDecoder: Decoder;\nexport declare const intEncoder: Encoder<IntValue>;\nexport declare const intDecoder: (value: Uint8ArrayConsumer) => IntValue;\nexport declare const primEncoder: Encoder<PrimValue>;\nexport declare const primDecoder: (value: Uint8ArrayConsumer, preamble: Uint8Array) => Partial<PrimValue>;\nexport declare const encodeAnnots: Encoder<string[]>;\nexport declare const decodeAnnots: Decoder;\nexport {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/schema/operation.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nexport declare const ManagerOperationSchema: {\n    branch: string;\n    contents: string[];\n};\nexport declare const ActivationSchema: {\n    pkh: string;\n    secret: string;\n};\nexport declare const RevealSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n};\nexport declare const DelegationSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate: string;\n};\nexport declare const TransactionSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters: string;\n};\nexport declare const OriginationSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate: string;\n    script: string;\n};\nexport declare const BallotSchema: {\n    source: string;\n    period: string;\n    proposal: string;\n    ballot: string;\n};\nexport declare const EndorsementSchema: {\n    level: string;\n};\nexport declare const SeedNonceRevelationSchema: {\n    level: string;\n    nonce: string;\n};\nexport declare const ProposalsSchema: {\n    source: string;\n    period: string;\n    proposals: string;\n};\nexport declare const operationEncoder: (encoders: {\n    [key: string]: (val: {}) => string;\n}) => (operation: {\n    kind: string;\n}) => string;\nexport declare const operationDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (value: Uint8ArrayConsumer) => {\n    kind: string;\n};\nexport declare const schemaEncoder: (encoders: {\n    [key: string]: (val: {}) => string;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => <T extends {\n    [key: string]: any;\n}>(value: T) => string;\nexport declare const schemaDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => (value: Uint8ArrayConsumer) => {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/codec.d.ts",dts:"import { Prefix } from '../../../../../@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/taquito-utils';\nimport { MichelsonValue } from './michelson/codec';\nimport { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare const prefixEncoder: (prefix: Prefix) => (str: string) => string;\nexport declare const prefixDecoder: (pre: Prefix) => (str: Uint8ArrayConsumer) => any;\nexport declare const tz1Decoder: (str: Uint8ArrayConsumer) => any;\nexport declare const branchDecoder: (str: Uint8ArrayConsumer) => any;\nexport declare const pkhDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const branchEncoder: (str: string) => string;\nexport declare const tz1Encoder: (str: string) => string;\nexport declare const boolEncoder: (bool: unknown) => string;\nexport declare const proposalEncoder: (proposal: string) => string;\nexport declare const proposalDecoder: (proposal: Uint8ArrayConsumer) => string;\nexport declare const proposalsDecoder: (proposal: Uint8ArrayConsumer) => string[];\nexport declare const proposalsEncoder: (proposals: string[]) => string;\nexport declare const ballotEncoder: (ballot: string) => string;\nexport declare const ballotDecoder: (ballot: Uint8ArrayConsumer) => string;\nexport declare const delegateEncoder: (val: string) => string;\nexport declare const int32Encoder: (val: number | string) => string;\nexport declare const int32Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const boolDecoder: (val: Uint8ArrayConsumer) => boolean;\nexport declare const delegateDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const pkhEncoder: (val: string) => string;\nexport declare const publicKeyEncoder: (val: string) => string;\nexport declare const addressEncoder: (val: string) => string;\nexport declare const publicKeyDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const addressDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const zarithEncoder: (n: string) => string;\nexport declare const zarithDecoder: (n: Uint8ArrayConsumer) => string;\nexport declare const entrypointDecoder: (value: Uint8ArrayConsumer) => string;\nexport declare const parametersDecoder: (val: Uint8ArrayConsumer) => {\n    entrypoint: string;\n    value: string | number | {} | undefined;\n} | undefined;\nexport declare const entrypointEncoder: (entrypoint: string) => string;\nexport declare const parametersEncoder: (val: {\n    entrypoint: string;\n    value: MichelsonValue;\n}) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/constants.d.ts",dts:'export declare const ENTRYPOINT_MAX_LENGTH = 31;\nexport declare enum CODEC {\n    SECRET = "secret",\n    RAW = "raw",\n    TZ1 = "tz1",\n    BRANCH = "branch",\n    ZARITH = "zarith",\n    PUBLIC_KEY = "public_key",\n    PKH = "pkh",\n    DELEGATE = "delegate",\n    SCRIPT = "script",\n    BALLOT_STATEMENT = "ballotStmt",\n    PROPOSAL = "proposal",\n    PROPOSAL_ARR = "proposalArr",\n    INT32 = "int32",\n    PARAMETERS = "parameters",\n    ADDRESS = "address",\n    OPERATION = "operation",\n    OP_ACTIVATE_ACCOUNT = "activate_account",\n    OP_DELEGATION = "delegation",\n    OP_TRANSACTION = "transaction",\n    OP_ORIGINATION = "origination",\n    OP_BALLOT = "ballot",\n    OP_ENDORSEMENT = "endorsement",\n    OP_SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    OP_REVEAL = "reveal",\n    OP_PROPOSALS = "proposals",\n    MANAGER = "manager"\n}\nexport declare const opMapping: {\n    [key: string]: string;\n};\nexport declare const opMappingReverse: {\n    [key: string]: string;\n};\nexport declare const kindMapping: {\n    [key: number]: string;\n};\nexport declare const kindMappingReverse: {\n    [key: string]: string;\n};\nexport declare const entrypointMapping: {\n    [key: string]: string;\n};\nexport declare const entrypointMappingReverse: {\n    [key: string]: string;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/decoder.d.ts",dts:"import { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare type Decoder = (val: Uint8ArrayConsumer) => string | number | {} | undefined;\nexport declare const decoders: {\n    [key: string]: Decoder;\n};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/encoder.d.ts",dts:"export declare type Encoder<T> = (val: T) => string;\nexport declare const encoders: {\n    [key: string]: Encoder<any>;\n};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/taquito-local-forging.d.ts",dts:"import { ForgeParams, Forger } from '../../taquito/src/forger/interface';\nimport { CODEC } from './constants';\nexport { CODEC } from './constants';\nexport * from './decoder';\nexport * from './encoder';\nexport * from './uint8array-consumer';\nexport declare function getCodec(codec: CODEC): {\n    encoder: import(\"./encoder\").Encoder<any>;\n    decoder: (hex: string) => any;\n};\nexport declare class LocalForger implements Forger {\n    private codec;\n    forge(params: ForgeParams): Promise<string>;\n    parse(hex: string): Promise<ForgeParams>;\n}\nexport declare const localForger: LocalForger;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/uint8array-consumer.d.ts",dts:"export declare class Uint8ArrayConsumer {\n    private readonly arr;\n    private offset;\n    static fromHexString(hex: string): Uint8ArrayConsumer;\n    constructor(arr: Uint8Array, offset?: number);\n    consume(count: number): Uint8Array;\n    get(idx: number): number;\n    length(): number;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/utils.d.ts",dts:"export declare const concat: (...arr: Uint8Array[]) => Uint8Array;\nexport declare const toHexString: (bytes: Uint8Array) => string;\nexport declare const pad: (num: number, paddingLen?: number) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-rpc/src/opkind.d.ts",dts:'export declare enum OpKind {\n    ORIGINATION = "origination",\n    DELEGATION = "delegation",\n    REVEAL = "reveal",\n    TRANSACTION = "transaction",\n    ACTIVATION = "activate_account",\n    ENDORSEMENT = "endorsement",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    PROPOSALS = "proposals",\n    BALLOT = "ballot"\n}\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-rpc/src/types.d.ts",dts:"import BigNumber from '../../../../../bignumber.js-9.0.0/bignumber';\nimport { OpKind } from './opkind';\nexport declare type BalanceResponse = BigNumber;\nexport declare type StorageResponse = ScriptedContracts['storage'];\nexport declare type ScriptResponse = ScriptedContracts;\nexport declare type BigMapGetResponse = MichelsonV1Expression;\nexport declare type ManagerResponse = {\n    manager: string;\n};\nexport declare type ManagerKeyResponse = string | {\n    key: string;\n};\nexport declare type DelegateResponse = string | null;\nexport declare type OperationHash = string;\nexport interface DelegatesResponse {\n    balance: BigNumber;\n    frozen_balance: BigNumber;\n    frozen_balance_by_cycle: Frozenbalancebycycle[];\n    staking_balance: BigNumber;\n    delegated_contracts: string[];\n    delegated_balance: BigNumber;\n    deactivated: boolean;\n    grace_period: number;\n}\ninterface Frozenbalancebycycle {\n    cycle: number;\n    deposit: BigNumber;\n    fees: BigNumber;\n    rewards: BigNumber;\n}\nexport declare type BigMapKey = {\n    key: {\n        [key: string]: string;\n    };\n    type: {\n        prim: string;\n    };\n};\nexport interface BlockFullHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: TimeStampMixed;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    seed_nonce_hash?: string;\n    signature: string;\n}\nexport declare type InlinedEndorsementKindEnum = OpKind.ENDORSEMENT;\nexport interface InlinedEndorsementContents {\n    kind: InlinedEndorsementKindEnum;\n    level: number;\n}\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport declare type OperationContentsBallotEnum = 'nay' | 'yay' | 'pass';\nexport interface OperationContentsEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    level: number;\n}\nexport interface OperationContentsRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n}\nexport interface OperationContentsDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n}\nexport interface OperationContentsDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n}\nexport interface OperationContentsActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n}\nexport interface OperationContentsProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: OperationContentsBallotEnum;\n}\nexport interface OperationContentsReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n}\nexport interface OperationContentsTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n}\nexport interface OperationContentsOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n}\nexport interface OperationContentsDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\nexport declare type OperationContents = OperationContentsEndorsement | OperationContentsRevelation | OperationContentsDoubleEndorsement | OperationContentsDoubleBaking | OperationContentsActivateAccount | OperationContentsProposals | OperationContentsBallot | OperationContentsReveal | OperationContentsTransaction | OperationContentsOrigination | OperationContentsDelegation;\nexport interface OperationContentsAndResultMetadataExtended {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    slots: number[];\n}\nexport interface OperationContentsAndResultMetadataReveal {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultReveal;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataTransaction {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultTransaction;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDelegation {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultDelegation;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadata {\n    balance_updates: OperationMetadataBalanceUpdates[];\n}\nexport interface OperationContentsAndResultEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    level: number;\n    metadata: OperationContentsAndResultMetadataExtended;\n}\nexport interface OperationContentsAndResultRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsAndResultBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: OperationContentsBallotEnum;\n}\nexport interface OperationContentsAndResultReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    metadata: OperationContentsAndResultMetadataReveal;\n}\nexport interface OperationContentsAndResultTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n    metadata: OperationContentsAndResultMetadataTransaction;\n}\nexport interface OperationContentsAndResultDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n    metadata: OperationContentsAndResultMetadataDelegation;\n}\nexport declare type OperationContentsAndResult = OperationContentsAndResultEndorsement | OperationContentsAndResultRevelation | OperationContentsAndResultDoubleEndorsement | OperationContentsAndResultDoubleBaking | OperationContentsAndResultActivateAccount | OperationContentsAndResultProposals | OperationContentsAndResultBallot | OperationContentsAndResultReveal | OperationContentsAndResultTransaction | OperationContentsAndResultOrigination | OperationContentsAndResultDelegation;\nexport interface OperationEntry {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    branch: string;\n    contents: (OperationContents | OperationContentsAndResult)[];\n    signature?: string;\n}\nexport interface BlockResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    header: BlockFullHeader;\n    metadata: BlockMetadata;\n    operations: OperationEntry[][];\n}\nexport declare type BakingRightsArgumentsDelegate = string | string[];\nexport declare type BakingRightsArgumentsCycle = number | number[];\nexport declare type BakingRightsArgumentsLevel = number | number[];\nexport interface BakingRightsQueryArguments {\n    level?: BakingRightsArgumentsLevel;\n    cycle?: BakingRightsArgumentsCycle;\n    delegate?: BakingRightsArgumentsDelegate;\n    max_priority?: number;\n    all?: null;\n}\nexport interface BakingRightsResponseItem {\n    level: number;\n    delegate: string;\n    priority: number;\n    estimated_time?: Date;\n}\nexport declare type BakingRightsResponse = BakingRightsResponseItem[];\nexport declare type EndorsingRightsArgumentsDelegate = string | string[];\nexport declare type EndorsingRightsArgumentsCycle = number | number[];\nexport declare type EndorsingRightsArgumentsLevel = number | number[];\nexport interface EndorsingRightsQueryArguments {\n    level?: EndorsingRightsArgumentsLevel;\n    cycle?: EndorsingRightsArgumentsCycle;\n    delegate?: EndorsingRightsArgumentsDelegate;\n}\nexport interface EndorsingRightsResponseItem {\n    level: number;\n    delegate: string;\n    slots: number[];\n    estimated_time?: Date;\n}\nexport declare type EndorsingRightsResponse = EndorsingRightsResponseItem[];\nexport declare type BallotListResponseEnum = 'nay' | 'yay' | 'pass';\nexport interface BallotListResponseItem {\n    pkh: string;\n    ballot: BallotListResponseEnum;\n}\nexport declare type BallotListResponse = BallotListResponseItem[];\nexport interface BallotsResponse {\n    yay: number;\n    nay: number;\n    pass: number;\n}\nexport declare type PeriodKindResponse = 'proposal' | 'testing_vote' | 'testing' | 'promotion_vote';\nexport declare type CurrentProposalResponse = string | null;\nexport declare type CurrentQuorumResponse = number;\nexport interface VotesListingsResponseItem {\n    pkh: string;\n    rolls: number;\n}\nexport declare type VotesListingsResponse = VotesListingsResponseItem[];\nexport declare type ProposalsResponseItem = [string, number];\nexport declare type ProposalsResponse = ProposalsResponseItem[];\nexport interface RawBlockHeaderResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\nexport interface BlockHeaderResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\nexport interface PackDataParams {\n    data: MichelsonV1Expression;\n    type: MichelsonV1Expression;\n    gas?: BigNumber;\n}\nexport declare type HexString = string;\nexport interface PackDataResponse {\n    packed: HexString;\n    gas?: BigNumber | 'unaccounted';\n}\nexport declare type BigMapResponse = MichelsonV1Expression | MichelsonV1Expression[];\nexport declare type PreapplyParams = OperationObject[];\nexport declare type PreapplyResponse = {\n    contents: OperationContentsAndResult[];\n};\nexport declare type ForgeOperationsParams = Pick<OperationObject, 'branch' | 'contents'>;\nexport declare type TimeStampMixed = Date | string;\nexport declare type BalanceUpdateKindEnum = 'contract' | 'freezer';\nexport declare type BalanceUpdateCategoryEnum = 'rewards' | 'fees' | 'deposits';\nexport interface MichelsonV1ExpressionBase {\n    int?: string;\n    string?: string;\n    bytes?: string;\n}\nexport interface MichelsonV1ExpressionExtended {\n    prim: string;\n    args?: MichelsonV1Expression[];\n    annots?: string[];\n}\nexport declare type MichelsonV1Expression = MichelsonV1ExpressionBase | MichelsonV1ExpressionExtended | MichelsonV1Expression[];\nexport interface ScriptedContracts {\n    code: MichelsonV1Expression[];\n    storage: MichelsonV1Expression;\n}\nexport interface OperationBalanceUpdatesItem {\n    kind: BalanceUpdateKindEnum;\n    category?: BalanceUpdateCategoryEnum;\n    delegate?: string;\n    cycle?: number;\n    contract?: string;\n    change: string;\n}\nexport declare type OperationBalanceUpdates = OperationBalanceUpdatesItem[];\nexport interface OperationObject {\n    branch?: string;\n    contents?: OperationContents[];\n    protocol?: string;\n    signature?: string;\n}\nexport declare type InternalOperationResultKindEnum = OpKind.REVEAL | OpKind.TRANSACTION | OpKind.ORIGINATION | OpKind.DELEGATION;\nexport declare type InternalOperationResultEnum = OperationResultReveal | OperationResultTransaction | OperationResultDelegation | OperationResultOrigination;\nexport interface OperationResultDelegation {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface ContractBigMapDiffItem {\n    key_hash: string;\n    key: MichelsonV1Expression;\n    value?: MichelsonV1Expression;\n}\nexport declare type ContractBigMapDiff = ContractBigMapDiffItem[];\nexport interface TezosGenericOperationError {\n    kind: string;\n    id: string;\n}\nexport interface OperationResultTransaction {\n    status: OperationResultStatusEnum;\n    storage?: MichelsonV1Expression;\n    big_map_diff?: ContractBigMapDiff;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    allocated_destination_contract?: boolean;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationResultReveal {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface TransactionOperationParameter {\n    entrypoint: string;\n    value: MichelsonV1Expression;\n}\nexport interface InternalOperationResult {\n    kind: InternalOperationResultKindEnum;\n    source: string;\n    nonce: number;\n    amount?: string;\n    destination?: string;\n    parameters?: TransactionOperationParameter;\n    public_key?: string;\n    balance?: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    result: InternalOperationResultEnum;\n}\nexport declare type MetadataBalanceUpdatesKindEnum = 'contract' | 'freezer';\nexport declare type MetadataBalanceUpdatesCategoryEnum = 'rewards' | 'fees' | 'deposits';\nexport interface OperationMetadataBalanceUpdates {\n    kind: MetadataBalanceUpdatesKindEnum;\n    category?: MetadataBalanceUpdatesCategoryEnum;\n    contract?: string;\n    delegate?: string;\n    cycle?: number;\n    change: string;\n}\nexport declare type OperationResultStatusEnum = 'applied' | 'failed' | 'skipped' | 'backtracked';\nexport interface OperationResultOrigination {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationContentsAndResultMetadataOrigination {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultOrigination;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport declare type ConstantsResponse = ConstantsResponseCommon & ConstantsResponseProto007 & ConstantsResponseProto006 & ConstantsResponseProto005 & ConstantsResponseProto004 & ConstantsResponseProto003 & ConstantsResponseProto001And002;\nexport interface ConstantsResponseCommon {\n    proof_of_work_nonce_size: number;\n    nonce_length: number;\n    max_operation_data_length: number;\n    preserved_cycles: number;\n    blocks_per_cycle: number;\n    blocks_per_commitment: number;\n    blocks_per_roll_snapshot: number;\n    blocks_per_voting_period: number;\n    time_between_blocks: BigNumber[];\n    endorsers_per_block: number;\n    hard_gas_limit_per_operation: BigNumber;\n    hard_gas_limit_per_block: BigNumber;\n    proof_of_work_threshold: BigNumber;\n    tokens_per_roll: BigNumber;\n    michelson_maximum_type_size: number;\n    seed_nonce_revelation_tip: BigNumber;\n    block_security_deposit: BigNumber;\n    endorsement_security_deposit: BigNumber;\n    endorsement_reward: BigNumber | BigNumber[];\n    cost_per_byte: BigNumber;\n    hard_storage_limit_per_operation: BigNumber;\n}\nexport interface ConstantsResponseProto007 extends Omit<ConstantsResponseProto006, 'max_revelations_per_block'> {\n    max_anon_ops_per_block?: number;\n}\nexport interface ConstantsResponseProto006 extends Omit<ConstantsResponseProto005, 'block_reward'> {\n    baking_reward_per_endorsement?: BigNumber[];\n}\nexport interface ConstantsResponseProto005 extends ConstantsResponseProto004 {\n    quorum_min?: number;\n    quorum_max?: number;\n    min_proposal_quorum?: number;\n    initial_endorsers?: number;\n    delay_per_missing_endorsement?: BigNumber;\n}\nexport interface ConstantsResponseProto004 extends ConstantsResponseProto003 {\n    test_chain_duration?: BigNumber;\n}\nexport interface ConstantsResponseProto003 extends Omit<ConstantsResponseProto001And002, 'origination_burn'> {\n    origination_size?: number;\n    max_proposals_per_delegate?: number;\n}\nexport interface ConstantsResponseProto001And002 {\n    max_revelations_per_block?: number;\n    origination_burn?: string;\n    block_reward?: BigNumber;\n}\nexport interface ContractResponse {\n    balance: BigNumber;\n    script: ScriptedContracts;\n    counter?: string;\n    delegate?: string;\n}\nexport interface TestChainStatus {\n    status: string;\n}\nexport interface MaxOperationListLength {\n    max_size: number;\n    max_op: number;\n}\nexport interface Level {\n    level: number;\n    level_position: number;\n    cycle: number;\n    cycle_position: number;\n    voting_period: number;\n    voting_period_position: number;\n    expected_commitment: boolean;\n}\nexport interface BlockMetadata {\n    protocol: string;\n    next_protocol: string;\n    test_chain_status: TestChainStatus;\n    max_operations_ttl: number;\n    max_operation_data_length: number;\n    max_block_header_length: number;\n    max_operation_list_length: MaxOperationListLength[];\n    baker: string;\n    level: Level;\n    voting_period_kind: string;\n    nonce_hash?: any;\n    consumed_gas: string;\n    deactivated: any[];\n    balance_updates: OperationBalanceUpdates;\n}\nexport declare type RPCRunOperationParam = {\n    operation: OperationObject;\n    chain_id: string;\n};\nexport declare type RPCRunCodeParam = {\n    script: MichelsonV1ExpressionExtended[];\n    storage: MichelsonV1Expression;\n    input: MichelsonV1Expression;\n    amount: string;\n    chain_id: string;\n    source?: string;\n    payer?: string;\n    gas?: BigNumber;\n    entrypoint?: string;\n    balance?: string;\n};\nexport declare type RunCodeResult = {\n    storage: MichelsonV1Expression;\n    operations: InternalOperationResult[];\n    big_map_diff?: ContractBigMapDiff;\n};\nexport declare type EntrypointsResponse = {\n    entrypoints: {\n        [key: string]: Object;\n    };\n    unreachable?: {\n        path: ('Left' | 'Right')[];\n    };\n};\nexport interface OperationContentsAndResultOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    metadata: OperationContentsAndResultMetadataOrigination;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/constants.d.ts",dts:'export declare enum Prefix {\n    TZ1 = "tz1",\n    TZ2 = "tz2",\n    TZ3 = "tz3",\n    KT = "KT",\n    KT1 = "KT1",\n    EDSK2 = "edsk2",\n    SPSK = "spsk",\n    P2SK = "p2sk",\n    EDPK = "edpk",\n    SPPK = "sppk",\n    P2PK = "p2pk",\n    EDESK = "edesk",\n    SPESK = "spesk",\n    P2ESK = "p2esk",\n    EDSK = "edsk",\n    EDSIG = "edsig",\n    SPSIG = "spsig",\n    P2SIG = "p2sig",\n    SIG = "sig",\n    NET = "Net",\n    NCE = "nce",\n    B = "b",\n    O = "o",\n    LO = "Lo",\n    LLO = "LLo",\n    P = "P",\n    CO = "Co",\n    ID = "id",\n    EXPR = "expr",\n    TZ = "TZ"\n}\nexport declare const prefix: {\n    tz1: Uint8Array;\n    tz2: Uint8Array;\n    tz3: Uint8Array;\n    KT: Uint8Array;\n    KT1: Uint8Array;\n    edsk: Uint8Array;\n    edsk2: Uint8Array;\n    spsk: Uint8Array;\n    p2sk: Uint8Array;\n    edpk: Uint8Array;\n    sppk: Uint8Array;\n    p2pk: Uint8Array;\n    edesk: Uint8Array;\n    spesk: Uint8Array;\n    p2esk: Uint8Array;\n    edsig: Uint8Array;\n    spsig: Uint8Array;\n    p2sig: Uint8Array;\n    sig: Uint8Array;\n    Net: Uint8Array;\n    nce: Uint8Array;\n    b: Uint8Array;\n    o: Uint8Array;\n    Lo: Uint8Array;\n    LLo: Uint8Array;\n    P: Uint8Array;\n    Co: Uint8Array;\n    id: Uint8Array;\n    expr: Uint8Array;\n    TZ: Uint8Array;\n};\nexport declare const prefixLength: {\n    [key: string]: number;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/taquito-utils.d.ts",dts:"import { Buffer } from '../../../../../buffer-5.6.0/index';\nexport * from './validators';\nexport { prefix, Prefix, prefixLength } from './constants';\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport declare function encodeExpr(value: string): any;\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport declare function b58cencode(value: string | Uint8Array, prefix: Uint8Array): any;\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport declare const b58cdecode: (enc: string, prefixArg: Uint8Array) => Uint8Array;\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport declare function b58decode(payload: string): string;\n/**\n *\n * @description Base58 encode a public key using predefined prefix\n *\n * @param value Public Key to base58 encode\n */\nexport declare function encodePubKey(value: string): any;\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport declare function encodeKey(value: string): any;\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport declare function encodeKeyHash(value: string): any;\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport declare const hex2buf: (hex: string) => Uint8Array;\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport declare const mergebuf: (b1: Uint8Array, b2: Uint8Array) => Uint8Array;\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\nexport declare const mic2arr: (s: any) => any;\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport declare const buf2hex: (buffer: Buffer) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/validators.d.ts",dts:"import { Prefix } from './constants';\nexport declare enum ValidationResult {\n    NO_PREFIX_MATCHED = 0,\n    INVALID_CHECKSUM = 1,\n    INVALID_LENGTH = 2,\n    VALID = 3\n}\nexport declare function isValidPrefix(value: any): value is Prefix;\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateAddress(value: any): ValidationResult;\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateChain(value: any): ValidationResult;\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateContractAddress(value: any): ValidationResult;\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport declare function validateKeyHash(value: any): ValidationResult;\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateSignature(value: any): ValidationResult;\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validatePublicKey(value: any): ValidationResult;\n"},{name:"@airgap/coinlib-core/dependencies/src/cosmjs/index.d.ts",dts:'import Long from \'long\';\nimport _m0 from \'protobufjs/minimal.js\';\ninterface Any {\n    /**\n     * A URL/resource name that uniquely identifies the type of the serialized\n     * protocol buffer message. This string must contain at least\n     * one "/" character. The last segment of the URL\'s path must represent\n     * the fully qualified name of the type (as in\n     * `path/google.protobuf.Duration`). The name should be in a canonical form\n     * (e.g., leading "." is not accepted).\n     *\n     * In practice, teams usually precompile into the binary all types that they\n     * expect it to use in the context of Any. However, for URLs which use the\n     * scheme `http`, `https`, or no scheme, one can optionally set up a type\n     * server that maps type URLs to message definitions as follows:\n     *\n     * * If no scheme is provided, `https` is assumed.\n     * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n     *   value in binary format, or produce an error.\n     * * Applications are allowed to cache lookup results based on the\n     *   URL, or have them precompiled into a binary to avoid any\n     *   lookup. Therefore, binary compatibility needs to be preserved\n     *   on changes to types. (Use versioned type names to manage\n     *   breaking changes.)\n     *\n     * Note: this functionality is not currently available in the official\n     * protobuf release, and it is not used for type URLs beginning with\n     * type.googleapis.com.\n     *\n     * Schemes other than `http`, `https` (or the empty scheme) might be\n     * used with implementation specific semantics.\n     */\n    typeUrl: string;\n    /** Must be a valid serialized protocol buffer of the above specified type. */\n    value: Uint8Array;\n}\ninterface ModeInfo_Single {\n    /** mode is the signing mode of the single signer */\n    mode: number;\n}\ninterface ModeInfo {\n    /** single represents a single signer */\n    single?: ModeInfo_Single | undefined;\n}\ninterface Coin {\n    denom: string;\n    amount: string;\n}\nexport interface EncodeObject {\n    readonly typeUrl: string;\n    readonly value: any;\n}\ninterface StdFee {\n    readonly amount: readonly Coin[];\n    readonly gas: string;\n}\ninterface Pubkey {\n    readonly type: string;\n    readonly value: any;\n}\ninterface StdSignature {\n    readonly pub_key: Pubkey;\n    readonly signature: string;\n}\ninterface Fee {\n    /** amount is the amount of coins to be paid as a fee */\n    amount: Coin[];\n    /**\n     * gas_limit is the maximum gas that can be used in transaction processing\n     * before an out of gas error occurs\n     */\n    gasLimit: Long;\n    /**\n     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\n     * the payer must be a tx signer (and thus have signed this field in AuthInfo).\n     * setting this field does *not* change the ordering of required signers for the transaction.\n     */\n    payer: string;\n    /**\n     * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\n     * to pay fees instead of the fee payer\'s own balance. If an appropriate fee grant does not exist or the chain does\n     * not support fee grants, this will fail\n     */\n    granter: string;\n}\ninterface SignerInfo {\n    /**\n     * public_key is the public key of the signer. It is optional for accounts\n     * that already exist in state. If unset, the verifier can use the required \\\n     * signer address for this position and lookup the public key.\n     */\n    publicKey?: Any;\n    /**\n     * mode_info describes the signing mode of the signer and is a nested\n     * structure to support nested multisig pubKey\'s\n     */\n    modeInfo?: ModeInfo;\n    /**\n     * sequence is the sequence of the account, which describes the\n     * number of committed transactions signed by a given address. It is used to\n     * prevent replay attacks.\n     */\n    sequence: Long;\n}\ndeclare const ModeInfo_Single: {\n    encode(message: ModeInfo_Single, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModeInfo_Single;\n    fromJSON(object: any): ModeInfo_Single;\n    toJSON(message: ModeInfo_Single): unknown;\n    fromPartial<I extends {\n        mode?: number | undefined;\n    } & {\n        mode?: number | undefined;\n    } & Record<Exclude<keyof I, "mode">, never>>(object: I): ModeInfo_Single;\n};\ndeclare const ModeInfo: {\n    encode(message: ModeInfo, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ModeInfo;\n    fromJSON(object: any): ModeInfo;\n    toJSON(message: ModeInfo): unknown;\n    fromPartial<I extends {\n        single?: {\n            mode?: number | undefined;\n        } | undefined;\n    } & {\n        single?: ({\n            mode?: number | undefined;\n        } & {\n            mode?: number | undefined;\n        } & Record<Exclude<keyof I["single"], "mode">, never>) | undefined;\n    } & Record<Exclude<keyof I, "single">, never>>(object: I): ModeInfo;\n};\ndeclare const SignerInfo: {\n    encode(message: SignerInfo, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): SignerInfo;\n    fromJSON(object: any): SignerInfo;\n    toJSON(message: SignerInfo): unknown;\n    fromPartial<I extends {\n        publicKey?: {\n            typeUrl?: string | undefined;\n            value?: Uint8Array | undefined;\n        } | undefined;\n        modeInfo?: {\n            single?: {\n                mode?: number | undefined;\n            } | undefined;\n        } | undefined;\n        sequence?: string | number | Long | undefined;\n    } & {\n        publicKey?: ({\n            typeUrl?: string | undefined;\n            value?: Uint8Array | undefined;\n        } & {\n            typeUrl?: string | undefined;\n            value?: Uint8Array | undefined;\n        } & Record<Exclude<keyof I["publicKey"], "typeUrl" | "value">, never>) | undefined;\n        modeInfo?: ({\n            single?: {\n                mode?: number | undefined;\n            } | undefined;\n        } & {\n            single?: ({\n                mode?: number | undefined;\n            } & {\n                mode?: number | undefined;\n            } & Record<Exclude<keyof I["modeInfo"]["single"], "mode">, never>) | undefined;\n        } & Record<Exclude<keyof I["modeInfo"], "single">, never>) | undefined;\n        sequence?: string | number | (Long & {\n            high: number;\n            low: number;\n            unsigned: boolean;\n            add: (addend: string | number | Long) => Long;\n            and: (other: string | number | Long) => Long;\n            compare: (other: string | number | Long) => number;\n            comp: (other: string | number | Long) => number;\n            divide: (divisor: string | number | Long) => Long;\n            div: (divisor: string | number | Long) => Long;\n            equals: (other: string | number | Long) => boolean;\n            eq: (other: string | number | Long) => boolean;\n            getHighBits: () => number;\n            getHighBitsUnsigned: () => number;\n            getLowBits: () => number;\n            getLowBitsUnsigned: () => number;\n            getNumBitsAbs: () => number;\n            greaterThan: (other: string | number | Long) => boolean;\n            gt: (other: string | number | Long) => boolean;\n            greaterThanOrEqual: (other: string | number | Long) => boolean;\n            gte: (other: string | number | Long) => boolean;\n            ge: (other: string | number | Long) => boolean;\n            isEven: () => boolean;\n            isNegative: () => boolean;\n            isOdd: () => boolean;\n            isPositive: () => boolean;\n            isZero: () => boolean;\n            eqz: () => boolean;\n            lessThan: (other: string | number | Long) => boolean;\n            lt: (other: string | number | Long) => boolean;\n            lessThanOrEqual: (other: string | number | Long) => boolean;\n            lte: (other: string | number | Long) => boolean;\n            le: (other: string | number | Long) => boolean;\n            modulo: (other: string | number | Long) => Long;\n            mod: (other: string | number | Long) => Long;\n            rem: (other: string | number | Long) => Long;\n            multiply: (multiplier: string | number | Long) => Long;\n            mul: (multiplier: string | number | Long) => Long;\n            negate: () => Long;\n            neg: () => Long;\n            not: () => Long;\n            countLeadingZeros: () => number;\n            clz: () => number;\n            countTrailingZeros: () => number;\n            ctz: () => number;\n            notEquals: (other: string | number | Long) => boolean;\n            neq: (other: string | number | Long) => boolean;\n            ne: (other: string | number | Long) => boolean;\n            or: (other: string | number | Long) => Long;\n            shiftLeft: (numBits: number | Long) => Long;\n            shl: (numBits: number | Long) => Long;\n            shiftRight: (numBits: number | Long) => Long;\n            shr: (numBits: number | Long) => Long;\n            shiftRightUnsigned: (numBits: number | Long) => Long;\n            shru: (numBits: number | Long) => Long;\n            shr_u: (numBits: number | Long) => Long;\n            rotateLeft: (numBits: number | Long) => Long;\n            rotl: (numBits: number | Long) => Long;\n            rotateRight: (numBits: number | Long) => Long;\n            rotr: (numBits: number | Long) => Long;\n            subtract: (subtrahend: string | number | Long) => Long;\n            sub: (subtrahend: string | number | Long) => Long;\n            toInt: () => number;\n            toNumber: () => number;\n            toBytes: (le?: boolean | undefined) => number[];\n            toBytesLE: () => number[];\n            toBytesBE: () => number[];\n            toSigned: () => Long;\n            toString: (radix?: number | undefined) => string;\n            toUnsigned: () => Long;\n            xor: (other: string | number | Long) => Long;\n        } & Record<Exclude<keyof I["sequence"], "toString" | "sub" | "add" | "high" | "low" | "div" | "unsigned" | "and" | "compare" | "comp" | "divide" | "equals" | "eq" | "getHighBits" | "getHighBitsUnsigned" | "getLowBits" | "getLowBitsUnsigned" | "getNumBitsAbs" | "greaterThan" | "gt" | "greaterThanOrEqual" | "gte" | "ge" | "isEven" | "isNegative" | "isOdd" | "isPositive" | "isZero" | "eqz" | "lessThan" | "lt" | "lessThanOrEqual" | "lte" | "le" | "modulo" | "mod" | "rem" | "multiply" | "mul" | "negate" | "neg" | "not" | "countLeadingZeros" | "clz" | "countTrailingZeros" | "ctz" | "notEquals" | "neq" | "ne" | "or" | "shiftLeft" | "shl" | "shiftRight" | "shr" | "shiftRightUnsigned" | "shru" | "shr_u" | "rotateLeft" | "rotl" | "rotateRight" | "rotr" | "subtract" | "toInt" | "toNumber" | "toBytes" | "toBytesLE" | "toBytesBE" | "toSigned" | "toUnsigned" | "xor">, never>) | undefined;\n    } & Record<Exclude<keyof I, "sequence" | "publicKey" | "modeInfo">, never>>(object: I): SignerInfo;\n};\ndeclare const Coin: {\n    encode(message: Coin, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Coin;\n    fromJSON(object: any): Coin;\n    toJSON(message: Coin): unknown;\n    fromPartial<I extends {\n        denom?: string | undefined;\n        amount?: string | undefined;\n    } & {\n        denom?: string | undefined;\n        amount?: string | undefined;\n    } & Record<Exclude<keyof I, "amount" | "denom">, never>>(object: I): Coin;\n};\ndeclare const Fee: {\n    encode(message: Fee, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Fee;\n    fromJSON(object: any): Fee;\n    toJSON(message: Fee): unknown;\n    fromPartial<I extends {\n        amount?: {\n            denom?: string | undefined;\n            amount?: string | undefined;\n        }[] | undefined;\n        gasLimit?: string | number | Long | undefined;\n        payer?: string | undefined;\n        granter?: string | undefined;\n    } & {\n        amount?: ({\n            denom?: string | undefined;\n            amount?: string | undefined;\n        }[] & ({\n            denom?: string | undefined;\n            amount?: string | undefined;\n        } & {\n            denom?: string | undefined;\n            amount?: string | undefined;\n        } & Record<Exclude<keyof I["amount"][number], "amount" | "denom">, never>)[] & Record<Exclude<keyof I["amount"], number | "toString" | "toLocaleString" | "concat" | "indexOf" | "lastIndexOf" | "slice" | "length" | "includes" | "push" | "reverse" | "map" | "filter" | "pop" | "join" | "shift" | "sort" | "splice" | "unshift" | "every" | "some" | "forEach" | "reduce" | "reduceRight" | "find" | "findIndex" | "fill" | "copyWithin" | "entries" | "keys" | "values">, never>) | undefined;\n        gasLimit?: string | number | (Long & {\n            high: number;\n            low: number;\n            unsigned: boolean;\n            add: (addend: string | number | Long) => Long;\n            and: (other: string | number | Long) => Long;\n            compare: (other: string | number | Long) => number;\n            comp: (other: string | number | Long) => number;\n            divide: (divisor: string | number | Long) => Long;\n            div: (divisor: string | number | Long) => Long;\n            equals: (other: string | number | Long) => boolean;\n            eq: (other: string | number | Long) => boolean;\n            getHighBits: () => number;\n            getHighBitsUnsigned: () => number;\n            getLowBits: () => number;\n            getLowBitsUnsigned: () => number;\n            getNumBitsAbs: () => number;\n            greaterThan: (other: string | number | Long) => boolean;\n            gt: (other: string | number | Long) => boolean;\n            greaterThanOrEqual: (other: string | number | Long) => boolean;\n            gte: (other: string | number | Long) => boolean;\n            ge: (other: string | number | Long) => boolean;\n            isEven: () => boolean;\n            isNegative: () => boolean;\n            isOdd: () => boolean;\n            isPositive: () => boolean;\n            isZero: () => boolean;\n            eqz: () => boolean;\n            lessThan: (other: string | number | Long) => boolean;\n            lt: (other: string | number | Long) => boolean;\n            lessThanOrEqual: (other: string | number | Long) => boolean;\n            lte: (other: string | number | Long) => boolean;\n            le: (other: string | number | Long) => boolean;\n            modulo: (other: string | number | Long) => Long;\n            mod: (other: string | number | Long) => Long;\n            rem: (other: string | number | Long) => Long;\n            multiply: (multiplier: string | number | Long) => Long;\n            mul: (multiplier: string | number | Long) => Long;\n            negate: () => Long;\n            neg: () => Long;\n            not: () => Long;\n            countLeadingZeros: () => number;\n            clz: () => number;\n            countTrailingZeros: () => number;\n            ctz: () => number;\n            notEquals: (other: string | number | Long) => boolean;\n            neq: (other: string | number | Long) => boolean;\n            ne: (other: string | number | Long) => boolean;\n            or: (other: string | number | Long) => Long;\n            shiftLeft: (numBits: number | Long) => Long;\n            shl: (numBits: number | Long) => Long;\n            shiftRight: (numBits: number | Long) => Long;\n            shr: (numBits: number | Long) => Long;\n            shiftRightUnsigned: (numBits: number | Long) => Long;\n            shru: (numBits: number | Long) => Long;\n            shr_u: (numBits: number | Long) => Long;\n            rotateLeft: (numBits: number | Long) => Long;\n            rotl: (numBits: number | Long) => Long;\n            rotateRight: (numBits: number | Long) => Long;\n            rotr: (numBits: number | Long) => Long;\n            subtract: (subtrahend: string | number | Long) => Long;\n            sub: (subtrahend: string | number | Long) => Long;\n            toInt: () => number;\n            toNumber: () => number;\n            toBytes: (le?: boolean | undefined) => number[];\n            toBytesLE: () => number[];\n            toBytesBE: () => number[];\n            toSigned: () => Long;\n            toString: (radix?: number | undefined) => string;\n            toUnsigned: () => Long;\n            xor: (other: string | number | Long) => Long;\n        } & Record<Exclude<keyof I["gasLimit"], "toString" | "sub" | "add" | "high" | "low" | "div" | "unsigned" | "and" | "compare" | "comp" | "divide" | "equals" | "eq" | "getHighBits" | "getHighBitsUnsigned" | "getLowBits" | "getLowBitsUnsigned" | "getNumBitsAbs" | "greaterThan" | "gt" | "greaterThanOrEqual" | "gte" | "ge" | "isEven" | "isNegative" | "isOdd" | "isPositive" | "isZero" | "eqz" | "lessThan" | "lt" | "lessThanOrEqual" | "lte" | "le" | "modulo" | "mod" | "rem" | "multiply" | "mul" | "negate" | "neg" | "not" | "countLeadingZeros" | "clz" | "countTrailingZeros" | "ctz" | "notEquals" | "neq" | "ne" | "or" | "shiftLeft" | "shl" | "shiftRight" | "shr" | "shiftRightUnsigned" | "shru" | "shr_u" | "rotateLeft" | "rotl" | "rotateRight" | "rotr" | "subtract" | "toInt" | "toNumber" | "toBytes" | "toBytesLE" | "toBytesBE" | "toSigned" | "toUnsigned" | "xor">, never>) | undefined;\n        payer?: string | undefined;\n        granter?: string | undefined;\n    } & Record<Exclude<keyof I, "amount" | "gasLimit" | "payer" | "granter">, never>>(object: I): Fee;\n};\ndeclare const Any: {\n    encode(message: Any, writer?: _m0.Writer): _m0.Writer;\n    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Any;\n    fromJSON(object: any): Any;\n    toJSON(message: Any): unknown;\n    fromPartial<I extends {\n        typeUrl?: string | undefined;\n        value?: Uint8Array | undefined;\n    } & {\n        typeUrl?: string | undefined;\n        value?: Uint8Array | undefined;\n    } & Record<Exclude<keyof I, "typeUrl" | "value">, never>>(object: I): Any;\n};\nexport declare const prepareSignBytes: (txBodyEncodeObject: EncodeObject, fee: StdFee, pubKey: Uint8Array, sequence: number, chainId: string, accountNumber: number) => Promise<Uint8Array>;\nexport declare const encodeTxBytes: (txBodyEncodeObject: EncodeObject, fee: StdFee, pubKey: Uint8Array, sequence: number, signature: StdSignature, chainId: string, accountNumber: number) => Promise<Uint8Array>;\nexport declare const decodeTxBytes: (bytes: Uint8Array) => Promise<{\n    messages: EncodeObject[];\n    memo: string;\n    fee: Fee | undefined;\n    signerInfos: SignerInfo[];\n}>;\nexport {};\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/PrivateKey.d.ts",dts:"/// <reference types=\"node\" />\nimport PublicKey from './PublicKey';\nexport default class PrivateKey {\n    static fromHex(hex: string): PrivateKey;\n    readonly secret: Buffer;\n    readonly publicKey: PublicKey;\n    constructor(secret?: Buffer);\n    toHex(): string;\n    encapsulate(pub: PublicKey): Buffer;\n    multiply(pub: PublicKey): Buffer;\n    equals(other: PrivateKey): boolean;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/PublicKey.d.ts",dts:"/// <reference types=\"node\" />\nimport PrivateKey from './PrivateKey';\nexport default class PublicKey {\n    static fromHex(hex: string): PublicKey;\n    readonly uncompressed: Buffer;\n    readonly compressed: Buffer;\n    constructor(buffer: Buffer);\n    toHex(compressed?: boolean): string;\n    decapsulate(priv: PrivateKey): Buffer;\n    equals(other: PublicKey): boolean;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/index.d.ts",dts:'export { default as PrivateKey } from "./PrivateKey";\nexport { default as PublicKey } from "./PublicKey";\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/index.d.ts",dts:'/// <reference types="node" />\nimport { aesDecrypt, aesEncrypt, decodeHex, getValidSecret, remove0x } from "./utils";\nexport declare function encrypt(receiverRawPub: string | Buffer, msg: Buffer): Buffer;\nexport declare function decrypt(receiverRawPrv: string | Buffer, msg: Buffer): Buffer;\nexport { PrivateKey, PublicKey } from "./keys";\nexport declare const utils: {\n    aesDecrypt: typeof aesDecrypt;\n    aesEncrypt: typeof aesEncrypt;\n    decodeHex: typeof decodeHex;\n    getValidSecret: typeof getValidSecret;\n    remove0x: typeof remove0x;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/utils.d.ts",dts:'/// <reference types="node" />\nexport declare function remove0x(hex: string): string;\nexport declare function decodeHex(hex: string): Buffer;\nexport declare function getValidSecret(): Buffer;\nexport declare function aesEncrypt(key: Buffer, plainText: Buffer): Buffer;\nexport declare function aesDecrypt(key: Buffer, cipherText: Buffer): Buffer;\n'},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/hd-key.d.ts",dts:"import * as nacl from '../../tweetnacl-1.0.1/nacl';\nexport declare function getMasterKeyFromSeed(seed: any): {\n    privateKey: any;\n    chainCode: any;\n};\nexport declare function deriveChild({ privateKey, chainCode }: {\n    privateKey: any;\n    chainCode: any;\n}, index: any): {\n    privateKey: any;\n    chainCode: any;\n};\nexport declare function getKeyPair(privateKey: any): nacl.SignKeyPair;\nexport declare function derivePathFromKey(path: any, key: any): any;\nexport declare function derivePathFromSeed(path: any, seed: any): any;\n"},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/hd-wallet.d.ts",dts:'export declare function generateHDWallet(seed: any): any;\nexport declare function generateWalletUsingDerivationPath(seed: any, derivationPath?: string): import("../../tweetnacl-1.0.1/nacl").SignKeyPair;\nexport declare function getHDWalletAccounts(wallet: any, accountCount: any): any;\n'},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/index.d.ts",dts:"export * from './hd-wallet';\n"},{name:"@airgap/coinlib-core/errors/coinlib-error.d.ts",dts:'export declare enum Domain {\n    SERIALIZER = "SERIALIZER",\n    SUBPROTOCOLS = "SUBPROTOCOLS",\n    WALLET = "WALLET",\n    BITCOIN = "BITCOIN",\n    ETHEREUM = "ETHEREUM",\n    ERC20 = "ERC20",\n    COSMOS = "COSMOS",\n    SUBSTRATE = "SUBSTRATE",\n    AETERNITY = "AETERNITY",\n    GROESTLCOIN = "GROESTLCOIN",\n    TEZOS = "TEZOS",\n    TEZOSFA = "TEZOSFA",\n    UTILS = "UTILS",\n    ACTIONS = "ACTIONS"\n}\nexport declare class CoinlibError extends Error {\n    domain: Domain;\n    code: string;\n    description?: string | undefined;\n    constructor(domain: Domain, code: string, description?: string | undefined);\n}\nexport declare class CoinlibAssertionError extends Error {\n    domain: Domain;\n    code: string;\n    expected: string;\n    actual: any;\n    constructor(domain: Domain, code: string, expected: string, actual: any);\n}\n'},{name:"@airgap/coinlib-core/errors/index.d.ts",dts:'import { AxiosError } from \'../dependencies/src/axios-0.19.0\';\nimport { CoinlibError, Domain } from \'./coinlib-error\';\nexport declare enum SerializerErrorType {\n    SERIALIZER_VERSION_MISMATCH = "SERIALIZER_VERSION_MISMATCH",\n    PROTOCOL_NOT_SUPPORTED = "PROTOCOL_NOT_SUPPORTED",\n    PROTOCOL_VERSION_MISMATCH = "PROTOCOL_VERSION_MISMATCH",\n    TYPE_NOT_SUPPORTED = "TYPE_NOT_SUPPORTED",\n    INVALID_SCHEMA = "INVALID_SCHEMA",\n    INVALID_SCHEMA_TYPE = "INVALID_SCHEMA_TYPE",\n    INVALID_PAYLOAD = "INVALID_PAYLOAD",\n    INVALID_HEX_STRING = "INVALID_HEX_STRING",\n    INVALID_STRING = "INVALID_STRING",\n    SCHEMA_ALREADY_EXISTS = "SCHEMA_ALREADY_EXISTS",\n    SCHEMA_DOES_NOT_EXISTS = "SCHEMA_DOES_NOT_EXISTS",\n    UNEXPECTED_PAYLOAD = "UNEXPECTED_PAYLOAD",\n    PAYLOAD_TYPE_UNKNOWN = "PAYLOAD_TYPE_UNKNOWN",\n    PAYLOAD_TYPE_MISMATCH = "PAYLOAD_TYPE_MISMATCH",\n    PAYLOAD_TYPE_NOT_SUPPORTED = "PAYLOAD_TYPE_NOT_SUPPORTED",\n    PROPERTY_IS_EMPTY = "PROPERTY_IS_EMPTY",\n    PROPERTY_INVALID = "PROPERTY_INVALID"\n}\nexport declare enum ProtocolErrorType {\n    NETWORK = "NETWORK",\n    CONDITION_VIOLATION = "CONDITION_VIOLATION",\n    UNSUPPORTED = "UNSUPPORTED",\n    NOT_FOUND = "NOT_FOUND",\n    BALANCE = "BALANCE",\n    PROPERTY_UNDEFINED = "PROPERTY_UNDEFINED",\n    OPERATION_FAILED = "OPERATION_FAILED",\n    NOT_IMPLEMENTED = "NOT_IMPLEMENTED",\n    INVALID_VALUE = "INVALID_VALUE"\n}\n/**\n * Gets thrown if an error occurs when making a network request\n * Partial<AxiosError> is either an AxiosError or an AxiosResponse,\n * as we sometimes want to throw an Error even though we get a 200 response\n * from the API (as in case of internal operation errors for Tezos).\n */\nexport declare class NetworkError extends CoinlibError {\n    data: string;\n    status: number | undefined;\n    url: string | undefined;\n    method: string | undefined;\n    requestBody?: unknown;\n    constructor(domain: Domain, error: Partial<AxiosError>, description?: string);\n}\n/**\n * Gets thrown if a value ist expected to fulfill a certain condition such as having a certain length, but the condition is not satisfied\n */\nexport declare class ConditionViolationError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if a variable assumes a value for which an operation is not supported\n */\nexport declare class UnsupportedError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if a variable is unexpectedly undefined\n */\nexport declare class NotFoundError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if an account has an insufficient balance to perform a certain kind of operation\n */\nexport declare class BalanceError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if an accessed object property is undefined\n */\nexport declare class PropertyUndefinedError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if an internal method fails\n */\nexport declare class OperationFailedError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if a method is executed which is not implemented\n */\nexport declare class NotImplementedError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\n/**\n * Gets thrown if a variable has a value which cannot be handled\n */\nexport declare class InvalidValueError extends CoinlibError {\n    constructor(domain: Domain, description?: string);\n}\nexport declare class SerializerError extends CoinlibError {\n    constructor(code: string, description?: string);\n}\n/**\n * Gets thrown if the serializer version does not match\n */\nexport declare class SerializerVersionMismatch extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the serializer cannot handle the specified coin/protocol\n */\nexport declare class ProtocolNotSupported extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the serializer CAN handle the specified coin/protocol, but not in this version\n */\nexport declare class ProtocolVersionMismatch extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the specified Type is not supported\n */\nexport declare class TypeNotSupported extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the schema in the serializer is invalid\n */\nexport declare class InvalidSchema extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the 2 types provided are not compatible\n */\nexport declare class InvalidSchemaType extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the payload that is being decoded does not match the schema\n */\nexport declare class InvalidPayloadError extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the string is not a valid hex string\n */\nexport declare class InvalidHexString extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the string starts with "0x". This causes problems with RLP\n */\nexport declare class InvalidString extends SerializerError {\n    constructor(description?: string);\n}\n'},{name:"@airgap/coinlib-core/errors/network.d.ts",dts:""},{name:"@airgap/coinlib-core/interfaces/IAirGapSignedTransaction.d.ts",dts:"export declare type IAirGapSignedTransaction = string;\n"},{name:"@airgap/coinlib-core/interfaces/IAirGapTransaction.d.ts",dts:'import { AeternityTransactionCursor } from \'../protocols/aeternity/AeternityTypes\';\nimport { EthereumTransactionCursor } from \'../protocols/ethereum/EthereumTypes\';\nimport { ProtocolNetwork } from \'../utils/ProtocolNetwork\';\nimport { ProtocolSymbols } from \'../utils/ProtocolSymbols\';\nimport { BitcoinBlockbookTransactionCursor, BitcoinTransactionCursor } from \'./../protocols/bitcoin/BitcoinTypes\';\nimport { CosmosTransactionCursor } from \'./../protocols/cosmos/CosmosTypes\';\nimport { SubstrateTransactionCursor } from \'./../protocols/substrate/SubstrateTypes\';\nimport { TezosTransactionCursor } from \'./../protocols/tezos/types/TezosTransactionCursor\';\nexport declare enum AirGapTransactionType {\n    SPEND = "Spend Transaction",\n    DELEGATE = "Delegation",\n    UNDELEGATE = "Undelegate"\n}\nexport declare enum AirGapTransactionStatus {\n    APPLIED = "applied",\n    FAILED = "failed"\n}\nexport declare enum AirGapTransactionWarningType {\n    SUCCESS = "success",\n    NOTE = "note",\n    WARNING = "warning",\n    ERROR = "error"\n}\nexport interface AirGapTransactionWarning {\n    type: AirGapTransactionWarningType;\n    title: string;\n    description: string;\n    icon?: string;\n    actions?: ({\n        text: string;\n        link: string;\n    } | {\n        text: string;\n        action(): Promise<void>;\n    })[];\n}\nexport interface IAirGapTransaction {\n    from: string[];\n    to: string[];\n    isInbound: boolean;\n    amount: string;\n    fee: string;\n    timestamp?: number;\n    protocolIdentifier: ProtocolSymbols;\n    network: ProtocolNetwork;\n    hash?: string;\n    blockHeight?: string;\n    data?: string;\n    extra?: any;\n    status?: AirGapTransactionStatus;\n    warnings?: AirGapTransactionWarning[];\n    transactionDetails?: any;\n}\nexport declare type IProtocolTransactionCursor = EthereumTransactionCursor | BitcoinTransactionCursor | TezosTransactionCursor | AeternityTransactionCursor | SubstrateTransactionCursor | CosmosTransactionCursor | BitcoinBlockbookTransactionCursor;\nexport interface IAirGapTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: IProtocolTransactionCursor;\n}\n'},{name:"@airgap/coinlib-core/interfaces/IAirGapWallet.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nexport interface IAirGapWallet {\n    addresses: string[];\n    protocol: ICoinProtocol;\n    deriveAddresses(amount: number): Promise<string[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityAddress.d.ts",dts:"import { CoinAddress } from '../ICoinProtocol';\nexport declare class AeternityAddress implements CoinAddress {\n    private readonly value;\n    private constructor();\n    static from(publicKey: string): AeternityAddress;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Ed25519CryptoClient } from '../Ed25519CryptoClient';\nexport declare class AeternityCryptoClient extends Ed25519CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedAeternityTransaction } from '../../serializer/schemas/definitions/signed-transaction-aeternity';\nimport { UnsignedAeternityTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-aeternity';\nimport { RawAeternityTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { AeternityTransactionCursor, AeternityTransactionResult } from './AeternityTypes';\nimport { AeternityAddress } from './AeternityAddress';\nimport { AeternityCryptoClient } from './AeternityCryptoClient';\nimport { AeternityProtocolOptions } from './AeternityProtocolOptions';\nexport declare class AeternityProtocol extends NonExtendedProtocol implements ICoinProtocol {\n    readonly options: AeternityProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    feeDefaults: {\n        low: string;\n        medium: string;\n        high: string;\n    };\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    defaultNetworkId: string;\n    private readonly feesURL;\n    readonly cryptoClient: AeternityCryptoClient;\n    constructor(options?: AeternityProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    /**\n     * Returns the PublicKey as String, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    /**\n     * Returns the PrivateKey as Buffer, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<AeternityAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<AeternityAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: AeternityAddress): Promise<AeternityAddress>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: AeternityTransactionCursor): Promise<AeternityTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: AeternityTransactionCursor): Promise<AeternityTransactionResult>;\n    protected getPageNumber(limit: number, offset: number): number;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawAeternityTransaction): Promise<IAirGapSignedTransaction>;\n    private decodeTx;\n    getTransactionDetails(unsignedTx: UnsignedAeternityTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedAeternityTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        payload?: string;\n    }): Promise<RawAeternityTransaction>;\n    /**\n     * This is a function that we only use to fix incompatibilitis with old vault versions that are unable to understand b64 encoded Txs.\n     *\n     * @deprecated\n     * @param preparedTx\n     */\n    convertTxToBase58(preparedTx: RawAeternityTransaction): RawAeternityTransaction;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    private toHexBuffer;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class AeternalBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class AeternityProtocolNetwork extends ProtocolNetwork<undefined> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: undefined);\n}\nexport declare class AeternityProtocolOptions implements ProtocolOptions<undefined> {\n    readonly network: AeternityProtocolNetwork;\n    readonly config: undefined;\n    constructor(network?: AeternityProtocolNetwork, config?: undefined);\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface AeternityTransactionCursor {\n    page: number;\n}\nexport interface AeternityTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: AeternityTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinAddress.d.ts",dts:"import { CoinAddress } from '../ICoinProtocol';\nexport declare class BitcoinAddress implements CoinAddress {\n    protected readonly value: string;\n    readonly visibilityDerivationIndex?: number | undefined;\n    readonly addressDerivationIndex?: number | undefined;\n    constructor(value: string, visibilityDerivationIndex?: number | undefined, addressDerivationIndex?: number | undefined);\n    static from(node: any, visibilityDerivationIndex?: number, addressDerivationIndex?: number): BitcoinAddress;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { ICoinProtocol } from '../..';\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nexport declare class BitcoinCryptoClient extends Secp256k1CryptoClient {\n    private readonly protocol;\n    private readonly bitcoinJSMessage;\n    constructor(protocol: ICoinProtocol, bitcoinJSMessage: any);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedBitcoinTransaction } from '../../serializer/schemas/definitions/signed-transaction-bitcoin';\nimport { UnsignedTransaction } from '../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawBitcoinTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { BitcoinBlockbookTransactionCursor, BitcoinBlockbookTransactionResult } from './BitcoinTypes';\nimport { BitcoinAddress } from './BitcoinAddress';\nimport { BitcoinProtocolOptions } from './BitcoinProtocolOptions';\nimport { BitcoinCryptoClient } from './BitcoinCryptoClient';\nexport interface UTXOResponse {\n    txid: string;\n    vout: number;\n    value: string;\n    height: number;\n    confirmations: number;\n    address: string;\n    path: string;\n}\nexport interface Vin {\n    txid: string;\n    sequence: any;\n    n: number;\n    addresses: string[];\n    value: string;\n    hex: string;\n}\nexport interface Vout {\n    value: string;\n    n: number;\n    hex: string;\n    addresses: string[];\n    spent?: boolean;\n}\nexport interface Transaction {\n    txid: string;\n    version: number;\n    vin: Vin[];\n    vout: Vout[];\n    blockhash: string;\n    blockHeight: number;\n    confirmations: number;\n    blockTime: number;\n    value: string;\n    valueIn: string;\n    fees: string;\n    hex: string;\n}\nexport interface Token {\n    type: string;\n    name: string;\n    path: string;\n    transfers: number;\n    decimals: number;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n}\nexport interface XPubResponse {\n    page: number;\n    totalPages: number;\n    itemsOnPage: number;\n    address: string;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n    unconfirmedBalance: string;\n    unconfirmedTxs: number;\n    txs: number;\n    transactions?: Transaction[];\n    totalTokens?: number;\n    tokens?: Token[];\n}\nexport interface AddressResponse {\n    page: number;\n    totalPages: number;\n    itemsOnPage: number;\n    address: string;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n    unconfirmedBalance: string;\n    unconfirmedTxs: number;\n    txs: number;\n    transactions?: Transaction[];\n}\nexport declare class BitcoinProtocol implements ICoinProtocol {\n    readonly options: BitcoinProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    subProtocols: never[];\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    readonly cryptoClient: BitcoinCryptoClient;\n    constructor(options?: BitcoinProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string): Promise<BitcoinAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<BitcoinAddress[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<BitcoinAddress>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<BitcoinAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: BitcoinAddress): Promise<BitcoinAddress>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawBitcoinTransaction): Promise<IAirGapSignedTransaction>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: RawBitcoinTransaction): Promise<string>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedBitcoinTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset?: number): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string, extras: unknown): Promise<RawBitcoinTransaction>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string): Promise<RawBitcoinTransaction>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor?: BitcoinBlockbookTransactionCursor, addressOffset?: number): Promise<BitcoinBlockbookTransactionResult>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: BitcoinBlockbookTransactionCursor): Promise<BitcoinBlockbookTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: BitcoinBlockbookTransactionCursor): Promise<BitcoinBlockbookTransactionResult>;\n    private containsSome;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class BitcoinProtocolNetworkExtras {\n    readonly indexerApi: string;\n    readonly network: any;\n    constructor(indexerApi?: string, network?: any);\n}\nexport declare class BlockcypherBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class BitcoinProtocolNetwork extends ProtocolNetwork<BitcoinProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: BitcoinProtocolNetworkExtras);\n}\nexport declare class BitcoinProtocolConfig {\n    readonly bitcoinJSLib: any;\n    constructor(bitcoinJSLib?: any);\n}\nexport declare class BitcoinProtocolOptions implements ProtocolOptions<BitcoinProtocolConfig> {\n    readonly network: BitcoinProtocolNetwork;\n    readonly config: BitcoinProtocolConfig;\n    constructor(network?: BitcoinProtocolNetwork, config?: BitcoinProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinSegwitAddress.d.ts",dts:"import { BitcoinAddress } from './BitcoinAddress';\nexport declare class BitcoinSegwitAddress extends BitcoinAddress {\n    constructor(value: string, visibilityDerivationIndex?: number, addressDerivationIndex?: number);\n    static from(node: any, visibilityDerivationIndex?: number, addressDerivationIndex?: number): BitcoinSegwitAddress;\n    static fromAddress(address: string): BitcoinSegwitAddress;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinSegwitProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { BitcoinProtocol, BitcoinProtocolOptions, IAirGapTransaction, ProtocolSymbols, SignedBitcoinSegwitTransaction, UnsignedTransaction } from '../..';\nimport { BitcoinSegwitAddress } from './BitcoinSegwitAddress';\nexport declare class BitcoinSegwitProtocol extends BitcoinProtocol {\n    name: string;\n    identifier: ProtocolSymbols;\n    standardDerivationPath: string;\n    addressPlaceholder: string;\n    constructor(options?: BitcoinProtocolOptions);\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string): Promise<BitcoinSegwitAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<BitcoinSegwitAddress[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<BitcoinSegwitAddress>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<BitcoinSegwitAddress[]>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedBitcoinSegwitTransaction): Promise<IAirGapTransaction[]>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string, extras: {\n        masterFingerprint: string;\n        replaceByFee: boolean;\n    }): Promise<any>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any): Promise<string>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinTestnetProtocol.d.ts",dts:"import { BitcoinProtocol } from './BitcoinProtocol';\nexport declare class BitcoinTestnetProtocol extends BitcoinProtocol {\n    name: string;\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface BitcoinTransactionCursor {\n    offset: number;\n}\nexport interface BitcoinTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: BitcoinTransactionCursor;\n}\nexport interface BitcoinBlockbookTransactionCursor {\n    page: number;\n}\nexport interface BitcoinBlockbookTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: BitcoinBlockbookTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosDelegateMessage.d.ts",dts:"import { EncodeObject } from '../../../dependencies/src/cosmjs';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoin } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosDelegateMessage implements CosmosMessage {\n    readonly delegatorAddress: string;\n    readonly validatorAddress: string;\n    readonly amount: CosmosCoin;\n    readonly type: CosmosMessageType;\n    constructor(delegatorAddress: string, validatorAddress: string, amount: CosmosCoin, undelegate?: boolean);\n    toEncodeObject(): EncodeObject;\n    static fromEncodeObject(encodeObject: EncodeObject): CosmosDelegateMessage;\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosDelegateMessage;\n    toRPCBody(): any;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    static fromRPCBody(json: any): CosmosDelegateMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosMessage.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoinJSON } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { Encodable, JSONConvertible, RPCConvertible } from '../CosmosTransaction';\nexport interface CosmosMessageJSON {\n    type: CosmosMessageTypeIndex;\n    amount: CosmosCoinJSON[];\n    fromAddress: string;\n    toAddress: string;\n}\nexport declare enum CosmosMessageTypeIndex {\n    SEND = 0,\n    DELEGATE = 1,\n    UNDELEGATE = 2,\n    WITHDRAW_DELEGATION_REWARD = 3\n}\nexport declare class CosmosMessageType {\n    static Send: CosmosMessageType;\n    static Delegate: CosmosMessageType;\n    static Undelegate: CosmosMessageType;\n    static WithdrawDelegationReward: CosmosMessageType;\n    readonly index: CosmosMessageTypeIndex;\n    readonly value: string;\n    constructor(index: CosmosMessageTypeIndex);\n}\nexport interface CosmosMessage extends JSONConvertible, RPCConvertible, Encodable {\n    type: CosmosMessageType;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    toJSON(): CosmosMessageJSON;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosSendMessage.d.ts",dts:"import { EncodeObject } from '../../../dependencies/src/cosmjs';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoin } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosSendMessage implements CosmosMessage {\n    readonly fromAddress: string;\n    readonly toAddress: string;\n    readonly amount: CosmosCoin[];\n    readonly type: CosmosMessageType;\n    constructor(fromAddress: string, toAddress: string, amount: CosmosCoin[]);\n    toEncodeObject(): EncodeObject;\n    static fromEncodeObject(encodeObject: EncodeObject): CosmosSendMessage;\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosSendMessage;\n    toRPCBody(): any;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    static fromRPCBody(json: any): CosmosSendMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosWithdrawDelegationRewardMessage.d.ts",dts:"import { EncodeObject } from '../../../dependencies/src/cosmjs';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosWithdrawDelegationRewardMessage implements CosmosMessage {\n    readonly delegatorAddress: string;\n    readonly validatorAddress: string;\n    readonly type: CosmosMessageType;\n    constructor(delegatorAddress: string, validatorAddress: string);\n    toEncodeObject(): EncodeObject;\n    static fromEncodeObject(encodeObject: EncodeObject): CosmosWithdrawDelegationRewardMessage;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosWithdrawDelegationRewardMessage;\n    toRPCBody(): {\n        type: string;\n        value: {\n            delegator_address: string;\n            validator_address: string;\n        };\n    };\n    static fromRPCBody(json: any): CosmosWithdrawDelegationRewardMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosAddress.d.ts",dts:"import { CoinAddress } from '../ICoinProtocol';\nexport declare class CosmosAddress implements CoinAddress {\n    private readonly value;\n    private static readonly addressPrefix;\n    private constructor();\n    static from(publicKey: string): CosmosAddress;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosCoin.d.ts",dts:"import { JSONConvertible, RPCConvertible } from './CosmosTransaction';\nexport interface CosmosCoinJSON {\n    denom: string;\n    amount: string;\n}\nexport declare class CosmosCoin implements JSONConvertible, RPCConvertible {\n    private static readonly supportedDenominations;\n    readonly denom: string;\n    readonly amount: string;\n    constructor(denom: string, amount: string);\n    toJSON(): CosmosCoinJSON;\n    static fromJSON(json: CosmosCoinJSON): CosmosCoin;\n    toRPCBody(): any;\n    static fromRPCBody(json: any): CosmosCoin;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nexport declare class CosmosCryptoClient extends Secp256k1CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosFee.d.ts",dts:"import { CosmosCoin } from './CosmosCoin';\nimport { JSONConvertible, RPCConvertible } from './CosmosTransaction';\nexport declare class CosmosFee implements JSONConvertible, RPCConvertible {\n    readonly amount: CosmosCoin[];\n    readonly gas: string;\n    constructor(amount: CosmosCoin[], gas: string);\n    toJSON(): {\n        amount: import(\"./CosmosCoin\").CosmosCoinJSON[];\n        gas: string;\n    };\n    static fromJSON(json: any): CosmosFee;\n    toRPCBody(): any;\n    static fromRPCBody(json: any): CosmosFee;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosNodeClient.d.ts",dts:"import BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport interface CosmosNodeInfo {\n    protocol_version: {\n        p2p: string;\n        block: string;\n        app: string;\n    };\n    id: string;\n    listen_addr: string;\n    network: string;\n    version: string;\n    channels: string;\n    moniker: string;\n    other: {\n        tx_index: string;\n        rpc_address: string;\n    };\n}\nexport interface CosmosAccount {\n    type: string;\n    value: CosmosAccountValue;\n}\nexport interface CosmosAccountValue {\n    account_number: string;\n    address: string;\n    coins: CosmosAccountCoin[];\n    sequence?: string;\n    public_key?: string;\n}\nexport interface CosmosAccountCoin {\n    denom: string;\n    amount: string;\n}\nexport interface CosmosDelegation {\n    delegation: {\n        delegator_address: string;\n        validator_address: string;\n        shares: string;\n    };\n    balance: {\n        denom: string;\n        amount: string;\n    };\n}\nexport interface CosmosUnbondingDelegation {\n    delegator_address: string;\n    validator_address: string;\n    entries: {\n        creation_height: string;\n        completion_time: string;\n        initial_balance: string;\n        balance: string;\n    }[];\n}\nexport interface CosmosValidator {\n    operator_address: string;\n    consensus_pubkey: string;\n    jailed: boolean;\n    status: number;\n    tokens: string;\n    delegator_shares: string;\n    description: CosmosValidatorDescription;\n    unbonding_height: string;\n    unbonding_time: string;\n    commission: CosmosValidatorCommission;\n    min_self_delegation: string;\n}\nexport interface CosmosValidatorDescription {\n    moniker: string;\n    identity: string;\n    website: string;\n    details: string;\n}\nexport interface CosmosValidatorCommission {\n    commission_rates: CosmosValidatorCommissionRate;\n    update_time: string;\n}\nexport interface CosmosValidatorCommissionRate {\n    rate: string;\n    max_rate: string;\n    max_change_rate: string;\n}\nexport interface TxResponse {\n    height: string;\n    txhash: string;\n    codespace: string;\n    code: number;\n    data: string;\n    raw_log: string;\n    logs: any[];\n    info: string;\n    gas_wanted: string;\n    gas_used: string;\n    tx?: any;\n    timestamp: string;\n}\nexport interface CosmosBroadcastSignedTransactionResponse {\n    tx_response: TxResponse;\n}\nexport interface CosmosRewardDetails {\n    validator_address: string;\n    reward: {\n        denom: string;\n        amount: number;\n    }[];\n}\nexport interface CosmosPagedSendTxsResponse {\n    total_count: string;\n    count: string;\n    page_number: string;\n    page_total: string;\n    limit: string;\n    txs: CosmosSendTx[];\n}\nexport interface CosmosSendTx {\n    height: string;\n    txhash: string;\n    gas_wanted: string;\n    gas_used: string;\n    tx: {\n        type: string;\n        value: {\n            msg: [\n                {\n                    type: string;\n                    value: {\n                        from_address: string;\n                        to_address: string;\n                        amount: [\n                            {\n                                denom: string;\n                                amount: string;\n                            }\n                        ];\n                    };\n                }\n            ];\n            fee: {\n                amount: [\n                    {\n                        denom: string;\n                        amount: string;\n                    }\n                ];\n                gas: string;\n            };\n            memo: string;\n        };\n    };\n    timestamp: string;\n}\nexport declare class CosmosNodeClient {\n    readonly baseURL: string;\n    useCORSProxy: boolean;\n    constructor(baseURL: string, useCORSProxy?: boolean);\n    fetchBalance(address: string, totalBalance?: boolean): Promise<BigNumber>;\n    fetchSendTransactionsFor(address: string, page?: number, limit?: number, isSender?: boolean): Promise<CosmosPagedSendTxsResponse>;\n    fetchNodeInfo(): Promise<CosmosNodeInfo>;\n    broadcastSignedTransaction(tx_bytes: string): Promise<string>;\n    fetchAccount(address: string): Promise<CosmosAccount>;\n    fetchDelegations(address: string, filterEmpty?: boolean): Promise<CosmosDelegation[]>;\n    fetchTotalDelegatedAmount(address: string): Promise<BigNumber>;\n    fetchValidator(address: string): Promise<CosmosValidator>;\n    fetchValidators(): Promise<CosmosValidator[]>;\n    fetchSelfDelegation(validatorAddress: string): Promise<CosmosDelegation>;\n    fetchUnbondingDelegations(delegatorAddress: string): Promise<CosmosUnbondingDelegation[]>;\n    fetchTotalUnbondingAmount(address: string): Promise<BigNumber>;\n    fetchRewardDetails(delegatorAddress: string): Promise<CosmosRewardDetails[]>;\n    fetchTotalReward(delegatorAddress: string): Promise<BigNumber>;\n    fetchRewardForDelegation(delegatorAddress: string, validatorAddress: string): Promise<BigNumber>;\n    withdrawAllDelegationRewards(delegatorAddress: string, chainID: string, accountNumber: string, sequence: string, gas: BigNumber, fee: BigNumber, memo: string, simulate?: boolean): Promise<string>;\n    withdrawDelegationRewards(delegatorAddress: string, validatorAdress: string, chainID: string, accountNumber: string, sequence: string, gas: BigNumber, fee: BigNumber, memo: string, simulate?: boolean): Promise<string>;\n    private url;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { KeyPair } from '../../data/KeyPair';\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedCosmosTransaction } from '../../serializer/schemas/definitions/signed-transaction-cosmos';\nimport { UnsignedCosmosTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { CosmosAddress } from './CosmosAddress';\nimport { CosmosCryptoClient } from './CosmosCryptoClient';\nimport { CosmosDelegation, CosmosNodeClient, CosmosUnbondingDelegation, CosmosValidator } from './CosmosNodeClient';\nimport { CosmosProtocolOptions } from './CosmosProtocolOptions';\nimport { CosmosTransaction } from './CosmosTransaction';\nimport { CosmosTransactionCursor, CosmosTransactionResult } from './CosmosTypes';\nexport declare enum CosmosDelegationActionType {\n    DELEGATE = \"delegate\",\n    UNDELEGATE = \"undelegate\",\n    WITHDRAW_ALL_REWARDS = \"withdraw_all_rewards\",\n    WITHDRAW_VALIDATOR_REWARDS = \"withdraw_validator_rewards\"\n}\nexport declare class CosmosProtocol extends NonExtendedProtocol implements ICoinDelegateProtocol {\n    readonly options: CosmosProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    subProtocols?: ICoinSubProtocol[];\n    private readonly defaultGas;\n    readonly cryptoClient: CosmosCryptoClient;\n    get nodeClient(): CosmosNodeClient;\n    constructor(options?: CosmosProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    generateKeyPair(mnemonic: string, derivationPath?: string, password?: string): KeyPair;\n    private generateKeyPairFromNode;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPublicKeyFromPrivateKey(privateKey: Buffer): Buffer;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<CosmosAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<CosmosAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: CosmosAddress): Promise<CosmosAddress>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: CosmosTransactionCursor): Promise<CosmosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: CosmosTransactionCursor): Promise<CosmosTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, transaction: CosmosTransaction): Promise<string>;\n    getTransactionDetails(transaction: UnsignedCosmosTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedCosmosTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    private getBalance;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        memo?: string;\n    }): Promise<CosmosTransaction>;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: CosmosDelegationActionType, data?: any): Promise<CosmosTransaction[]>;\n    undelegate(publicKey: string, validatorAddress: string, amount: string, memo?: string): Promise<CosmosTransaction>;\n    delegate(publicKey: string, validatorAddress: string | string[], amount: string, undelegate?: boolean, memo?: string): Promise<CosmosTransaction>;\n    withdrawDelegationRewards(publicKey: string, _validatorAddresses?: string[], memo?: string): Promise<CosmosTransaction>;\n    withdrawAllDelegationRewards(delegatorAddress: string, fee: BigNumber, memo?: string): Promise<string>;\n    fetchTotalReward(delegatorAddress: string): Promise<BigNumber>;\n    fetchRewardForDelegation(delegatorAddress: string, validatorAddress: string): Promise<BigNumber>;\n    fetchDelegations(address: string): Promise<CosmosDelegation[]>;\n    fetchTotalDelegatedAmount(address: string): Promise<BigNumber>;\n    fetchValidator(address: string): Promise<CosmosValidator>;\n    fetchUnbondingDelegations(delegatorAddress: string): Promise<CosmosUnbondingDelegation[]>;\n    fetchTotalUnbondingAmount(address: string): Promise<BigNumber>;\n    fetchValidators(): Promise<CosmosValidator[]>;\n    fetchSelfDelegation(address: string): Promise<CosmosDelegation>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    private getDelegatorDetails;\n    private getAvailableDelegatorActions;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { CosmosNodeClient } from './CosmosNodeClient';\nexport declare class MintscanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class CosmosProtocolNetwork extends ProtocolNetwork<undefined> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: undefined);\n}\nexport declare class CosmosProtocolConfig {\n    readonly nodeClient: CosmosNodeClient;\n    constructor(nodeClient?: CosmosNodeClient);\n}\nexport declare class CosmosProtocolOptions implements ProtocolOptions<CosmosProtocolConfig> {\n    readonly network: CosmosProtocolNetwork;\n    readonly config: CosmosProtocolConfig;\n    constructor(network?: CosmosProtocolNetwork, config?: CosmosProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosTransaction.d.ts",dts:"import { EncodeObject } from '../../dependencies/src/cosmjs';\nimport { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SerializableUnsignedCosmosTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-cosmos';\nimport { CosmosMessage } from './cosmos-message/CosmosMessage';\nimport { CosmosFee } from './CosmosFee';\nimport { CosmosProtocol } from './CosmosProtocol';\nexport interface JSONConvertible {\n    toJSON(): any;\n}\nexport interface RPCConvertible {\n    toRPCBody(): any;\n}\nexport interface Encodable {\n    toEncodeObject(): EncodeObject;\n}\nexport declare class CosmosTransaction implements JSONConvertible, RPCConvertible, Encodable {\n    readonly messages: CosmosMessage[];\n    readonly fee: CosmosFee;\n    readonly memo: string;\n    readonly chainID: string;\n    readonly accountNumber: string;\n    readonly sequence: string;\n    constructor(messages: CosmosMessage[], fee: CosmosFee, memo: string, chainID: string, accountNumber: string, sequence: string);\n    toJSON(): {\n        accountNumber: string;\n        chainID: string;\n        fee: {\n            amount: import(\"./CosmosCoin\").CosmosCoinJSON[];\n            gas: string;\n        };\n        memo: string;\n        messages: import(\"./cosmos-message/CosmosMessage\").CosmosMessageJSON[];\n        sequence: string;\n    };\n    toRPCBody(): any;\n    toEncodeObject(): EncodeObject;\n    toAirGapTransactions(protocol: CosmosProtocol): IAirGapTransaction[];\n    static fromJSON(json: SerializableUnsignedCosmosTransaction): CosmosTransaction;\n    static fromRPCBody(json: any): CosmosTransaction;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface CosmosTransactionCursor {\n    address: string;\n    limit: number;\n    sender: {\n        page: number;\n        totalPages: number;\n        count: number;\n        totalCount: number;\n    };\n    receipient: {\n        page: number;\n        totalPages: number;\n        count: number;\n        totalCount: number;\n    };\n}\nexport interface CosmosTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: CosmosTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/info-clients/EtherscanInfoClient.d.ts",dts:"import { EthereumProtocol } from '../../EthereumProtocol';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from '../../EthereumTypes';\nimport { EthereumInfoClient } from './InfoClient';\nexport declare class EtherscanInfoClient extends EthereumInfoClient {\n    constructor(baseURL?: string);\n    fetchTransactions(protocol: EthereumProtocol, address: string, limit: any, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    fetchContractTransactions(protocol: EthereumProtocol, contractAddress: string, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/info-clients/InfoClient.d.ts",dts:"import { EthereumProtocol } from '../../EthereumProtocol';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from '../../EthereumTypes';\nexport declare abstract class EthereumInfoClient {\n    baseURL: string;\n    constructor(baseURL: string);\n    abstract fetchTransactions(protocol: EthereumProtocol, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    abstract fetchContractTransactions(protocol: EthereumProtocol, contractAddress: string, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/node-clients/AirGapNodeClient.d.ts",dts:"import { BigNumber } from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus } from '../../../../interfaces/IAirGapTransaction';\nimport { EthereumNodeClient } from './NodeClient';\nexport declare class EthereumRPCData {\n    protected static parametersLength: number;\n    methodSignature: string;\n    constructor(methodSignature: string);\n    abiEncoded(): string;\n    static addLeadingZeroPadding(value: string, targetLength?: number): string;\n    static removeLeadingZeroPadding(value: string): string;\n}\nexport declare class EthereumRPCDataBalanceOf extends EthereumRPCData {\n    static methodName: string;\n    address: string;\n    constructor(address: string);\n    abiEncoded(): string;\n}\nexport declare class EthereumRPCDataTransfer extends EthereumRPCData {\n    static methodName: string;\n    recipient: string;\n    amount: string;\n    constructor(toAddressOrData: string, amount?: string);\n    abiEncoded(): string;\n}\nexport declare class AirGapNodeClient extends EthereumNodeClient {\n    constructor(baseURL?: string);\n    fetchBalance(address: string): Promise<BigNumber>;\n    fetchTransactionCount(address: string): Promise<number>;\n    sendSignedTransaction(transaction: string): Promise<string>;\n    getTransactionStatus(transactionHash: string): Promise<AirGapTransactionStatus>;\n    callBalanceOf(contractAddress: string, address: string): Promise<BigNumber>;\n    callBalanceOfOnContracts(contractAddresses: string[], address: string): Promise<{\n        [contractAddress: string]: BigNumber;\n    }>;\n    private balanceOfBody;\n    estimateTransactionGas(fromAddress: string, toAddress: string, amount?: string, data?: string, gas?: string): Promise<BigNumber>;\n    estimateTransferGas(contractAddress: string, fromAddress: string, toAddress: string, hexAmount: string): Promise<BigNumber>;\n    getGasPrice(): Promise<BigNumber>;\n    private send;\n    private batchSend;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/node-clients/NodeClient.d.ts",dts:"import { BigNumber } from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus } from '../../../../interfaces/IAirGapTransaction';\nexport declare abstract class EthereumNodeClient {\n    baseURL: string;\n    constructor(baseURL: string);\n    abstract fetchBalance(address: string): Promise<BigNumber>;\n    abstract fetchTransactionCount(address: string): Promise<number>;\n    abstract sendSignedTransaction(transaction: string): Promise<string>;\n    abstract callBalanceOf(contractAddress: string, address: string): Promise<BigNumber>;\n    abstract getTransactionStatus(transactionHash: string): Promise<AirGapTransactionStatus>;\n    abstract estimateTransferGas(contractAddress: string, fromAddress: string, toAddress: string, hexAmount: string): Promise<BigNumber>;\n    abstract estimateTransactionGas(fromAddress: string, toAddress: string, amount?: string, data?: string, gas?: string): Promise<BigNumber>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    abstract callBalanceOfOnContracts(contractAddresses: string[], address: string): Promise<{\n        [contractAddress: string]: BigNumber;\n    }>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/erc20/ERC20.d.ts",dts:"import { GenericERC20 } from './GenericERC20';\ndeclare const ERC20Token: GenericERC20;\nexport { ERC20Token };\n"},{name:"@airgap/coinlib-core/protocols/ethereum/erc20/GenericERC20.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { SignedEthereumTransaction } from '../../../serializer/schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedTransaction } from '../../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawEthereumTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { BaseEthereumProtocol } from '../BaseEthereumProtocol';\nimport { EtherscanInfoClient } from '../clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from '../clients/node-clients/AirGapNodeClient';\nimport { EthereumERC20ProtocolOptions } from '../EthereumProtocolOptions';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from './../EthereumTypes';\nexport declare class GenericERC20 extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> implements ICoinSubProtocol {\n    readonly options: EthereumERC20ProtocolOptions;\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    readonly contractAddress: string;\n    constructor(options: EthereumERC20ProtocolOptions);\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawEthereumTransaction): Promise<IAirGapSignedTransaction>;\n    private estimateGas;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string): Promise<RawEthereumTransaction>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionDetailsFromSigned(signedTx: SignedEthereumTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/utils/utils.d.ts",dts:"export declare class EthereumUtils {\n    static toHex(value: any): string;\n    private static readonly SHA3_NULL_S;\n    static sha3(value: any): string | null;\n    private static numberToHex;\n    private static hexToBytes;\n    private static isHexStrict;\n    private static checkAddressChecksum;\n    private static isAddress;\n    private static isBigNumber;\n    private static utf8ToHex;\n    private static isObject;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/BaseEthereumProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { Network } from '../../networks';\nimport { SignedEthereumTransaction } from '../../serializer/schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedTransaction } from '../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawEthereumTransaction, RawTypedEthereumTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nimport { EthereumAddress } from './EthereumAddress';\nimport { EthereumCryptoClient } from './EthereumCryptoClient';\nimport { EthereumProtocolOptions } from './EthereumProtocolOptions';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from './EthereumTypes';\nexport declare abstract class BaseEthereumProtocol<NodeClient extends EthereumNodeClient, InfoClient extends EthereumInfoClient> implements ICoinProtocol {\n    readonly options: EthereumProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    protected readonly MAX_GAS_ESTIMATE: string;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    network: Network;\n    readonly cryptoClient: EthereumCryptoClient;\n    get subProtocols(): ICoinSubProtocol[];\n    constructor(options?: EthereumProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getExtendedPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getExtendedPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string | Buffer): Promise<EthereumAddress>;\n    getAddressesFromPublicKey(publicKey: string | Buffer): Promise<EthereumAddress[]>;\n    private getPublicKeyFromExtendedPublicKey;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<EthereumAddress>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<EthereumAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: EthereumAddress): Promise<EthereumAddress>;\n    private getPrivateKeyFromExtendedPrivateKey;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, untypedTransaction: RawTypedEthereumTransaction | RawEthereumTransaction, childDerivationPath?: string): Promise<IAirGapSignedTransaction>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawEthereumTransaction): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedEthereumTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset?: number): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, _offset: number, recipients: string[], values: string[], fee: string, data?: any): Promise<RawEthereumTransaction>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<RawEthereumTransaction>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionsFromPublicKey(publicKey: string, limit?: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { CoinAddress } from '../ICoinProtocol';\nexport declare class EthereumAddress implements CoinAddress {\n    private readonly value;\n    private constructor();\n    static from(publicKey: string | Buffer): EthereumAddress;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumClassicProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nexport declare class EthereumClassicProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nimport { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nexport declare class EthereumCryptoClient extends Secp256k1CryptoClient {\n    private readonly protocol;\n    constructor(protocol: BaseEthereumProtocol<EthereumNodeClient, EthereumInfoClient>);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nimport { EthereumProtocolOptions } from './EthereumProtocolOptions';\nexport declare class EthereumProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    readonly options: EthereumProtocolOptions;\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    constructor(options?: EthereumProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { SubProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nexport declare const NODE_URL: string;\nexport declare const BLOCK_EXPLORER_API: string;\nexport declare class EthereumProtocolNetworkExtras {\n    readonly chainID: number;\n    readonly blockExplorerApi: string;\n    constructor(chainID?: number, blockExplorerApi?: string);\n}\nexport declare class EtherscanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class EthereumProtocolNetwork extends ProtocolNetwork<EthereumProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: EthereumProtocolNetworkExtras);\n}\nexport declare class EthereumProtocolConfig {\n    constructor();\n}\nexport declare class EthereumProtocolOptions implements ProtocolOptions<EthereumProtocolConfig> {\n    readonly network: EthereumProtocolNetwork;\n    readonly config: EthereumProtocolConfig;\n    readonly nodeClient: EthereumNodeClient;\n    readonly infoClient: EthereumInfoClient;\n    constructor(network?: EthereumProtocolNetwork, config?: EthereumProtocolConfig);\n}\nexport declare class EthereumERC20ProtocolConfig {\n    readonly symbol: string;\n    readonly name: string;\n    readonly marketSymbol: string;\n    readonly identifier: SubProtocolSymbols;\n    readonly contractAddress: string;\n    readonly decimals: number;\n    constructor(symbol: string, name: string, marketSymbol: string, identifier: SubProtocolSymbols, contractAddress: string, decimals: number);\n}\nexport declare class EthereumERC20ProtocolOptions extends EthereumProtocolOptions {\n    readonly network: EthereumProtocolNetwork;\n    readonly config: EthereumERC20ProtocolConfig;\n    constructor(network: EthereumProtocolNetwork, config: EthereumERC20ProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumRopstenProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nexport declare class EthereumRopstenProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface EthereumTransactionCursor {\n    page: number;\n}\nexport interface EthereumTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: EthereumTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { BitcoinCryptoClient } from '../bitcoin/BitcoinCryptoClient';\nimport { BitcoinProtocol } from '../bitcoin/BitcoinProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { GroestlcoinProtocolOptions } from './GroestlcoinProtocolOptions';\nexport declare class GroestlcoinProtocol extends BitcoinProtocol {\n    readonly options: GroestlcoinProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    readonly cryptoClient: BitcoinCryptoClient;\n    constructor(options?: GroestlcoinProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class GroestlcoinProtocolNetworkExtras {\n    readonly indexerApi: string;\n    readonly network: any;\n    constructor(indexerApi?: string, network?: any);\n}\nexport declare class CryptoidBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class GroestlcoinProtocolNetwork extends ProtocolNetwork<GroestlcoinProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: GroestlcoinProtocolNetworkExtras);\n}\nexport declare class GroestlcoinProtocolConfig {\n    readonly bitcoinJSLib: any;\n    constructor(bitcoinJSLib?: any);\n}\nexport declare class GroestlcoinProtocolOptions implements ProtocolOptions<GroestlcoinProtocolConfig> {\n    readonly network: GroestlcoinProtocolNetwork;\n    readonly config: GroestlcoinProtocolConfig;\n    constructor(network?: GroestlcoinProtocolNetwork, config?: GroestlcoinProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinTestnetProtocol.d.ts",dts:"import { BitcoinProtocol } from '../bitcoin/BitcoinProtocol';\nexport declare class GroestlcoinTestnetProtocol extends BitcoinProtocol {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/blockexplorer/SubstrateBlockExplorerClient.d.ts",dts:"import { IAirGapTransaction } from '../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nimport { SubstrateTransactionCursor } from './../../SubstrateTypes';\nexport declare class SubstrateBlockExplorerClient {\n    readonly network: SubstrateNetwork;\n    readonly apiUrl: string;\n    constructor(network: SubstrateNetwork, apiUrl: string);\n    getTransactions(address: string, limit: number, protocolDecimals: number, cursor?: SubstrateTransactionCursor): Promise<IAirGapTransaction[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/account/SubstrateAccountInfo.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEInt } from '../scale/type/SCALEInt';\ndeclare class SubstrateAccountData {\n    readonly free: SCALEInt;\n    readonly reserved: SCALEInt;\n    readonly miscFrozen: SCALEInt;\n    readonly feeFrozen: SCALEInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateAccountData>;\n    private constructor();\n}\nexport declare class SubstrateAccountInfo {\n    readonly nonce: SCALEInt;\n    readonly consumers: SCALEInt;\n    readonly providers: SCALEInt;\n    readonly sufficients: SCALEInt;\n    readonly data: SubstrateAccountData;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateAccountInfo;\n    private static migrateFieldLengths;\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/account/SubstrateAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateAccountId, SubstrateCompatAddress } from '../../../compat/SubstrateCompatAddress';\nexport declare class SubstrateAddress implements SubstrateCompatAddress {\n    readonly version: Buffer;\n    readonly payload: Buffer;\n    readonly checksum: Buffer;\n    private static placeholder;\n    static createPlaceholder(): SubstrateAddress;\n    static from(accountId: SubstrateAccountId<SubstrateAddress>, ss58Format?: number): SubstrateAddress;\n    static fromPublicKey(payload: Buffer | Uint8Array | string, ss58Format?: number): SubstrateAddress;\n    static fromEncoded(encoded: string): SubstrateAddress;\n    private static fromBytes;\n    private static fromPayload;\n    private static generateChecksum;\n    private encoded;\n    constructor(version: Buffer, payload: Buffer, checksum: Buffer);\n    compare(other: SubstrateAccountId<SubstrateAddress>): number;\n    getValue(): string;\n    getBufferBytes(): Buffer;\n    getHexBytes(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/account/SubstrateRegistration.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEData } from '../scale/type/SCALEData';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\ndeclare enum SubstrateJudgement {\n    UNKNOWN = 0,\n    FEE_PAID = 1,\n    REASONABLE = 2,\n    KNOWN_GOOD = 3,\n    OUT_OF_DATE = 4,\n    LOW_QUALITY = 5,\n    ERRORNEOUS = 6\n}\nexport declare class SubstrateIdentityInfo {\n    readonly display: SCALEData;\n    readonly legal: SCALEData;\n    readonly web: SCALEData;\n    readonly riot: SCALEData;\n    readonly email: SCALEData;\n    readonly image: SCALEData;\n    readonly twitter: SCALEData;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateIdentityInfo>;\n    private constructor();\n}\nexport declare class SubstrateRegistration {\n    readonly judgements: SCALEArray<SCALETuple<SCALEInt, SCALEEnum<SubstrateJudgement>>>;\n    readonly deposit: SCALEInt;\n    readonly identityInfo: SubstrateIdentityInfo;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateRegistration;\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/decorator/call/SubstrateCall.d.ts",dts:"export interface SubstrateCall {\n    palletName: string;\n    name: string;\n    palletIndex: number;\n    callIndex: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/decorator/constant/SubstrateConstant.d.ts",dts:'/// <reference types="node" />\nexport interface SubstrateConstant {\n    palletName: string;\n    name: string;\n    value: Buffer;\n    type: string;\n}\n'},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/decorator/storage/SubstrateStorageEntry.d.ts",dts:"import { SCALEType } from '../../../scale/type/SCALEType';\nexport declare enum SubstrateStorageEntryHasher {\n    BLAKE2_128 = 0,\n    BLAKE2_256 = 1,\n    BLAKE2_128_CONCAT = 2,\n    TWOX128 = 3,\n    TWOX256 = 4,\n    TWOX64_CONCAT = 5,\n    IDENTITY = 6\n}\nexport declare abstract class SubstrateStorageEntry {\n    readonly palletName: string;\n    readonly prefix: string;\n    private readonly storageHash;\n    constructor(palletName: string, prefix: string);\n    hash(...args: SCALEType[]): Promise<string>;\n    protected abstract argsToKeys(args: SCALEType[]): Promise<string>;\n    protected abstract hashArgs(args: SCALEType[]): Promise<string>;\n    private hashPrefixTrie;\n}\nexport declare class SubstratePlainStorageEntry extends SubstrateStorageEntry {\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\nexport declare class SubstrateMapStorageEntry extends SubstrateStorageEntry {\n    readonly hasher: SubstrateStorageEntryHasher;\n    constructor(pallet: string, prefix: string, hasher: SubstrateStorageEntryHasher);\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\nexport declare class SubstrateDoubleMapStorageEntry extends SubstrateStorageEntry {\n    readonly firstHasher: SubstrateStorageEntryHasher;\n    readonly secondHasher: SubstrateStorageEntryHasher;\n    constructor(pallet: string, prefix: string, firstHasher: SubstrateStorageEntryHasher, secondHasher: SubstrateStorageEntryHasher);\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\nexport declare class SubstrateNMapStorageEntry extends SubstrateStorageEntry {\n    readonly hashers: SubstrateStorageEntryHasher[];\n    constructor(pallet: string, prefix: string, hashers: SubstrateStorageEntryHasher[]);\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/decorator/MetadataDecorator.d.ts",dts:"import { SubstrateCall } from './call/SubstrateCall';\nimport { SubstrateConstant } from './constant/SubstrateConstant';\nimport { SubstrateStorageEntry } from './storage/SubstrateStorageEntry';\nexport declare class MetadataDecorator {\n    private readonly storageEntries;\n    private readonly calls;\n    private readonly constants;\n    constructor(storageEntries: SubstrateStorageEntry[], calls: SubstrateCall[], constants: SubstrateConstant[]);\n    storageEntry(moduleName: string, entryName: string): SubstrateStorageEntry | undefined;\n    call(moduleName: string, callName: string): SubstrateCall | undefined;\n    constant(moduleName: string, constantName: string): SubstrateConstant | undefined;\n    private createMapKey;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/storage/MetadataV11Storage.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV11StorageEntry } from './MetadataV11StorageEntry';\nexport declare class MetadataV11Storage extends SCALEClass {\n    readonly prefix: SCALEString;\n    readonly storageEntries: SCALEArray<MetadataV11StorageEntry>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Storage>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/storage/MetadataV11StorageEntry.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV11StorageEntryType } from './MetadataV11StorageEntryType';\ndeclare enum StorageEntryModifier {\n    Optional = 0,\n    Default = 1\n}\nexport declare class MetadataV11StorageEntry extends SCALEClass {\n    readonly name: SCALEString;\n    readonly modifier: SCALEEnum<StorageEntryModifier>;\n    readonly type: MetadataV11StorageEntryType;\n    readonly defaultValue: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntry>;\n    protected scaleFields: (SCALEBytes | SCALEString | MetadataV11StorageEntryType | SCALEEnum<StorageEntryModifier>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/storage/MetadataV11StorageEntryType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEBoolean } from '../../../../scale/type/SCALEBoolean';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { SubstrateStorageEntry, SubstrateStorageEntryHasher } from '../../../decorator/storage/SubstrateStorageEntry';\ndeclare enum StorageEntryType {\n    Plain = 0,\n    Map = 1,\n    DoubleMap = 2\n}\nexport declare abstract class MetadataV11StorageEntryType extends SCALEClass {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryType>;\n    protected abstract readonly type: SCALEEnum<StorageEntryType>;\n    protected abstract readonly _scaleFields: SCALEType[];\n    protected readonly scaleFields: SCALEType[];\n    abstract decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryPlain extends MetadataV11StorageEntryType {\n    readonly name: SCALEString;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryPlain>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: SCALEString[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryMap extends MetadataV11StorageEntryType {\n    readonly hasher: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key: SCALEString;\n    readonly value: SCALEString;\n    readonly unused: SCALEBoolean;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEBoolean | SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryDoubleMap extends MetadataV11StorageEntryType {\n    readonly hasher1: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key1: SCALEString;\n    readonly key2: SCALEString;\n    readonly value: SCALEString;\n    readonly hasher2: SCALEEnum<SubstrateStorageEntryHasher>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryDoubleMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/MetadataV11Call.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\ndeclare class MetadataV11CallArgument extends SCALEClass {\n    readonly name: SCALEString;\n    readonly type: SCALEString;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11CallArgument>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\nexport declare class MetadataV11Call extends SCALEClass {\n    readonly name: SCALEString;\n    readonly args: SCALEArray<MetadataV11CallArgument>;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Call>;\n    protected scaleFields: (SCALEString | SCALEArray<MetadataV11CallArgument>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/MetadataV11Constant.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Constant extends SCALEClass {\n    readonly name: SCALEString;\n    readonly type: SCALEString;\n    readonly value: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Constant>;\n    protected scaleFields: (SCALEBytes | SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/MetadataV11Error.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Error extends SCALEClass {\n    readonly name: SCALEString;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Error>;\n    protected scaleFields: (SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/MetadataV11Event.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Event extends SCALEClass {\n    readonly name: SCALEString;\n    readonly args: SCALEArray<SCALEString>;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Event>;\n    scaleFields: (SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/module/MetadataV11Module.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV11Call } from './MetadataV11Call';\nimport { MetadataV11Constant } from './MetadataV11Constant';\nimport { MetadataV11Error } from './MetadataV11Error';\nimport { MetadataV11Event } from './MetadataV11Event';\nimport { MetadataV11Storage } from './storage/MetadataV11Storage';\nexport declare class MetadataV11Module extends SCALEClass {\n    readonly name: SCALEString;\n    readonly storage: SCALEOptional<MetadataV11Storage>;\n    readonly calls: SCALEOptional<SCALEArray<MetadataV11Call>>;\n    readonly events: SCALEOptional<SCALEArray<MetadataV11Event>>;\n    readonly constants: SCALEArray<MetadataV11Constant>;\n    readonly errors: SCALEArray<MetadataV11Error>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Module>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV11Storage>, calls: SCALEOptional<SCALEArray<MetadataV11Call>>, events: SCALEOptional<SCALEArray<MetadataV11Event>>, constants: SCALEArray<MetadataV11Constant>, errors: SCALEArray<MetadataV11Error>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v11/MetadataV11.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV11Module } from './module/MetadataV11Module';\nexport declare class MetadataV11 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly modules: SCALEArray<MetadataV11Module>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): MetadataV11;\n    protected scaleFields: SCALEType[];\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, modules: SCALEArray<MetadataV11Module>);\n    decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v12/module/MetadataV12Module.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../../scale/type/SCALEInt';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV11Call } from '../../v11/module/MetadataV11Call';\nimport { MetadataV11Constant } from '../../v11/module/MetadataV11Constant';\nimport { MetadataV11Error } from '../../v11/module/MetadataV11Error';\nimport { MetadataV11Event } from '../../v11/module/MetadataV11Event';\nimport { MetadataV11Module } from '../../v11/module/MetadataV11Module';\nimport { MetadataV11Storage } from '../../v11/module/storage/MetadataV11Storage';\nexport declare class MetadataV12Module extends MetadataV11Module {\n    readonly index: SCALEInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV12Module>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV11Storage>, calls: SCALEOptional<SCALEArray<MetadataV11Call>>, events: SCALEOptional<SCALEArray<MetadataV11Event>>, constants: SCALEArray<MetadataV11Constant>, errors: SCALEArray<MetadataV11Error>, index: SCALEInt);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v12/MetadataV12.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV12Module } from './module/MetadataV12Module';\nexport declare class MetadataV12 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly modules: SCALEArray<MetadataV12Module>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): MetadataV12;\n    protected scaleFields: SCALEInt[];\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, modules: SCALEArray<MetadataV12Module>);\n    decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v13/module/storage/MetadataV13Storage.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV13StorageEntry } from './MetadataV13StorageEntry';\nexport declare class MetadataV13Storage extends SCALEClass {\n    readonly prefix: SCALEString;\n    readonly storageEntries: SCALEArray<MetadataV13StorageEntry>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13Storage>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v13/module/storage/MetadataV13StorageEntry.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV13StorageEntryType } from './MetadataV13StorageEntryType';\ndeclare enum StorageEntryModifier {\n    Optional = 0,\n    Default = 1\n}\nexport declare class MetadataV13StorageEntry extends SCALEClass {\n    readonly name: SCALEString;\n    readonly modifier: SCALEEnum<StorageEntryModifier>;\n    readonly type: MetadataV13StorageEntryType;\n    readonly fallback: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntry>;\n    protected scaleFields: (SCALEBytes | SCALEString | MetadataV13StorageEntryType | SCALEEnum<StorageEntryModifier>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v13/module/storage/MetadataV13StorageEntryType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEBoolean } from '../../../../scale/type/SCALEBoolean';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { SubstrateStorageEntry, SubstrateStorageEntryHasher } from '../../../decorator/storage/SubstrateStorageEntry';\ndeclare enum StorageEntryType {\n    Plain = 0,\n    Map = 1,\n    DoubleMap = 2,\n    NMap = 3\n}\nexport declare abstract class MetadataV13StorageEntryType extends SCALEClass {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntryType>;\n    protected abstract readonly type: SCALEEnum<StorageEntryType>;\n    protected abstract readonly _scaleFields: SCALEType[];\n    protected get scaleFields(): SCALEType[];\n    abstract decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV13StorageEntryPlain extends MetadataV13StorageEntryType {\n    readonly name: SCALEString;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntryPlain>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: SCALEString[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV13StorageEntryMap extends MetadataV13StorageEntryType {\n    readonly hasher: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key: SCALEString;\n    readonly value: SCALEString;\n    readonly unused: SCALEBoolean;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntryMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEBoolean | SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV13StorageEntryDoubleMap extends MetadataV13StorageEntryType {\n    readonly hasher1: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key1: SCALEString;\n    readonly key2: SCALEString;\n    readonly value: SCALEString;\n    readonly hasher2: SCALEEnum<SubstrateStorageEntryHasher>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntryDoubleMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV13StorageEntryNMap extends MetadataV13StorageEntryType {\n    readonly keyVec: SCALEArray<SCALEString>;\n    readonly hashers: SCALEArray<SCALEEnum<SubstrateStorageEntryHasher>>;\n    readonly value: SCALEString;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13StorageEntryNMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEString | SCALEArray<SCALEString> | SCALEArray<SCALEEnum<SubstrateStorageEntryHasher>>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v13/module/MetadataV13Module.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEInt } from '../../../scale/type/SCALEInt';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV11Call } from '../../v11/module/MetadataV11Call';\nimport { MetadataV11Constant } from '../../v11/module/MetadataV11Constant';\nimport { MetadataV11Error } from '../../v11/module/MetadataV11Error';\nimport { MetadataV11Event } from '../../v11/module/MetadataV11Event';\nimport { MetadataV13Storage } from './storage/MetadataV13Storage';\nexport declare class MetadataV13Module extends SCALEClass {\n    readonly name: SCALEString;\n    readonly storage: SCALEOptional<MetadataV13Storage>;\n    readonly calls: SCALEOptional<SCALEArray<MetadataV11Call>>;\n    readonly events: SCALEOptional<SCALEArray<MetadataV11Event>>;\n    readonly constants: SCALEArray<MetadataV11Constant>;\n    readonly errors: SCALEArray<MetadataV11Error>;\n    readonly index: SCALEInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV13Module>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV13Storage>, calls: SCALEOptional<SCALEArray<MetadataV11Call>>, events: SCALEOptional<SCALEArray<MetadataV11Event>>, constants: SCALEArray<MetadataV11Constant>, errors: SCALEArray<MetadataV11Error>, index: SCALEInt);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v13/MetadataV13.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV13Module } from './module/MetadataV13Module';\nexport declare class MetadataV13 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly modules: SCALEArray<MetadataV13Module>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): MetadataV13;\n    protected scaleFields: SCALEInt[];\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, modules: SCALEArray<MetadataV13Module>);\n    decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/extrinsic/MetadataV14Extrinsic.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../../scale/type/SCALEInt';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV14Component } from '../MetadataV14Component';\nimport { MetadataV14SignedExtension } from './MetadataV14SignedExtension';\nexport declare class MetadataV14Exstrinsic extends MetadataV14Component {\n    readonly version: SCALEInt;\n    readonly signedExtensions: SCALEArray<MetadataV14SignedExtension>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Exstrinsic>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/extrinsic/MetadataV14SignedExtension.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALECompactInt } from '../../../scale/type/SCALECompactInt';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV14Component } from '../MetadataV14Component';\nexport declare class MetadataV14SignedExtension extends MetadataV14Component {\n    readonly identifier: SCALEString;\n    readonly additionalSigned: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SignedExtension>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/storage/MetadataV14Storage.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV14StorageEntry } from './MetadataV14StorageEntry';\nexport declare class MetadataV14Storage extends SCALEClass {\n    readonly prefix: SCALEString;\n    readonly storageEntries: SCALEArray<MetadataV14StorageEntry>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Storage>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/storage/MetadataV14StorageEntry.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV14StorageEntryType } from './MetadataV14StorageEntryType';\ndeclare enum StorageEntryModifier {\n    Optional = 0,\n    Default = 1\n}\nexport declare class MetadataV14StorageEntry extends SCALEClass {\n    readonly name: SCALEString;\n    readonly modifier: SCALEEnum<StorageEntryModifier>;\n    readonly type: MetadataV14StorageEntryType;\n    readonly fallback: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14StorageEntry>;\n    protected scaleFields: (SCALEBytes | SCALEString | MetadataV14StorageEntryType | SCALEEnum<StorageEntryModifier>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/storage/MetadataV14StorageEntryType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../../../scale/type/SCALECompactInt';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { SubstrateStorageEntry, SubstrateStorageEntryHasher } from '../../../decorator/storage/SubstrateStorageEntry';\ndeclare enum StorageEntryType {\n    Plain = 0,\n    Map = 1\n}\nexport declare abstract class MetadataV14StorageEntryType extends SCALEClass {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14StorageEntryType>;\n    protected abstract readonly type: SCALEEnum<StorageEntryType>;\n    protected abstract readonly _scaleFields: SCALEType[];\n    protected get scaleFields(): SCALEType[];\n    abstract decorate(palletName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV14StorageEntryPlain extends MetadataV14StorageEntryType {\n    readonly id: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14StorageEntryPlain>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: SCALECompactInt[];\n    private constructor();\n    decorate(palletName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV14StorageEntryMap extends MetadataV14StorageEntryType {\n    readonly hashers: SCALEArray<SCALEEnum<SubstrateStorageEntryHasher>>;\n    readonly key: SCALECompactInt;\n    readonly value: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14StorageEntryMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALECompactInt | SCALEArray<SCALEEnum<SubstrateStorageEntryHasher>>)[];\n    private constructor();\n    decorate(palletName: string, prefix: string): SubstrateStorageEntry;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/MetadataV14Call.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { MetadataV14Component } from '../MetadataV14Component';\nexport declare class MetadataV14Call extends MetadataV14Component {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Call>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/MetadataV14Constant.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../scale/type/SCALEBytes';\nimport { SCALECompactInt } from '../../../scale/type/SCALECompactInt';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { MetadataV14Component } from '../MetadataV14Component';\nexport declare class MetadataV14Constant extends MetadataV14Component {\n    readonly name: SCALEString;\n    readonly value: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Constant>;\n    protected scaleFields: (SCALECompactInt | SCALEBytes | SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/MetadataV14Error.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { MetadataV14Component } from '../MetadataV14Component';\nexport declare class MetadataV14Error extends MetadataV14Component {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Error>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/MetadataV14Event.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { MetadataV14Component } from '../MetadataV14Component';\nexport declare class MetadataV14Event extends MetadataV14Component {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Event>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/pallet/MetadataV14Pallet.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEInt } from '../../../scale/type/SCALEInt';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV14Call } from './MetadataV14Call';\nimport { MetadataV14Constant } from './MetadataV14Constant';\nimport { MetadataV14Error } from './MetadataV14Error';\nimport { MetadataV14Event } from './MetadataV14Event';\nimport { MetadataV14Storage } from './storage/MetadataV14Storage';\nexport declare class MetadataV14Pallet extends SCALEClass {\n    readonly name: SCALEString;\n    readonly storage: SCALEOptional<MetadataV14Storage>;\n    readonly calls: SCALEOptional<MetadataV14Call>;\n    readonly events: SCALEOptional<MetadataV14Event>;\n    readonly constants: SCALEArray<MetadataV14Constant>;\n    readonly errors: SCALEOptional<MetadataV14Error>;\n    readonly index: SCALEInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14Pallet>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV14Storage>, calls: SCALEOptional<MetadataV14Call>, events: SCALEOptional<MetadataV14Event>, constants: SCALEArray<MetadataV14Constant>, errors: SCALEOptional<MetadataV14Error>, index: SCALEInt);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/si/MetadataV14SiField.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../../../scale/type/SCALECompactInt';\nimport { SCALEOptional } from '../../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nexport declare class MetadataV14SiField extends SCALEClass {\n    readonly name: SCALEOptional<SCALEString>;\n    readonly type: SCALECompactInt;\n    readonly typeName: SCALEOptional<SCALEString>;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiField>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/si/MetadataV14SiType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { MetadataV14SiTypeParameter } from './MetadataV14SiTypeParameter';\nimport { MetadataV14SiTypeDef } from './MetadataV14TypeDef';\nexport declare class MetadataV14SiType extends SCALEClass {\n    readonly path: SCALEArray<SCALEString>;\n    readonly params: SCALEArray<MetadataV14SiTypeParameter>;\n    readonly def: MetadataV14SiTypeDef;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiType>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/si/MetadataV14SiTypeParameter.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../../../scale/type/SCALECompactInt';\nimport { SCALEOptional } from '../../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nexport declare class MetadataV14SiTypeParameter extends SCALEClass {\n    readonly name: SCALEString;\n    readonly type: SCALEOptional<SCALECompactInt>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiTypeParameter>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/si/MetadataV14SiVariant.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEInt } from '../../../../scale/type/SCALEInt';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { MetadataV14SiField } from './MetadataV14SiField';\nexport declare class MetadataV14SiVariant extends SCALEClass {\n    readonly name: SCALEString;\n    readonly fields: SCALEArray<MetadataV14SiField>;\n    readonly index: SCALEInt;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiVariant>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/si/MetadataV14TypeDef.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../../../scale/type/SCALECompactInt';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEInt } from '../../../../scale/type/SCALEInt';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { MetadataV14SiField } from './MetadataV14SiField';\nimport { MetadataV14SiVariant } from './MetadataV14SiVariant';\ndeclare enum TypeDefPrimitive {\n    Bool = 0,\n    Char = 1,\n    Str = 2,\n    U8 = 3,\n    U16 = 4,\n    U32 = 5,\n    U64 = 6,\n    U128 = 7,\n    U256 = 8,\n    I8 = 9,\n    I16 = 10,\n    I32 = 11,\n    I64 = 12,\n    I128 = 13,\n    I256 = 14\n}\nexport declare abstract class MetadataV14SiTypeDef extends SCALEClass {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiTypeDef>;\n}\nexport declare class MetadataV14SiCompositeTypeDef extends MetadataV14SiTypeDef {\n    readonly fields: SCALEArray<MetadataV14SiField>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiCompositeTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiVariantTypeDef extends MetadataV14SiTypeDef {\n    readonly variants: SCALEArray<MetadataV14SiVariant>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiVariantTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiSequenceTypeDef extends MetadataV14SiTypeDef {\n    readonly type: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiSequenceTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiArrayTypeDef extends MetadataV14SiTypeDef {\n    readonly len: SCALEInt;\n    readonly type: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiArrayTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiTupleTypeDef extends MetadataV14SiTypeDef {\n    readonly value: SCALEArray<SCALECompactInt>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiTupleTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiPrimitiveTypeDef extends MetadataV14SiTypeDef {\n    readonly value: SCALEEnum<TypeDefPrimitive>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiPrimitiveTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiCompactTypeDef extends MetadataV14SiTypeDef {\n    readonly type: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiCompactTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport declare class MetadataV14SiBitSequenceTypeDef extends MetadataV14SiTypeDef {\n    readonly bitStoreType: SCALECompactInt;\n    readonly bitOrderType: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14SiBitSequenceTypeDef>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/MetadataV14PortableRegistry.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV14PortableType } from './MetadataV14PortableType';\nexport declare class MetadataV14PortableRegistry extends SCALEClass {\n    readonly types: SCALEArray<MetadataV14PortableType>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14PortableRegistry>;\n    protected readonly scaleFields: SCALEType[];\n    private typesRecord;\n    private constructor();\n    get(id: string): MetadataV14PortableType | undefined;\n    private getTypesRecord;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/registry/MetadataV14PortableType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../../scale/type/SCALECompactInt';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV14SiType } from './si/MetadataV14SiType';\nexport declare class MetadataV14PortableType extends SCALEClass {\n    readonly id: SCALECompactInt;\n    readonly type: MetadataV14SiType;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV14PortableType>;\n    protected readonly scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/MetadataV14.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALECompactInt } from '../../scale/type/SCALECompactInt';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV14Exstrinsic } from './extrinsic/MetadataV14Extrinsic';\nimport { MetadataV14Pallet } from './pallet/MetadataV14Pallet';\nimport { MetadataV14PortableRegistry } from './registry/MetadataV14PortableRegistry';\nexport declare class MetadataV14 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly lookup: MetadataV14PortableRegistry;\n    readonly pallets: SCALEArray<MetadataV14Pallet>;\n    readonly extrinsics: MetadataV14Exstrinsic;\n    readonly type: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): MetadataV14;\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, lookup: MetadataV14PortableRegistry, pallets: SCALEArray<MetadataV14Pallet>, extrinsics: MetadataV14Exstrinsic, type: SCALECompactInt);\n    decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/v14/MetadataV14Component.d.ts",dts:"import { SCALEClass } from '../../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../../scale/type/SCALECompactInt';\nimport { SCALEType } from '../../scale/type/SCALEType';\nexport declare abstract class MetadataV14Component extends SCALEClass {\n    readonly type: SCALECompactInt;\n    protected scaleFields: SCALEType[];\n    protected constructor(type: SCALECompactInt);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/Metadata.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { MetadataDecorator } from './decorator/MetadataDecorator';\nimport { MetadataVersioned } from './MetadataVersioned';\nexport declare class Metadata {\n    readonly versioned: MetadataVersioned;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): Metadata;\n    private static assertMagicNumber;\n    private constructor();\n    decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/metadata/MetadataVersioned.d.ts",dts:"import { SCALEInt } from '../scale/type/SCALEInt';\nimport { MetadataDecorator } from './decorator/MetadataDecorator';\nexport declare abstract class MetadataVersioned {\n    abstract readonly version: SCALEInt;\n    abstract decorate(supportedStorageEntries: Object, supportedCalls: Object, supportedConstants: Object): MetadataDecorator;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEAccountId.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateAccountId, SubstrateCompatAddressType } from '../../../../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEAccountId<Network extends SubstrateNetwork> extends SCALEType {\n    readonly address: SubstrateCompatAddressType[Network];\n    static from<Network extends SubstrateNetwork>(value: string | Uint8Array | Buffer | SubstrateCompatAddressType[Network], network: Network): SCALEAccountId<Network>;\n    static decode<Network extends SubstrateNetwork>(network: Network, hex: string, byteLength?: number): SCALEDecodeResult<SCALEAccountId<Network>>;\n    private constructor();\n    compare(other: SCALEAccountId<Network> | SubstrateAccountId<SubstrateCompatAddressType[Network]>): number;\n    asAddress(): string;\n    asBytes(): Buffer;\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEArray.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEArray<T extends SCALEType> extends SCALEType {\n    readonly elements: T[];\n    static from<T extends SCALEType>(elements: T[]): SCALEArray<T>;\n    static decode<T extends SCALEType, Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, hex: string, decodeElement: DecoderMethod<T, Network>): SCALEDecodeResult<SCALEArray<T>>;\n    protected constructor(elements: T[]);\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEBoolean.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEBoolean extends SCALEType {\n    readonly value: boolean;\n    static from(value: boolean | number): SCALEBoolean;\n    static decode(hex: string): SCALEDecodeResult<SCALEBoolean>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEBytes.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEBytes extends SCALEType {\n    readonly bytes: Buffer;\n    static from(bytes: string | Buffer | Uint8Array): SCALEBytes;\n    static decode(hex: string): SCALEDecodeResult<SCALEBytes>;\n    private constructor();\n    toString(encoding?: BufferEncoding): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEClass.d.ts",dts:"import { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare abstract class SCALEClass extends SCALEType {\n    protected abstract readonly scaleFields: SCALEType[];\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALECompactInt.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEInt } from './SCALEInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\ndeclare type Number = SCALECompactInt | SCALEInt | BigNumber | number;\nexport declare class SCALECompactInt extends SCALEType {\n    readonly value: BigNumber;\n    static from(value: number | BigNumber | string): SCALECompactInt;\n    static decode(hex: string): SCALEDecodeResult<SCALECompactInt>;\n    private constructor();\n    toString(base?: number): string;\n    toNumber(): number;\n    plus(other: Number): SCALECompactInt;\n    minus(other: Number): SCALECompactInt;\n    multiply(other: Number): SCALECompactInt;\n    divide(other: Number): SCALECompactInt;\n    lt(other: Number): boolean;\n    lte(other: Number): boolean;\n    gt(other: Number): boolean;\n    gte(other: Number): boolean;\n    eq(other: Number): boolean;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private applyOperation;\n    private performOperation;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEData.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEDataType {\n    None = 0,\n    Raw = 1,\n    BlakeTwo256 = 2,\n    Sha256 = 3,\n    Keccak256 = 4,\n    ShaThree256 = 5\n}\nexport declare class SCALEData extends SCALEType {\n    readonly type: SCALEDataType;\n    readonly bytes: Buffer | null;\n    static from(type: SCALEDataType, bytes?: string | Uint8Array | Buffer): SCALEData;\n    static decode(hex: string): SCALEDecodeResult<SCALEData>;\n    constructor(type: SCALEDataType, bytes: Buffer | null);\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEEnum.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEEnum<T> extends SCALEType {\n    readonly value: T;\n    static from<T>(value: T): SCALEEnum<T>;\n    static decode<T>(hex: string, getEnumValue: (value: number) => T | null): SCALEDecodeResult<SCALEEnum<T>>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEEra.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport interface EraConfig {\n    chainHeight: number | BigNumber;\n    period?: number | BigNumber;\n}\nexport declare class SCALEEra extends SCALEType {\n    readonly period: number;\n    readonly phase: number;\n    static Immortal(): SCALEEra;\n    static Mortal(config: EraConfig): SCALEEra;\n    readonly isMortal: boolean;\n    static decode(hex: string): SCALEDecodeResult<SCALEEra>;\n    private static decodeImmortal;\n    private static decodeMortal;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private getTrailingZeros;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEHash.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEHash extends SCALEType {\n    readonly value: Buffer;\n    static empty(bitLength?: number): SCALEHash;\n    static from(bytes: string | Buffer | Uint8Array): SCALEHash;\n    static decode(hex: string, bitLength: number): SCALEDecodeResult<SCALEHash>;\n    readonly isEmpty: boolean;\n    private constructor();\n    toString(encoding?: BufferEncoding): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEInt.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALECompactInt } from './SCALECompactInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\ndeclare type Number = SCALECompactInt | SCALEInt | BigNumber | number;\nexport declare class SCALEInt extends SCALEType {\n    readonly value: BigNumber;\n    readonly bitLength?: number | undefined;\n    static from(value: number | BigNumber | string, bitLength?: number): SCALEInt;\n    static decode(hex: string, bitLength?: number): SCALEDecodeResult<SCALEInt>;\n    private constructor();\n    toString(base?: number): string;\n    toNumber(): number;\n    plus(other: Number): SCALEInt;\n    minus(other: Number): SCALEInt;\n    multiply(other: Number): SCALEInt;\n    divide(other: Number): SCALEInt;\n    lt(other: Number): boolean;\n    lte(other: Number): boolean;\n    gt(other: Number): boolean;\n    gte(other: Number): boolean;\n    eq(other: Number): boolean;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private applyOperation;\n    private performOperation;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEMultiAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateCompatAddressType } from '../../../../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEAccountId } from './SCALEAccountId';\nimport { SCALEBytes } from './SCALEBytes';\nimport { SCALEHash } from './SCALEHash';\nimport { SCALEInt } from './SCALEInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEMultiAddressType {\n    Id = 0,\n    Index = 1,\n    Raw = 2,\n    Address32 = 3,\n    Address20 = 4\n}\ndeclare type SCALEMultiAddressValue<T extends SCALEMultiAddressType, Network extends SubstrateNetwork> = T extends SCALEMultiAddressType.Id ? SCALEAccountId<Network> : T extends SCALEMultiAddressType.Index ? SCALEInt : T extends SCALEMultiAddressType.Raw ? SCALEBytes : T extends SCALEMultiAddressType.Address32 ? SCALEHash : T extends SCALEMultiAddressType.Address20 ? SCALEHash : never;\nexport declare class SCALEMultiAddress<T extends SCALEMultiAddressType, Network extends SubstrateNetwork> extends SCALEType {\n    readonly type: T;\n    readonly value: SCALEMultiAddressValue<T, Network>;\n    static isOfType<T extends SCALEMultiAddressType, Network extends SubstrateNetwork>(multiAddress: SCALEMultiAddress<SCALEMultiAddressType, Network>, type: T): multiAddress is SCALEMultiAddress<T, Network>;\n    static from<Network extends SubstrateNetwork>(value: number | string | BigNumber, type: SCALEMultiAddressType.Index, network: Network): SCALEMultiAddress<SCALEMultiAddressType.Index, Network>;\n    static from<T extends Exclude<SCALEMultiAddressType, SCALEMultiAddressType.Index>, Network extends SubstrateNetwork>(value: string | Uint8Array | Buffer | SubstrateCompatAddressType[Network], type: T, network: Network): SCALEMultiAddress<T, Network>;\n    static decode<Network extends SubstrateNetwork, T extends SCALEMultiAddressType = SCALEMultiAddressType>(network: SubstrateNetwork, hex: string, type?: T, runtimeVersion?: number): SCALEDecodeResult<SCALEMultiAddress<T, Network>>;\n    private constructor();\n    toString(): string;\n    asAddress(): string;\n    asBytes(): Buffer;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEOptional.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEOptionalType {\n    None = 0,\n    Some = 1\n}\nexport declare class SCALEOptional<T extends SCALEType> extends SCALEType {\n    readonly value: T | undefined;\n    static empty<T extends SCALEType>(): SCALEOptional<T>;\n    static from<T extends SCALEType>(value: T): SCALEOptional<T>;\n    static decode<T extends SCALEType, Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, hex: string, decodeValue: DecoderMethod<T, Network>): SCALEDecodeResult<SCALEOptional<T>>;\n    private readonly type;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEString.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEString extends SCALEType {\n    readonly value: string;\n    static from(value: string): SCALEString;\n    static decode(hex: string): SCALEDecodeResult<SCALEString>;\n    private constructor();\n    toCamelCase(options?: {\n        startUpper: boolean;\n    }): string;\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALETuple.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALETuple<T extends SCALEType, R extends SCALEType> extends SCALEType {\n    readonly first: T;\n    readonly second: R;\n    static from<T extends SCALEType, R extends SCALEType>(first: T, second: R): SCALETuple<T, R>;\n    static from<T extends SCALEType, R extends SCALEType>(tuple: [T, R]): SCALETuple<T, R>;\n    static decode<T extends SCALEType, R extends SCALEType, Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, hex: string, decodeFirst: DecoderMethod<T, Network>, decodeSecond: DecoderMethod<R, Network>): SCALEDecodeResult<SCALETuple<T, R>>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/type/SCALEType.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nexport interface SCALEEncodeConfig {\n    withPrefix?: boolean;\n    network?: SubstrateNetwork;\n    runtimeVersion?: number;\n}\nexport declare abstract class SCALEType {\n    encode(config?: SCALEEncodeConfig): string;\n    abstract toString(): string;\n    protected abstract _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/scale/SCALEDecoder.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALECompatAddressType } from '../../../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from './type/SCALEAccountId';\nimport { SCALEArray } from './type/SCALEArray';\nimport { SCALEBoolean } from './type/SCALEBoolean';\nimport { SCALEBytes } from './type/SCALEBytes';\nimport { SCALECompactInt } from './type/SCALECompactInt';\nimport { SCALEData } from './type/SCALEData';\nimport { SCALEEnum } from './type/SCALEEnum';\nimport { SCALEEra } from './type/SCALEEra';\nimport { SCALEHash } from './type/SCALEHash';\nimport { SCALEInt } from './type/SCALEInt';\nimport { SCALEMultiAddress, SCALEMultiAddressType } from './type/SCALEMultiAddress';\nimport { SCALEOptional } from './type/SCALEOptional';\nimport { SCALEString } from './type/SCALEString';\nimport { SCALETuple } from './type/SCALETuple';\nimport { SCALEType } from './type/SCALEType';\nexport declare type DecoderMethod<T, Network extends SubstrateNetwork> = (network: Network, runtimeVersion: number | undefined, hex: string) => SCALEDecodeResult<T>;\nexport declare type DecoderPartialMethod<T> = (hex: string) => SCALEDecodeResult<T>;\nexport interface SCALEDecodeResult<T> {\n    bytesDecoded: number;\n    decoded: T;\n}\nexport declare class SCALEDecoder<Network extends SubstrateNetwork> {\n    private readonly network;\n    private readonly runtimeVersion;\n    private hex;\n    constructor(network: Network, runtimeVersion: number | undefined, bytes: string | Uint8Array | Buffer);\n    decodeNextAccount(): SCALEDecodeResult<SCALECompatAddressType[Network]>;\n    decodeNextAccountId(byteLength?: number): SCALEDecodeResult<SCALEAccountId<Network>>;\n    decodeNextArray<T extends SCALEType>(decoderMethod: DecoderMethod<T, Network>): SCALEDecodeResult<SCALEArray<T>>;\n    decodeNextBoolean(): SCALEDecodeResult<SCALEBoolean>;\n    decodeNextBytes(): SCALEDecodeResult<SCALEBytes>;\n    decodeNextCompactInt(): SCALEDecodeResult<SCALECompactInt>;\n    decodeNextEra(): SCALEDecodeResult<SCALEEra>;\n    decodeNextHash(bitLength: number): SCALEDecodeResult<SCALEHash>;\n    decodeNextInt(bitLength: number): SCALEDecodeResult<SCALEInt>;\n    decodeNextMultiAccount<T extends SCALEMultiAddressType>(type?: T): SCALEDecodeResult<SCALEMultiAddress<T, Network>>;\n    decodeNextOptional<T extends SCALEType>(decoderMethod: DecoderMethod<T, Network>): SCALEDecodeResult<SCALEOptional<T>>;\n    decodeNextString(): SCALEDecodeResult<SCALEString>;\n    decodeNextTuple<T extends SCALEType, R extends SCALEType>(firstDecoderMethod: DecoderMethod<T, Network>, secondDecoderMethod: DecoderMethod<R, Network>): SCALEDecodeResult<SCALETuple<T, R>>;\n    decodeNextEnum<T>(getEnumValue: (value: number) => T | null): SCALEDecodeResult<SCALEEnum<T>>;\n    decodeNextData(): SCALEDecodeResult<SCALEData>;\n    decodeNextObject<T>(decoderMethod: DecoderMethod<T, Network>): SCALEDecodeResult<T>;\n    private decodeNextValuePartial;\n    private decodeNextValue;\n    private moveCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateActiveEraInfo.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALEOptional } from '../scale/type/SCALEOptional';\nexport declare class SubstrateActiveEraInfo {\n    readonly index: SCALEInt;\n    readonly start: SCALEOptional<SCALEInt>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateActiveEraInfo;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateEraElectionStatus.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare enum SubstrateElectionStatus {\n    CLOSED = 0,\n    OPEN = 1\n}\nexport declare class SubstrateEraElectionStatus {\n    status: SCALEEnum<SubstrateElectionStatus>;\n    blockNumber?: SCALEInt | undefined;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateEraElectionStatus;\n    constructor(status: SCALEEnum<SubstrateElectionStatus>, blockNumber?: SCALEInt | undefined);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateEraRewardPoints.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateEraRewardPoints<Network extends SubstrateNetwork> {\n    readonly total: SCALEInt;\n    readonly individual: SCALEArray<SCALETuple<SCALEAccountId<Network>, SCALEInt>>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateEraRewardPoints<Network>;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateExposure.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateExposure<Network extends SubstrateNetwork> {\n    readonly total: SCALECompactInt;\n    readonly own: SCALECompactInt;\n    readonly others: SCALEArray<SCALETuple<SCALEAccountId<Network>, SCALECompactInt>>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateExposure<Network>;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateNominationStatus.d.ts",dts:"export declare enum SubstrateNominationStatus {\n    ACTIVE = 0,\n    INACTIVE = 1,\n    OVERSUBSCRIBED = 2\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateNominations.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEBoolean } from '../scale/type/SCALEBoolean';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare class SubstrateNominations<Network extends SubstrateNetwork> {\n    readonly targets: SCALEArray<SCALEAccountId<Network>>;\n    readonly submittedIn: SCALEInt;\n    readonly suppressed: SCALEBoolean;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateNominations<Network>;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateNominatorDetails.d.ts",dts:"import { DelegatorDetails } from '../../../../ICoinDelegateProtocol';\nexport interface SubstrateLockedDetails {\n    value: string;\n    expectedUnlock: number;\n}\nexport interface SubstrateNominatorRewardDetails {\n    eraIndex: number;\n    amount: string;\n    exposures: [string, number][];\n    timestamp: number;\n}\nexport declare type SubstrateStakingStatus = 'bonded' | 'nominating' | 'nominating_waiting' | 'nominating_inactive';\nexport interface SubstrateStakingDetails {\n    total: string;\n    active: string;\n    unlocked: string;\n    locked: SubstrateLockedDetails[];\n    status: SubstrateStakingStatus;\n    nextEra: number;\n    rewards: SubstrateNominatorRewardDetails[];\n}\nexport interface SubstrateNominatorDetails extends DelegatorDetails {\n    stakingDetails?: SubstrateStakingDetails;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstratePayee.d.ts",dts:"export declare enum SubstratePayee {\n    STAKED = 0,\n    STASH = 1,\n    CONTROLLER = 2\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateSlashingSpans.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare class SubstrateSlashingSpans {\n    readonly spanIndex: SCALEInt;\n    readonly lastStart: SCALEInt;\n    readonly lastNonzeroSlash: SCALEInt;\n    readonly prior: SCALEArray<SCALEInt>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateSlashingSpans;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateStakingActionType.d.ts",dts:'export declare enum SubstrateStakingActionType {\n    BOND_NOMINATE = "bond_nominate",\n    REBOND_NOMINATE = "rebond_nominate",\n    NOMINATE = "nominate",\n    CANCEL_NOMINATION = "cancel_nomination",\n    CHANGE_NOMINATION = "change_nomination",\n    UNBOND = "unbond",\n    REBOND = "rebond",\n    BOND_EXTRA = "bond_extra",\n    REBOND_EXTRA = "rebond_extra",\n    WITHDRAW_UNBONDED = "withdraw_unbonded",\n    CHANGE_REWARD_DESTINATION = "change_reward_destination",\n    CHANGE_CONTROLLER = "change_controller"\n}\n'},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateStakingLedger.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateStakingLedger<Network extends SubstrateNetwork> {\n    readonly stash: SCALEAccountId<Network>;\n    readonly total: SCALECompactInt;\n    readonly active: SCALECompactInt;\n    readonly unlocking: SCALEArray<SCALETuple<SCALECompactInt, SCALECompactInt>>;\n    readonly claimedRewards: SCALEArray<SCALEInt>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateStakingLedger<Network>;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateValidatorDetails.d.ts",dts:"import { DelegateeDetails } from '../../../../ICoinDelegateProtocol';\nexport declare type SubstrateValidatorStatus = 'Active' | 'Inactive' | 'Reaped';\nexport interface SubstrateValidatorRewardDetails {\n    amount: string;\n    totalStake: string;\n    ownStake: string;\n    commission: string;\n}\nexport interface SubstrateValidatorDetails extends DelegateeDetails {\n    status?: SubstrateValidatorStatus;\n    ownStash?: string;\n    totalStakingBalance?: string;\n    commission?: string;\n    lastEraReward?: SubstrateValidatorRewardDetails;\n    nominators: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/staking/SubstrateValidatorPrefs.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nexport declare class SubstrateValidatorPrefs {\n    readonly commission: SCALECompactInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SubstrateValidatorPrefs;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/state/SubstrateRuntimeVersion.d.ts",dts:"export interface SubstrateRuntimeVersion {\n    specName: string;\n    implName: string;\n    authoringVersion: number;\n    specVersion: number;\n    implVersion: number;\n    apis: [string, number][];\n    transactionVersion: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/transaction/method/SubstrateTransactionMethod.d.ts",dts:"import { IAirGapTransaction } from '../../../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../scale/SCALEDecoder';\nimport { SCALEClass } from '../../scale/type/SCALEClass';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { SubstrateTransactionType } from '../SubstrateTransaction';\nexport declare class SubstrateTransactionMethod extends SCALEClass {\n    readonly moduleIndex: SCALEInt;\n    readonly callIndex: SCALEInt;\n    readonly args: [string, SCALEType][];\n    readonly toAirGapTransactionParts: () => Partial<IAirGapTransaction>[];\n    static create<Network extends SubstrateNetwork>(network: Network, type: SubstrateTransactionType, moduleIndex: number, callIndex: number, args: any): SubstrateTransactionMethod;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, type: SubstrateTransactionType, raw: string): SCALEDecodeResult<SubstrateTransactionMethod>;\n    protected readonly scaleFields: (SCALEType | SCALEInt)[];\n    private constructor();\n    toString(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/transaction/method/SubstrateTransactionMethodArgs.d.ts",dts:"import { IAirGapTransaction } from '../../../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecoder, SCALEDecodeResult } from '../../scale/SCALEDecoder';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { SubstrateTransactionType } from '../SubstrateTransaction';\nexport declare abstract class SubstrateTransactionMethodArgsFactory<T, Network extends SubstrateNetwork> {\n    protected readonly network: Network;\n    protected readonly args: T;\n    static create<Network extends SubstrateNetwork>(network: Network, type: SubstrateTransactionType, args: any): SubstrateTransactionMethodArgsFactory<any, Network>;\n    protected constructor(network: Network, args: T);\n    abstract createFields(): [string, SCALEType][];\n    abstract createToAirGapTransactionParts(): () => Partial<IAirGapTransaction>[];\n}\nexport declare abstract class SubstrateTransactionMethodArgsDecoder<T, Network extends SubstrateNetwork> {\n    static create<Network extends SubstrateNetwork>(type: SubstrateTransactionType): SubstrateTransactionMethodArgsDecoder<any, Network>;\n    decode(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<T>;\n    protected abstract _decode(decoder: SCALEDecoder<Network>): SCALEDecodeResult<T>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/transaction/SubstrateSignature.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEHash } from '../scale/type/SCALEHash';\nexport declare enum SubstrateSignatureType {\n    Ed25519 = 0,\n    Sr25519 = 1,\n    Ecdsa = 2\n}\nexport declare const SUBSTRATE_SIGNATURE_SIZE: Record<SubstrateSignatureType, number>;\nexport declare class SubstrateSignature extends SCALEClass {\n    readonly type: SCALEEnum<SubstrateSignatureType>;\n    readonly signature: SCALEHash;\n    static create(type: SubstrateSignatureType, signature?: string | Uint8Array | Buffer): SubstrateSignature;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateSignature>;\n    protected scaleFields: (SCALEHash | SCALEEnum<SubstrateSignatureType>)[];\n    readonly isSigned: boolean;\n    protected constructor(type: SCALEEnum<SubstrateSignatureType>, signature: SCALEHash);\n    toString(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/transaction/SubstrateTransaction.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapTransaction } from '../../../../../interfaces/IAirGapTransaction';\nimport { SCALECompatAddressType, SubstrateAccountId, SubstrateCompatAddressType } from '../../../compat/SubstrateCompatAddress';\nimport { SubstrateCompatSignatureType } from '../../../compat/SubstrateCompatSignature';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SubstrateCall } from '../metadata/decorator/call/SubstrateCall';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { EraConfig, SCALEEra } from '../scale/type/SCALEEra';\nimport { SCALEEncodeConfig } from '../scale/type/SCALEType';\nimport { SubstrateTransactionMethod } from './method/SubstrateTransactionMethod';\nimport { SubstrateSignatureType } from './SubstrateSignature';\ninterface SubstrateTransactionConfigBase<Network extends SubstrateNetwork> {\n    from: SubstrateAccountId<SubstrateCompatAddressType[Network]>;\n    args: any;\n    tip: number | BigNumber;\n    methodId: SubstrateCall;\n    era: EraConfig | null;\n    nonce: number | BigNumber;\n}\ninterface SubstrateTransactionConfigWithSignature<Network extends SubstrateNetwork> extends SubstrateTransactionConfigBase<Network> {\n    signature: SubstrateCompatSignatureType[Network];\n}\ninterface SubstrateTransactionConfigWithSignatureType<Network extends SubstrateNetwork> extends SubstrateTransactionConfigBase<Network> {\n    signatureType: SubstrateSignatureType;\n}\ndeclare type SubstrateTransactionConfig<Network extends SubstrateNetwork> = SubstrateTransactionConfigWithSignature<Network> | SubstrateTransactionConfigWithSignatureType<Network>;\nexport declare enum SubstrateTransactionType {\n    TRANSFER = 0,\n    BOND = 1,\n    UNBOND = 2,\n    REBOND = 3,\n    BOND_EXTRA = 4,\n    WITHDRAW_UNBONDED = 5,\n    NOMINATE = 6,\n    CANCEL_NOMINATION = 7,\n    COLLECT_PAYOUT = 8,\n    SET_PAYEE = 9,\n    SET_CONTROLLER = 10,\n    SUBMIT_BATCH = 11,\n    M_DELEGATE = 12,\n    M_SCHEDULE_LEAVE_DELEGATORS = 13,\n    M_EXECUTE_LEAVE_DELEGATORS = 14,\n    M_CANCEL_LEAVE_DELEGATORS = 15,\n    M_SCHEDULE_REVOKE_DELGATION = 16,\n    M_EXECUTE_DELGATION_REQUEST = 17,\n    M_CANCEL_DELEGATION_REQUEST = 18,\n    M_DELEGATOR_BOND_MORE = 19,\n    M_SCHEDULE_DELEGATOR_BOND_LESS = 20,\n    M_EXECUTE_CANDIDATE_BOND_LESS = 21,\n    M_CANCEL_CANDIDATE_BOND_LESS = 22\n}\nexport declare class SubstrateTransaction<Network extends SubstrateNetwork> extends SCALEClass {\n    readonly network: Network;\n    readonly type: SubstrateTransactionType;\n    readonly signer: SCALECompatAddressType[Network];\n    readonly signature: SubstrateCompatSignatureType[Network];\n    readonly era: SCALEEra;\n    readonly nonce: SCALECompactInt;\n    readonly tip: SCALECompactInt;\n    readonly method: SubstrateTransactionMethod;\n    static create<Network extends SubstrateNetwork>(network: Network, type: SubstrateTransactionType, config: SubstrateTransactionConfig<Network>): SubstrateTransaction<Network>;\n    static fromTransaction<Network extends SubstrateNetwork>(transaction: SubstrateTransaction<Network>, config?: Partial<SubstrateTransactionConfig<Network>>): SubstrateTransaction<Network>;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, type: SubstrateTransactionType, raw: string): SCALEDecodeResult<SubstrateTransaction<Network>>;\n    protected scaleFields: (SCALECompactInt | SCALEEra | SubstrateTransactionMethod | SCALECompatAddressType[Network] | SubstrateCompatSignatureType[Network])[];\n    private constructor();\n    toString(): string;\n    toAirGapTransactions(): Partial<IAirGapTransaction>[];\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/data/transaction/SubstrateTransactionPayload.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALEEra } from '../scale/type/SCALEEra';\nimport { SCALEHash } from '../scale/type/SCALEHash';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALEEncodeConfig } from '../scale/type/SCALEType';\nimport { SubstrateTransactionMethod } from './method/SubstrateTransactionMethod';\nimport { SubstrateTransaction, SubstrateTransactionType } from './SubstrateTransaction';\ninterface PayloadConfig {\n    lastHash: string;\n    genesisHash: string;\n    specVersion: number | BigNumber;\n    transactionVersion: number | BigNumber;\n}\nexport declare class SubstrateTransactionPayload extends SCALEClass {\n    readonly method: SubstrateTransactionMethod;\n    readonly era: SCALEEra;\n    readonly nonce: SCALECompactInt;\n    readonly tip: SCALECompactInt;\n    readonly specVersion: SCALEInt;\n    readonly transactionVersion: SCALEInt;\n    readonly genesisHash: SCALEHash;\n    readonly blockHash: SCALEHash;\n    static create<Network extends SubstrateNetwork>(transaction: SubstrateTransaction<Network>, config: PayloadConfig): SubstrateTransactionPayload;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, type: SubstrateTransactionType, hex: string): SCALEDecodeResult<SubstrateTransactionPayload>;\n    protected readonly scaleFields: (SCALECompactInt | SCALEInt | SCALEHash | SCALEEra | SubstrateTransactionMethod)[];\n    private constructor();\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/node/SubstrateNodeClient.d.ts",dts:"import BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { Cache } from '../../../../utils/cache';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nimport { SubstrateAccountInfo } from '../data/account/SubstrateAccountInfo';\nimport { SubstrateRegistration } from '../data/account/SubstrateRegistration';\nimport { SubstrateCall } from '../data/metadata/decorator/call/SubstrateCall';\nimport { MetadataDecorator } from '../data/metadata/decorator/MetadataDecorator';\nimport { SCALEAccountId } from '../data/scale/type/SCALEAccountId';\nimport { SCALEArray } from '../data/scale/type/SCALEArray';\nimport { SCALECompactInt } from '../data/scale/type/SCALECompactInt';\nimport { SCALEData } from '../data/scale/type/SCALEData';\nimport { SCALETuple } from '../data/scale/type/SCALETuple';\nimport { SCALEType } from '../data/scale/type/SCALEType';\nimport { SubstrateActiveEraInfo } from '../data/staking/SubstrateActiveEraInfo';\nimport { SubstrateEraElectionStatus } from '../data/staking/SubstrateEraElectionStatus';\nimport { SubstrateEraRewardPoints } from '../data/staking/SubstrateEraRewardPoints';\nimport { SubstrateExposure } from '../data/staking/SubstrateExposure';\nimport { SubstrateNominations } from '../data/staking/SubstrateNominations';\nimport { SubstratePayee } from '../data/staking/SubstratePayee';\nimport { SubstrateSlashingSpans } from '../data/staking/SubstrateSlashingSpans';\nimport { SubstrateStakingLedger } from '../data/staking/SubstrateStakingLedger';\nimport { SubstrateValidatorPrefs } from '../data/staking/SubstrateValidatorPrefs';\nimport { SubstrateRuntimeVersion } from '../data/state/SubstrateRuntimeVersion';\nimport { SubstrateTransactionType } from '../data/transaction/SubstrateTransaction';\nimport { SubstrateCallEndpoints, SubstrateCallModuleName, SubstrateCallName, SubstrateConstantModuleName, SubstrateConstantName, SubstrateRpcMethodName, SubstrateRpcModuleName, SubstrateStorageEntryName, SubstrateStorageModuleName } from './supported';\nimport { SubstrateCompatAddressType } from '../../compat/SubstrateCompatAddress';\ninterface ConnectionConfig {\n    allowCache: boolean;\n}\nexport declare class SubstrateNodeClient<Network extends SubstrateNetwork> {\n    protected readonly network: Network;\n    protected readonly baseURL: string;\n    protected readonly storageEntries: Object;\n    protected readonly calls: Object;\n    protected readonly constants: Object;\n    protected readonly callEndpoints: SubstrateCallEndpoints;\n    protected readonly cache: Cache;\n    protected metadata: MetadataDecorator | undefined;\n    protected runtimeVersion: number | undefined;\n    protected readonly lastFees: Map<SubstrateTransactionType, BigNumber>;\n    protected initApiPromise: Promise<void> | null;\n    constructor(network: Network, baseURL: string, storageEntries?: Object, calls?: Object, constants?: Object, callEndpoints?: SubstrateCallEndpoints, cache?: Cache);\n    getAccountInfo(address: SubstrateCompatAddressType[Network]): Promise<SubstrateAccountInfo | null>;\n    getExistentialDeposit(): Promise<BigNumber>;\n    getTransactionMetadata(type: SubstrateTransactionType): Promise<SubstrateCall>;\n    getTransferFeeEstimate(transaction: Uint8Array | string): Promise<BigNumber | null>;\n    saveLastFee(type: SubstrateTransactionType, fee: BigNumber): void;\n    getSavedLastFee(type: SubstrateTransactionType, defaultValue?: 'null' | 'largest'): BigNumber | null;\n    getFirstBlockHash(): Promise<string | null>;\n    getLastBlockHash(): Promise<string | null>;\n    getCurrentHeight(): Promise<BigNumber>;\n    getCurrentEraIndex(): Promise<BigNumber | null>;\n    getRuntimeVersion(): Promise<SubstrateRuntimeVersion | null>;\n    getBonded(address: SubstrateCompatAddressType[Network]): Promise<SubstrateCompatAddressType[Network] | null>;\n    getNominations(address: SubstrateCompatAddressType[Network]): Promise<SubstrateNominations<Network> | null>;\n    getRewardPoints(eraIndex: number): Promise<SubstrateEraRewardPoints<Network> | null>;\n    getValidatorReward(eraIndex: number): Promise<BigNumber | null>;\n    getStakersClipped(eraIndex: number, validator: SubstrateCompatAddressType[Network]): Promise<SubstrateExposure<Network> | null>;\n    getRewardDestination(address: SubstrateCompatAddressType[Network]): Promise<SubstratePayee | null>;\n    getStakingLedger(address: SubstrateCompatAddressType[Network]): Promise<SubstrateStakingLedger<Network> | null>;\n    getValidators(): Promise<SubstrateCompatAddressType[Network][] | null>;\n    getValidatorExposure(eraIndex: number, address: SubstrateCompatAddressType[Network]): Promise<SubstrateExposure<Network> | null>;\n    getElectionStatus(): Promise<SubstrateEraElectionStatus | null>;\n    getIdentityOf(address: SubstrateCompatAddressType[Network]): Promise<SubstrateRegistration | null>;\n    getSuperOf(address: SubstrateCompatAddressType[Network]): Promise<SCALETuple<SCALEAccountId<Network>, SCALEData> | null>;\n    getSubsOf(address: SubstrateCompatAddressType[Network]): Promise<SCALETuple<SCALECompactInt, SCALEArray<SCALEAccountId<Network>>> | null>;\n    getValidatorPrefs(eraIndex: number, address: SubstrateCompatAddressType[Network]): Promise<SubstrateValidatorPrefs | null>;\n    getExpectedEraDuration(): Promise<BigNumber | null>;\n    getActiveEraInfo(): Promise<SubstrateActiveEraInfo | null>;\n    getSlashingSpan(address: SubstrateCompatAddressType[Network]): Promise<SubstrateSlashingSpans | null>;\n    submitTransaction(encoded: string): Promise<string>;\n    protected getBlockHash(blockNumber?: number): Promise<string | null>;\n    protected fromStorage<M extends SubstrateStorageModuleName, E extends SubstrateStorageEntryName<M>>(moduleName: M, entryName: E, ...args: SCALEType[]): Promise<string | null>;\n    protected getCall<M extends SubstrateCallModuleName, C extends SubstrateCallName<M>>(moduleName: M, callName: C): Promise<SubstrateCall>;\n    protected getConstant<M extends SubstrateConstantModuleName, C extends SubstrateConstantName<M>>(moduleName: M, constantName: C): Promise<string>;\n    protected initApi(): Promise<void>;\n    protected initCache(): Promise<void>;\n    protected send<T extends SubstrateRpcModuleName, S extends SubstrateRpcMethodName<T>>(module: T, method: S, params?: string[], config?: ConnectionConfig): Promise<any>;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/node/supported.d.ts",dts:'import { SubstrateTransactionType } from \'../data/transaction/SubstrateTransaction\';\nexport declare const supportedRpcMethods: {\n    author: readonly ["submitExtrinsic"];\n    chain: readonly ["getBlock", "getBlockHash"];\n    state: readonly ["getMetadata", "getStorage", "getRuntimeVersion"];\n    payment: readonly ["queryInfo"];\n};\nexport declare const supportedStorageEntries: {\n    Identity: readonly ["IdentityOf", "SuperOf", "SubsOf"];\n    Staking: readonly ["Bonded", "Ledger", "Payee", "Nominators", "CurrentEra", "ActiveEra", "EraElectionStatus", "ErasStakers", "ErasStakersClipped", "ErasValidatorPrefs", "ErasValidatorReward", "ErasRewardPoints", "SlashingSpans"];\n    Session: readonly ["Validators"];\n    System: readonly ["Account"];\n    ParachainStaking: readonly ["CollatorCommission", "CandidateState", "DelegatorState", "Round", "SelectedCandidates"];\n};\nexport declare const supportedCalls: {\n    Balances: readonly ["transfer"];\n    Staking: readonly ["bond", "bond_extra", "unbond", "withdraw_unbonded", "nominate", "chill", "set_payee", "set_controller", "payout_stakers", "rebond"];\n    Utility: readonly ["batch"];\n    ParachainStaking: readonly ["delegate", "schedule_leave_delegators", "execute_leave_delegators", "cancel_leave_delegators", "schedule_revoke_delegation", "execute_delegation_request", "cancel_delegation_request", "delegator_bond_more", "schedule_delegator_bond_less", "execute_candidate_bond_less", "cancel_candidate_bond_less"];\n};\nexport declare const supportedConstants: {\n    Babe: readonly ["EpochDuration", "ExpectedBlockTime"];\n    Balances: readonly ["ExistentialDeposit"];\n    Staking: readonly ["SessionsPerEra"];\n    ParachainStaking: readonly ["DefaultBlocksPerRound", "MaxDelegatorsPerCandidate", "MaxDelegationsPerDelegator", "MinDelegation", "MinDelegatorStk", "CandidateBondLessDelay", "LeaveDelegatorsDelay", "RevokeDelegationDelay", "DelegationBondLessDelay"];\n};\nexport declare type SubstrateRpcModuleName = keyof typeof supportedRpcMethods;\nexport declare type SubstrateRpcMethodName<T extends SubstrateRpcModuleName> = {\n    [S in T]: typeof supportedRpcMethods[S][number];\n}[T];\nexport declare type SubstrateStorageModuleName = keyof typeof supportedStorageEntries;\nexport declare type SubstrateStorageEntryName<T extends SubstrateStorageModuleName> = {\n    [S in T]: typeof supportedStorageEntries[S][number];\n}[T];\nexport declare type SubstrateCallModuleName = keyof typeof supportedCalls;\nexport declare type SubstrateCallName<T extends SubstrateCallModuleName> = {\n    [S in T]: typeof supportedCalls[S][number];\n}[T];\nexport declare type SubstrateConstantModuleName = keyof typeof supportedConstants;\nexport declare type SubstrateConstantName<T extends SubstrateConstantModuleName> = {\n    [S in T]: typeof supportedConstants[S][number];\n}[T];\nexport declare type SubstrateCallEndpoints = Map<SubstrateTransactionType, [SubstrateCallModuleName, SubstrateCallName<any>]>;\nexport declare const supportedCallEndpoints: SubstrateCallEndpoints;\n'},{name:"@airgap/coinlib-core/protocols/substrate/common/SubstrateAccountController.d.ts",dts:"import { KeyPair } from '../../../data/KeyPair';\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateAccountId, SubstrateCompatAddressType } from '../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateNominationStatus } from './data/staking/SubstrateNominationStatus';\nimport { SubstrateNominatorDetails } from './data/staking/SubstrateNominatorDetails';\nimport { SubstrateValidatorDetails } from './data/staking/SubstrateValidatorDetails';\nimport { SubstrateNodeClient } from './node/SubstrateNodeClient';\nexport declare class SubstrateAccountController<Network extends SubstrateNetwork, NodeClient extends SubstrateNodeClient<Network>> {\n    readonly network: Network;\n    readonly nodeClient: NodeClient;\n    constructor(network: Network, nodeClient: NodeClient);\n    createKeyPairFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<KeyPair>;\n    createKeyPairFromHexSecret(secret: string, derivationPath: string): Promise<KeyPair>;\n    createAddressFromPublicKey(publicKey: string): Promise<SubstrateCompatAddressType[Network]>;\n    getBalance(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<BigNumber>;\n    getTransferableBalance(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, excludeExistentialDeposit?: boolean, ignoreFees?: boolean): Promise<BigNumber>;\n    getUnlockingBalance(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<BigNumber>;\n    isBonded(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<boolean>;\n    isDelegating(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<boolean>;\n    getCurrentValidators(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<string[]>;\n    getValidatorDetails(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<SubstrateValidatorDetails>;\n    getNominatorDetails(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, validatorIds?: SubstrateAccountId<SubstrateCompatAddressType[Network]>[]): Promise<SubstrateNominatorDetails>;\n    getNominationStatus(nominator: SubstrateAccountId<SubstrateCompatAddressType[Network]>, validator: SubstrateAccountId<SubstrateCompatAddressType[Network]>, era?: number): Promise<SubstrateNominationStatus | undefined>;\n    getSlashingSpansNumber(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): Promise<number>;\n    private getStakingDetails;\n    private getUnlockingDetails;\n    private getStakingStatus;\n    private getEraValidatorReward;\n    private getNominatorRewards;\n    private calculateEraNominatorReward;\n    private calculateValidatorReward;\n    private calculateNominatorReward;\n    private getAvailableStakingActions;\n    private getAccountIdentityInfo;\n    private partitionArray;\n    private substrateAddressFrom;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/common/SubstrateTransactionController.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateAccountId, SubstrateCompatAddressType } from '../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateTransactionMethod } from './data/transaction/method/SubstrateTransactionMethod';\nimport { SubstrateSignatureType } from './data/transaction/SubstrateSignature';\nimport { SubstrateTransaction, SubstrateTransactionType } from './data/transaction/SubstrateTransaction';\nimport { SubstrateNodeClient } from './node/SubstrateNodeClient';\nexport interface SubstrateTransactionDetails<Network extends SubstrateNetwork> {\n    runtimeVersion: number | undefined;\n    fee: BigNumber;\n    transaction: SubstrateTransaction<Network>;\n    payload: string;\n}\nexport interface SubstrateTransactionConfig {\n    type: SubstrateTransactionType;\n    tip: string | number | BigNumber;\n    args: any;\n}\nexport declare class SubstrateTransactionController<Network extends SubstrateNetwork> {\n    readonly network: Network;\n    readonly nodeClient: SubstrateNodeClient<Network>;\n    constructor(network: Network, nodeClient: SubstrateNodeClient<Network>);\n    prepareSubmittableTransactions(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, available: BigNumber | string, txConfig: SubstrateTransactionConfig[]): Promise<string>;\n    createTransaction(type: SubstrateTransactionType, accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, tip?: string | number | BigNumber, args?: any, chainHeight?: number | BigNumber, nonce?: number | BigNumber): Promise<SubstrateTransaction<Network>>;\n    protected getDefaultSignatureType(): SubstrateSignatureType;\n    createTransactionMethod(type: SubstrateTransactionType, args?: any): Promise<SubstrateTransactionMethod>;\n    signTransaction(privateKey: Buffer, transaction: SubstrateTransaction<Network>, payload: string): Promise<SubstrateTransaction<Network>>;\n    encodeDetails(txs: SubstrateTransactionDetails<Network>[]): string;\n    decodeDetails(serialized: string): SubstrateTransactionDetails<Network>[];\n    calculateTransactionFee(transaction: SubstrateTransaction<Network>): Promise<BigNumber | null>;\n    estimateTransactionFees(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, transationTypes: [SubstrateTransactionType, any][]): Promise<BigNumber | null>;\n    private prepareTransactionDetails;\n    protected signWithPrivateKey(privateKey: Buffer, transaction: SubstrateTransaction<Network>, payload: string, signatureType: SubstrateSignatureType): Promise<SubstrateTransaction<Network>>;\n    private signPayload;\n    private signEd25519Payload;\n    private signSr25519Payload;\n    private signEcdsaPayload;\n    private substrateAddressFrom;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/compat/SubstrateCompatAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { CoinAddress } from '../../ICoinProtocol';\nimport { SCALEDecodeResult } from '../common/data/scale/SCALEDecoder';\nimport { SCALEAccountId } from '../common/data/scale/type/SCALEAccountId';\nimport { SCALEMultiAddress, SCALEMultiAddressType } from '../common/data/scale/type/SCALEMultiAddress';\nimport { SCALEType } from '../common/data/scale/type/SCALEType';\nimport { KusamaAddress } from '../kusama/KusamaAddress';\nimport { MoonbeamAddress } from '../moonbeam/data/account/MoonbeamAddress';\nimport { PolkadotAddress } from '../polkadot/PolkadotAddress';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nexport declare type SubstrateAccountId<T extends SubstrateCompatAddress> = string | T;\nexport interface SubstrateAddressFactory<Network extends SubstrateNetwork> {\n    from(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>): SubstrateCompatAddressType[Network];\n    getPlaceholder(): SubstrateCompatAddressType[Network];\n}\nexport interface SCALEAddressFactory<Network extends SubstrateNetwork> {\n    from(value: string | Uint8Array | Buffer | SubstrateCompatAddressType[Network], network: Network): SCALECompatAddressType[Network];\n    decode(network: Network, runtimeVersion: number | undefined, hex: string): SCALEDecodeResult<SCALECompatAddressType[Network]>;\n}\nexport interface SubstrateCompatAddressType extends Record<SubstrateNetwork, SubstrateCompatAddress> {\n    [SubstrateNetwork.POLKADOT]: PolkadotAddress;\n    [SubstrateNetwork.KUSAMA]: KusamaAddress;\n    [SubstrateNetwork.MOONBEAM]: MoonbeamAddress;\n}\nexport interface SCALECompatAddressType extends Record<SubstrateNetwork, SCALEType> {\n    [SubstrateNetwork.POLKADOT]: SCALEMultiAddress<SCALEMultiAddressType.Id, SubstrateNetwork.POLKADOT>;\n    [SubstrateNetwork.KUSAMA]: SCALEMultiAddress<SCALEMultiAddressType.Id, SubstrateNetwork.KUSAMA>;\n    [SubstrateNetwork.MOONBEAM]: SCALEAccountId<SubstrateNetwork.MOONBEAM>;\n}\nexport declare function substrateAddressFactory<Network extends SubstrateNetwork>(substrateNetwork: Network): SubstrateAddressFactory<Network>;\nexport declare function scaleAddressFactory<Network extends SubstrateNetwork>(substrateNetwork: Network): SCALEAddressFactory<Network>;\nexport interface SubstrateCompatAddress extends CoinAddress {\n    compare(other: SubstrateAccountId<this>): number;\n    getBufferBytes(): Buffer;\n    getHexBytes(): string;\n}\nexport declare function isSubstrateCompatAddress(address: unknown): address is SubstrateCompatAddress;\n"},{name:"@airgap/coinlib-core/protocols/substrate/compat/SubstrateCompatSignature.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../common/data/scale/SCALEDecoder';\nimport { SubstrateSignature, SubstrateSignatureType } from '../common/data/transaction/SubstrateSignature';\nimport { MoonbeamSignature } from '../moonbeam/data/transaction/MoonbeamSignature';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nexport interface SubstrateSignatureFactory<Network extends SubstrateNetwork> {\n    create(type: SubstrateSignatureType, signature?: string | Uint8Array | Buffer): SubstrateCompatSignatureType[Network];\n    decode(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateCompatSignatureType[Network]>;\n}\nexport interface SubstrateCompatSignatureType extends Record<SubstrateNetwork, SubstrateSignature> {\n    [SubstrateNetwork.POLKADOT]: SubstrateSignature;\n    [SubstrateNetwork.KUSAMA]: SubstrateSignature;\n    [SubstrateNetwork.MOONBEAM]: MoonbeamSignature;\n}\nexport declare function substrateSignatureFactory<Network extends SubstrateNetwork>(substrateNetwork: Network): SubstrateSignatureFactory<Network>;\n"},{name:"@airgap/coinlib-core/protocols/substrate/kusama/KusamaAddress.d.ts",dts:"import { SubstrateAddress } from '../common/data/account/SubstrateAddress';\nimport { SubstrateAccountId } from '../compat/SubstrateCompatAddress';\nexport declare class KusamaAddress extends SubstrateAddress {\n    static getPlaceholder(): KusamaAddress;\n    static from(accountId: SubstrateAccountId<KusamaAddress>): KusamaAddress;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/kusama/KusamaProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { SubstrateDelegateProtocol } from '../SubstrateDelegateProtocol';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class KusamaProtocol extends SubstrateDelegateProtocol<SubstrateNetwork.KUSAMA> {\n    readonly options: SubstrateProtocolOptions<SubstrateNetwork.KUSAMA>;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    addressIsCaseSensitive: boolean;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    constructor(options?: SubstrateProtocolOptions<SubstrateNetwork.KUSAMA>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/kusama/KusamaProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../../utils/ProtocolNetwork';\nimport { SubstrateNodeClient } from '../common/node/SubstrateNodeClient';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubscanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolNetworkExtras, SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class KusamaProtocolNetworkExtras extends SubstrateProtocolNetworkExtras<SubstrateNetwork.KUSAMA> {\n    readonly apiUrl: string;\n    constructor(apiUrl?: string);\n}\nexport declare class KusamaSubscanBlockExplorer extends SubscanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class KusamaProtocolConfig extends SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class KusamaProtocolNetwork extends ProtocolNetwork<KusamaProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: KusamaProtocolNetworkExtras);\n}\nexport declare class KusamaProtocolOptions extends SubstrateProtocolOptions<SubstrateNetwork.KUSAMA, KusamaProtocolConfig> {\n    readonly network: KusamaProtocolNetwork;\n    readonly config: KusamaProtocolConfig;\n    constructor(network?: KusamaProtocolNetwork, config?: KusamaProtocolConfig, nodeClient?: SubstrateNodeClient<SubstrateNetwork.KUSAMA>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/controllers/MoonbeamAccountController.d.ts",dts:"import { KeyPair } from '../../../../data/KeyPair';\nimport { SubstrateAccountController } from '../../common/SubstrateAccountController';\nimport { SubstrateAccountId } from '../../compat/SubstrateCompatAddress';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nimport { MoonbeamAddress } from '../data/account/MoonbeamAddress';\nimport { MoonbeamCollatorDetails } from '../data/staking/MoonbeamCollatorDetails';\nimport { MoonbeamDelegationDetails } from '../data/staking/MoonbeamDelegationDetails';\nimport { MoonbeamDelegatorDetails } from '../data/staking/MoonbeamDelegatorDetails';\nimport { MoonbeamNodeClient } from '../node/MoonbeamNodeClient';\nexport declare class MoonbeamAccountController extends SubstrateAccountController<SubstrateNetwork.MOONBEAM, MoonbeamNodeClient> {\n    createKeyPairFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<KeyPair>;\n    createKeyPairFromHexSecret(secret: string, derivationPath: string): Promise<KeyPair>;\n    createAddressFromPublicKey(publicKey: string): Promise<MoonbeamAddress>;\n    isDelegating(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<boolean>;\n    getMinDelegationAmount(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<string>;\n    getCurrentCollators(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<string[]>;\n    getDelegatorDetails(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<MoonbeamDelegatorDetails>;\n    getCollatorDetails(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<MoonbeamCollatorDetails>;\n    getDelegationDetails(accountId: SubstrateAccountId<MoonbeamAddress>, collator: SubstrateAccountId<MoonbeamAddress>): Promise<MoonbeamDelegationDetails>;\n    private getStakingActions;\n    private getUndelegatedActions;\n    private getDelegatedActions;\n    private getLeavingActions;\n    private getRequestActions;\n    private getRevokeRequestActions;\n    private getDecreaseRequestActions;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/controllers/MoonbeamTransactionController.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateSignatureType } from '../../common/data/transaction/SubstrateSignature';\nimport { SubstrateTransaction } from '../../common/data/transaction/SubstrateTransaction';\nimport { SubstrateTransactionController } from '../../common/SubstrateTransactionController';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nexport declare class MoonbeamTransactionController extends SubstrateTransactionController<SubstrateNetwork.MOONBEAM> {\n    getDefaultSignatureType(): SubstrateSignatureType;\n    signTransaction(privateKey: Buffer, transaction: SubstrateTransaction<SubstrateNetwork.MOONBEAM>, payload: string): Promise<SubstrateTransaction<SubstrateNetwork.MOONBEAM>>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/account/MoonbeamAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateAccountId, SubstrateCompatAddress } from '../../../compat/SubstrateCompatAddress';\nexport declare class MoonbeamAddress implements SubstrateCompatAddress {\n    static getPlaceholder(): MoonbeamAddress;\n    static from(accountId: SubstrateAccountId<MoonbeamAddress>): MoonbeamAddress;\n    static fromBytes(publicKeyOrAddress: string | Uint8Array | Buffer): MoonbeamAddress;\n    static fromPublicKey(publicKey: string | Uint8Array | Buffer): MoonbeamAddress;\n    private readonly value;\n    constructor(value: string);\n    compare(other: SubstrateAccountId<MoonbeamAddress>): number;\n    getValue(): string;\n    getBufferBytes(): Buffer;\n    getHexBytes(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamBond.d.ts",dts:"import { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEAccountId } from '../../../common/data/scale/type/SCALEAccountId';\nimport { SCALEClass } from '../../../common/data/scale/type/SCALEClass';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALEType } from '../../../common/data/scale/type/SCALEType';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nexport declare class MoonbeamBond extends SCALEClass {\n    readonly owner: SCALEAccountId<SubstrateNetwork.MOONBEAM>;\n    readonly amount: SCALEInt;\n    static decode(runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamBond>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamCandidateBondLessRequest.d.ts",dts:"import { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEClass } from '../../../common/data/scale/type/SCALEClass';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALEType } from '../../../common/data/scale/type/SCALEType';\nexport declare class MoonbeamCandidateBondLessRequest extends SCALEClass {\n    readonly amount: SCALEInt;\n    readonly whenExecutable: SCALEInt;\n    static decode(runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamCandidateBondLessRequest>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamCollatorCandidate.d.ts",dts:"import { SCALEAccountId } from '../../../common/data/scale/type/SCALEAccountId';\nimport { SCALEArray } from '../../../common/data/scale/type/SCALEArray';\nimport { SCALEEnum } from '../../../common/data/scale/type/SCALEEnum';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALEOptional } from '../../../common/data/scale/type/SCALEOptional';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { MoonbeamBond } from './MoonbeamBond';\nimport { MoonbeamCandidateBondLessRequest } from './MoonbeamCandidateBondLessRequest';\nexport declare enum MoonbeamCollatorStatus {\n    ACTIVE = 0,\n    IDLE = 1,\n    LEAVING = 2\n}\nexport declare class MoonbeamCollatorCandidate {\n    readonly id: SCALEAccountId<SubstrateNetwork.MOONBEAM>;\n    readonly bond: SCALEInt;\n    readonly delegators: SCALEArray<SCALEAccountId<SubstrateNetwork.MOONBEAM>>;\n    readonly topDelegations: SCALEArray<MoonbeamBond>;\n    readonly bottomDelegations: SCALEArray<MoonbeamBond>;\n    readonly totalCounted: SCALEInt;\n    readonly totalBacking: SCALEInt;\n    readonly request: SCALEOptional<MoonbeamCandidateBondLessRequest>;\n    readonly status: SCALEEnum<MoonbeamCollatorStatus>;\n    static decode(runtimeVersion: number | undefined, raw: string): MoonbeamCollatorCandidate;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamCollatorDetails.d.ts",dts:"import { DelegateeDetails } from '../../../../ICoinDelegateProtocol';\nexport interface MoonbeamCollatorDetails extends DelegateeDetails {\n    status?: 'Active' | 'Idle' | 'Leaving';\n    minEligibleBalance: string;\n    ownStakingBalance: string;\n    totalStakingBalance: string;\n    commission: string;\n    delegators: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamDelegationDetails.d.ts",dts:"import { MoonbeamCollatorDetails } from './MoonbeamCollatorDetails';\nimport { MoonbeamDelegatorDetails } from './MoonbeamDelegatorDetails';\nexport interface MoonbeamDelegationRequest {\n    type: 'revoke' | 'decrease';\n    amount: string;\n    executableIn?: number;\n}\nexport interface MoonbeamDelegationDetails {\n    delegatorDetails: MoonbeamDelegatorDetails;\n    collatorDetails: MoonbeamCollatorDetails;\n    bond: string;\n    pendingRequest?: MoonbeamDelegationRequest;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamDelegationRequest.d.ts",dts:"import { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEAccountId } from '../../../common/data/scale/type/SCALEAccountId';\nimport { SCALEClass } from '../../../common/data/scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../common/data/scale/type/SCALEEnum';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALEType } from '../../../common/data/scale/type/SCALEType';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nexport declare enum MoonbeamDelegationChange {\n    REVOKE = 0,\n    DECREASE = 1\n}\nexport declare class MoonbeamDelegationRequest extends SCALEClass {\n    readonly collator: SCALEAccountId<SubstrateNetwork.MOONBEAM>;\n    readonly amount: SCALEInt;\n    readonly whenExecutable: SCALEInt;\n    readonly action: SCALEEnum<MoonbeamDelegationChange>;\n    static decode(runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamDelegationRequest>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamDelegator.d.ts",dts:"import { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEAccountId } from '../../../common/data/scale/type/SCALEAccountId';\nimport { SCALEArray } from '../../../common/data/scale/type/SCALEArray';\nimport { SCALEClass } from '../../../common/data/scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../common/data/scale/type/SCALEEnum';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALEType } from '../../../common/data/scale/type/SCALEType';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { MoonbeamBond } from './MoonbeamBond';\nimport { MoonbeamPendingDelegationRequests } from './MoonbeamPendingDelegationRequests';\nexport declare enum MoonbeamDelegatorStatusRaw {\n    ACTIVE = 0,\n    LEAVING = 1\n}\nexport declare abstract class MoonbeamDelegatorStatus extends SCALEClass {\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamDelegatorStatus>;\n    abstract readonly type: SCALEEnum<MoonbeamDelegatorStatusRaw>;\n    protected abstract readonly _scaleFields: SCALEType[];\n    protected get scaleFields(): SCALEType[];\n}\nexport declare class MoonbeamDelegatorStatusActive extends MoonbeamDelegatorStatus {\n    static decode<Network extends SubstrateNetwork>(_network: Network, _runtimeVersion: number | undefined, _raw: string): SCALEDecodeResult<MoonbeamDelegatorStatusActive>;\n    readonly type: SCALEEnum<MoonbeamDelegatorStatusRaw>;\n    protected readonly _scaleFields: SCALEType[];\n}\nexport declare class MoonbeamDelegatorStatusLeaving extends MoonbeamDelegatorStatus {\n    readonly roundIndex: SCALEInt;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamDelegatorStatusLeaving>;\n    readonly type: SCALEEnum<MoonbeamDelegatorStatusRaw>;\n    protected readonly _scaleFields: SCALEType[];\n    constructor(roundIndex: SCALEInt);\n}\nexport declare class MoonbeamDelegator {\n    readonly id: SCALEAccountId<SubstrateNetwork.MOONBEAM>;\n    readonly delegations: SCALEArray<MoonbeamBond>;\n    readonly total: SCALEInt;\n    readonly requests: MoonbeamPendingDelegationRequests;\n    readonly status: MoonbeamDelegatorStatus;\n    static decode(runtimeVersion: number | undefined, raw: string): MoonbeamDelegator;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamDelegatorDetails.d.ts",dts:"import { DelegatorDetails } from '../../../../ICoinDelegateProtocol';\nexport interface MoonbeamDelegatorDetails extends DelegatorDetails {\n    totalBond: string;\n    status?: 'Active' | 'Leaving' | 'ReadyToLeave';\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamPendingDelegationRequests.d.ts",dts:"import { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEAccountId } from '../../../common/data/scale/type/SCALEAccountId';\nimport { SCALEArray } from '../../../common/data/scale/type/SCALEArray';\nimport { SCALEClass } from '../../../common/data/scale/type/SCALEClass';\nimport { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nimport { SCALETuple } from '../../../common/data/scale/type/SCALETuple';\nimport { SCALEType } from '../../../common/data/scale/type/SCALEType';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { MoonbeamDelegationRequest } from './MoonbeamDelegationRequest';\nexport declare class MoonbeamPendingDelegationRequests extends SCALEClass {\n    readonly revocationsCount: SCALEInt;\n    readonly requests: SCALEArray<SCALETuple<SCALEAccountId<SubstrateNetwork.MOONBEAM>, MoonbeamDelegationRequest>>;\n    readonly lessTotal: SCALEInt;\n    static decode(runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MoonbeamPendingDelegationRequests>;\n    protected scaleFields: SCALEType[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamRoundInfo.d.ts",dts:"import { SCALEInt } from '../../../common/data/scale/type/SCALEInt';\nexport declare class MoonbeamRoundInfo {\n    readonly current: SCALEInt;\n    readonly first: SCALEInt;\n    readonly length: SCALEInt;\n    static decode(runtimeVersion: number | undefined, raw: string): MoonbeamRoundInfo;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/staking/MoonbeamStakingActionType.d.ts",dts:'export declare enum MoonbeamStakingActionType {\n    DELEGATE = "delegate",\n    SCHEDULE_UNDELEGATE = "schedule_undelegate",\n    EXECUTE_UNDELEGATE = "execute_undelegate",\n    CANCEL_UNDELEGATE = "cancel_undelegate",\n    SCHEDULE_UNDELEGATE_ALL = "schedule_undelegate_all",\n    EXECUTE_UNDELEGATE_ALL = "execute_undelegate_all",\n    CANCEL_UNDELEGATE_ALL = "cancel_undelegate_all",\n    BOND_MORE = "bond_more",\n    SCHEDULE_BOND_LESS = "schedule_bond_less",\n    EXECUTE_BOND_LESS = "execute_bond_less",\n    CANCEL_BOND_LESS = "cancel_bond_less"\n}\n'},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/data/transaction/MoonbeamSignature.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../../../common/data/scale/SCALEDecoder';\nimport { SCALEHash } from '../../../common/data/scale/type/SCALEHash';\nimport { SubstrateSignature, SubstrateSignatureType } from '../../../common/data/transaction/SubstrateSignature';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nexport declare class MoonbeamSignature extends SubstrateSignature {\n    static create(type?: SubstrateSignatureType, signature?: string | Uint8Array | Buffer): MoonbeamSignature;\n    static decode<Network extends SubstrateNetwork>(network: Network, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateSignature>;\n    protected scaleFields: SCALEHash[];\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/moonbase/MoonbaseProtocol.d.ts",dts:"import { MoonbeamProtocol } from '../MoonbeamProtocol';\nimport { ProtocolSymbols } from '../../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../../ICoinProtocol';\nimport { MoonbaseProtocolOptions } from './MoonbaseProtocolOptions';\nexport declare class MoonbaseProtocol extends MoonbeamProtocol {\n    readonly options: MoonbaseProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    addressIsCaseSensitive: boolean;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    constructor(options?: MoonbaseProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/moonbase/MoonbaseProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../../utils/ProtocolBlockExplorer';\nimport { NetworkType } from '../../../../utils/ProtocolNetwork';\nimport { SubscanBlockExplorer } from '../../SubstrateProtocolOptions';\nimport { BaseMoonbeamProtocolNetwork, BaseMoonbeamProtocolOptions, MoonbeamProtocolConfig, MoonbeamProtocolNetworkExtras } from '../MoonbeamProtocolOptions';\nexport declare class MoonbaseProtocolConfig extends MoonbeamProtocolConfig {\n}\nexport declare class MoonbaseProtocolNetworkExtras extends MoonbeamProtocolNetworkExtras {\n    readonly apiUrl: string;\n    constructor(apiUrl?: string);\n}\nexport declare class MoonbaseSubscanBlockExplorer extends SubscanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class MoonbaseProtocolNetwork extends BaseMoonbeamProtocolNetwork<MoonbaseProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: MoonbaseProtocolNetworkExtras);\n}\nexport declare class MoonbaseProtocolOptions extends BaseMoonbeamProtocolOptions<MoonbaseProtocolConfig> {\n    readonly network: MoonbaseProtocolNetwork;\n    readonly config: MoonbaseProtocolConfig;\n    constructor(network?: MoonbaseProtocolNetwork, config?: MoonbaseProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/moonriver/MoonriverProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../../ICoinProtocol';\nimport { MoonbeamProtocol } from '../MoonbeamProtocol';\nimport { MoonriverProtocolOptions } from './MoonriverProtocolOptions';\nexport declare class MoonriverProtocol extends MoonbeamProtocol {\n    readonly options: MoonriverProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    addressIsCaseSensitive: boolean;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    constructor(options?: MoonriverProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/moonriver/MoonriverProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../../utils/ProtocolBlockExplorer';\nimport { NetworkType } from '../../../../utils/ProtocolNetwork';\nimport { SubscanBlockExplorer } from '../../SubstrateProtocolOptions';\nimport { BaseMoonbeamProtocolNetwork, BaseMoonbeamProtocolOptions, MoonbeamProtocolConfig, MoonbeamProtocolNetworkExtras } from '../MoonbeamProtocolOptions';\nexport declare class MoonriverProtocolConfig extends MoonbeamProtocolConfig {\n}\nexport declare class MoonriverProtocolNetworkExtras extends MoonbeamProtocolNetworkExtras {\n    readonly apiUrl: string;\n    constructor(apiUrl?: string);\n}\nexport declare class MoonriverSubscanBlockExplorer extends SubscanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class MoonriverProtocolNetwork extends BaseMoonbeamProtocolNetwork<MoonriverProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: MoonriverProtocolNetworkExtras);\n}\nexport declare class MoonriverProtocolOptions extends BaseMoonbeamProtocolOptions<MoonriverProtocolConfig> {\n    readonly network: MoonriverProtocolNetwork;\n    readonly config: MoonriverProtocolConfig;\n    constructor(network?: MoonriverProtocolNetwork, config?: MoonriverProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/node/MoonbeamNodeClient.d.ts",dts:"import BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNodeClient } from '../../common/node/SubstrateNodeClient';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nimport { MoonbeamAddress } from '../data/account/MoonbeamAddress';\nimport { MoonbeamCollatorCandidate } from '../data/staking/MoonbeamCollatorCandidate';\nimport { MoonbeamDelegator } from '../data/staking/MoonbeamDelegator';\nimport { MoonbeamRoundInfo } from '../data/staking/MoonbeamRoundInfo';\nexport declare class MoonbeamNodeClient extends SubstrateNodeClient<SubstrateNetwork.MOONBEAM> {\n    getRound(): Promise<MoonbeamRoundInfo | undefined>;\n    getCollators(): Promise<MoonbeamAddress[] | undefined>;\n    getDelegatorState(address: MoonbeamAddress): Promise<MoonbeamDelegator | undefined>;\n    getCandidateState(address: MoonbeamAddress): Promise<MoonbeamCollatorCandidate | undefined>;\n    getCollatorCommission(): Promise<BigNumber | undefined>;\n    getMaxDelegatorsPerCandidate(): Promise<BigNumber | undefined>;\n    getMaxDelegationsPerDelegator(): Promise<BigNumber | undefined>;\n    getMinDelegation(): Promise<BigNumber | undefined>;\n    getMinDelegatorStake(): Promise<BigNumber | undefined>;\n    getCandidateBondLessDelay(): Promise<BigNumber | undefined>;\n    getLeaveDelegatorsDelay(): Promise<BigNumber | undefined>;\n    getRevokeDelegationDelay(): Promise<BigNumber | undefined>;\n    getDelegationBondLessDelay(): Promise<BigNumber | undefined>;\n    getDefaultBlocksPerRound(): Promise<BigNumber | undefined>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/MoonbeamProtocol.d.ts",dts:"import { BigNumber } from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { RawSubstrateTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails } from '../../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { SubstrateTransactionType } from '../common/data/transaction/SubstrateTransaction';\nimport { SubstrateAccountId } from '../compat/SubstrateCompatAddress';\nimport { SubstrateDelegateProtocol } from '../SubstrateDelegateProtocol';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { MoonbeamAddress } from './data/account/MoonbeamAddress';\nimport { MoonbeamProtocolOptions } from './MoonbeamProtocolOptions';\nexport declare class MoonbeamProtocol extends SubstrateDelegateProtocol<SubstrateNetwork.MOONBEAM> {\n    readonly options: MoonbeamProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    addressIsCaseSensitive: boolean;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    defaultValidator?: string;\n    constructor(options?: MoonbeamProtocolOptions);\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: any, data?: any): Promise<any[]>;\n    prepareDelegation(publicKey: string, tip: string | number | BigNumber, candidate: string, amount: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareScheduleUndelegate(publicKey: string, tip: string | number | BigNumber, collator: string): Promise<RawSubstrateTransaction[]>;\n    prepareExecuteUndelegate(publicKey: string, tip: string | number | BigNumber, candidate: string): Promise<RawSubstrateTransaction[]>;\n    prepareCancelUndelegate(publicKey: string, tip: string | number | BigNumber, candidate: string): Promise<RawSubstrateTransaction[]>;\n    prepareScheduleUndelegateAll(publicKey: string, tip: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareExecuteUndelegateAll(publicKey: string, tip: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareCancelUndelegateAll(publicKey: string, tip: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareDelegatorBondMore(publicKey: string, tip: string | number | BigNumber, candidate: string, more: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareScheduleDelegatorBondLess(publicKey: string, tip: string | number | BigNumber, candidate: string, less: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareExecuteDelegatorBondLess(publicKey: string, tip: string | number | BigNumber, candidate: string): Promise<RawSubstrateTransaction[]>;\n    prepareCancelDelegatorBondLess(publicKey: string, tip: string | number | BigNumber, candidate: string): Promise<RawSubstrateTransaction[]>;\n    private prepareExecuteDelegationRequest;\n    private prepareCancelDelegationRequest;\n    getMinDelegationAmount(accountId: SubstrateAccountId<MoonbeamAddress>): Promise<string>;\n    getFutureRequiredTransactions(accountId: SubstrateAccountId<MoonbeamAddress>, intention: 'check' | 'transfer' | 'delegate'): Promise<[SubstrateTransactionType, any][]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/moonbeam/MoonbeamProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../../utils/ProtocolNetwork';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubscanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolNetworkExtras, SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nimport { MoonbeamAccountController } from './controllers/MoonbeamAccountController';\nimport { MoonbeamTransactionController } from './controllers/MoonbeamTransactionController';\nimport { MoonbeamNodeClient } from './node/MoonbeamNodeClient';\nexport declare class MoonbeamProtocolConfig extends SubstrateProtocolConfig {\n}\nexport declare class MoonbeamProtocolNetworkExtras extends SubstrateProtocolNetworkExtras<SubstrateNetwork.MOONBEAM> {\n    readonly apiUrl: string;\n    constructor(apiUrl: string);\n}\nexport declare class MoonbeamSubscanBlockExplorer extends SubscanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class BaseMoonbeamProtocolNetwork<Extras extends MoonbeamProtocolNetworkExtras = MoonbeamProtocolNetworkExtras> extends ProtocolNetwork<Extras> {\n    constructor(name: string | undefined, type: NetworkType | undefined, rpcUrl: string, blockExplorer: ProtocolBlockExplorer, extras: Extras);\n}\nexport declare class MoonbeamProtocolNetwork extends BaseMoonbeamProtocolNetwork {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: MoonbeamProtocolNetworkExtras);\n}\nexport declare class BaseMoonbeamProtocolOptions<Config extends MoonbeamProtocolConfig = MoonbeamProtocolConfig> extends SubstrateProtocolOptions<SubstrateNetwork.MOONBEAM, Config, MoonbeamNodeClient, MoonbeamAccountController, MoonbeamTransactionController> {\n    readonly network: MoonbeamProtocolNetwork;\n    readonly config: Config;\n    constructor(network: MoonbeamProtocolNetwork, config: Config, nodeClient?: MoonbeamNodeClient);\n}\nexport declare class MoonbeamProtocolOptions extends BaseMoonbeamProtocolOptions {\n    readonly network: MoonbeamProtocolNetwork;\n    readonly config: MoonbeamProtocolConfig;\n    constructor(network?: MoonbeamProtocolNetwork, config?: MoonbeamProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/polkadot/PolkadotAddress.d.ts",dts:"import { SubstrateAddress } from '../common/data/account/SubstrateAddress';\nimport { SubstrateAccountId } from '../compat/SubstrateCompatAddress';\nexport declare class PolkadotAddress extends SubstrateAddress {\n    static getPlaceholder(): PolkadotAddress;\n    static from(accountId: SubstrateAccountId<PolkadotAddress>): PolkadotAddress;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/polkadot/PolkadotProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { SubstrateDelegateProtocol } from '../SubstrateDelegateProtocol';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class PolkadotProtocol extends SubstrateDelegateProtocol<SubstrateNetwork.POLKADOT> {\n    readonly options: SubstrateProtocolOptions<SubstrateNetwork.POLKADOT>;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    addressIsCaseSensitive: boolean;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    protected defaultValidator: string;\n    constructor(options?: SubstrateProtocolOptions<SubstrateNetwork.POLKADOT>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/polkadot/PolkadotProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../../utils/ProtocolNetwork';\nimport { SubstrateNodeClient } from '../common/node/SubstrateNodeClient';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubscanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolNetworkExtras, SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class PolkadotProtocolNetworkExtras extends SubstrateProtocolNetworkExtras<SubstrateNetwork.POLKADOT> {\n    readonly apiUrl: string;\n    constructor(apiUrl?: string);\n}\nexport declare class PolkadotSubscanBlockExplorer extends SubscanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class PolkadotProtocolConfig extends SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class PolkadotProtocolNetwork extends ProtocolNetwork<PolkadotProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: PolkadotProtocolNetworkExtras);\n}\nexport declare class PolkadotProtocolOptions extends SubstrateProtocolOptions<SubstrateNetwork.POLKADOT, PolkadotProtocolConfig> {\n    readonly network: PolkadotProtocolNetwork;\n    readonly config: PolkadotProtocolConfig;\n    constructor(network?: PolkadotProtocolNetwork, config?: PolkadotProtocolConfig, nodeClient?: SubstrateNodeClient<SubstrateNetwork.POLKADOT>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Sr25519CryptoClient } from '../Sr25519CryptoClient';\nexport declare class SubstrateCryptoClient extends Sr25519CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateDelegateProtocol.d.ts",dts:"import BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { RawSubstrateTransaction } from '../../serializer/types';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { SubstratePayee } from './common/data/staking/SubstratePayee';\nimport { SubstrateStakingActionType } from './common/data/staking/SubstrateStakingActionType';\nimport { SubstrateNetwork } from './SubstrateNetwork';\nimport { SubstrateProtocol } from './SubstrateProtocol';\nexport declare abstract class SubstrateDelegateProtocol<Network extends SubstrateNetwork> extends SubstrateProtocol<Network> implements ICoinDelegateProtocol {\n    protected defaultValidator?: string;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: SubstrateStakingActionType, data?: any): Promise<RawSubstrateTransaction[]>;\n    prepareNomination(publicKey: string, tip: string | number | BigNumber, targets: string[] | string, controller?: string, value?: string | number | BigNumber, payee?: string | SubstratePayee): Promise<RawSubstrateTransaction[]>;\n    prepareRebondNominate(publicKey: string, tip: string | number | BigNumber, targets: string[] | string, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareScheduleUndelegate(publicKey: string, tip: string | number | BigNumber, value?: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareChangeValidator(publicKey: string, tip: string | number | BigNumber, targets: string[] | string): Promise<RawSubstrateTransaction[]>;\n    prepareUnbond(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareRebond(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareBondExtra(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareRebondExtra(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareWithdrawUnbonded(publicKey: string, tip: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    estimateMaxDelegationValueFromAddress(address: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateNetwork.d.ts",dts:"export declare enum SubstrateNetwork {\n    POLKADOT = 0,\n    KUSAMA = 1,\n    MOONBEAM = 2\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedSubstrateTransaction } from '../../serializer/schemas/definitions/signed-transaction-substrate';\nimport { UnsignedSubstrateTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-substrate';\nimport { RawSubstrateTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { SubstrateTransactionType } from './common/data/transaction/SubstrateTransaction';\nimport { SubstrateAccountId, SubstrateCompatAddressType } from './compat/SubstrateCompatAddress';\nimport { SubstrateCryptoClient } from './SubstrateCryptoClient';\nimport { SubstrateNetwork } from './SubstrateNetwork';\nimport { SubstrateProtocolOptions } from './SubstrateProtocolOptions';\nimport { SubstrateTransactionCursor, SubstrateTransactionResult } from './SubstrateTypes';\nexport declare abstract class SubstrateProtocol<Network extends SubstrateNetwork> extends NonExtendedProtocol {\n    readonly options: SubstrateProtocolOptions<Network>;\n    abstract symbol: string;\n    abstract name: string;\n    abstract marketSymbol: string;\n    abstract feeSymbol: string;\n    abstract decimals: number;\n    abstract feeDecimals: number;\n    abstract identifier: ProtocolSymbols;\n    abstract feeDefaults: FeeDefaults;\n    abstract units: CurrencyUnit[];\n    abstract standardDerivationPath: string;\n    supportsHD: boolean;\n    abstract addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    readonly cryptoClient: SubstrateCryptoClient;\n    constructor(options: SubstrateProtocolOptions<Network>);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<SubstrateCompatAddressType[Network]>;\n    getAddressesFromPublicKey(publicKey: string): Promise<SubstrateCompatAddressType[Network][]>;\n    getNextAddressFromPublicKey(publicKey: string, current: SubstrateCompatAddressType[Network]): Promise<SubstrateCompatAddressType[Network]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: SubstrateTransactionCursor): Promise<SubstrateTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: SubstrateTransactionCursor): Promise<SubstrateTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, rawTransaction: RawSubstrateTransaction): Promise<string>;\n    getTransactionDetails(transaction: UnsignedSubstrateTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedSubstrateTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, _recipients: string[], fee?: string, data?: {\n        excludeExistentialDeposit?: boolean;\n    }): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        excludeExistentialDeposit?: boolean;\n    }): Promise<RawSubstrateTransaction>;\n    broadcastTransaction(encoded: string): Promise<string>;\n    getFutureRequiredTransactions(accountId: SubstrateAccountId<SubstrateCompatAddressType[Network]>, intention: 'check' | 'transfer' | 'delegate'): Promise<[SubstrateTransactionType, any][]>;\n    private getTransactionDetailsFromEncoded;\n    signMessage(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { SubstrateBlockExplorerClient } from './common/blockexplorer/SubstrateBlockExplorerClient';\nimport { SubstrateNodeClient } from './common/node/SubstrateNodeClient';\nimport { SubstrateAccountController } from './common/SubstrateAccountController';\nimport { SubstrateTransactionController } from './common/SubstrateTransactionController';\nimport { SubstrateNetwork } from './SubstrateNetwork';\nexport declare class SubstrateProtocolNetworkExtras<T extends SubstrateNetwork> {\n    readonly apiUrl: string;\n    readonly network: T;\n    constructor(apiUrl: string, network: T);\n}\nexport declare class SubscanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class SubstrateProtocolNetwork<T extends SubstrateNetwork> extends ProtocolNetwork<SubstrateProtocolNetworkExtras<T>> {\n    constructor(name: string | undefined, type: NetworkType | undefined, rpcUrl: string, blockExplorer: ProtocolBlockExplorer, extras: SubstrateProtocolNetworkExtras<T>);\n}\nexport declare class SubstrateProtocolOptions<Network extends SubstrateNetwork, Config extends SubstrateProtocolConfig = SubstrateProtocolConfig, NodeClient extends SubstrateNodeClient<Network> = SubstrateNodeClient<Network>, AccountController extends SubstrateAccountController<Network, NodeClient> = SubstrateAccountController<Network, NodeClient>, TransactionController extends SubstrateTransactionController<Network> = SubstrateTransactionController<Network>> implements ProtocolOptions<Config> {\n    readonly network: SubstrateProtocolNetwork<Network>;\n    readonly config: Config;\n    readonly nodeClient: NodeClient;\n    readonly accountController: AccountController;\n    readonly transactionController: TransactionController;\n    readonly blockExplorerClient: SubstrateBlockExplorerClient;\n    constructor(network: SubstrateProtocolNetwork<Network>, config: Config, nodeClient: NodeClient, accountController: AccountController, transactionController: TransactionController);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface SubstrateTransactionCursor {\n    page: number;\n}\nexport interface SubstrateTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: SubstrateTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/remote-data/TezosContractRemoteDataFactory.d.ts",dts:"import { RemoteDataFactory, RemoteDataFactoryExtra } from '../../../../utils/remote-data/RemoteDataFactory';\nimport { TezosProtocolNetworkResolver } from '../../TezosProtocolOptions';\nimport { TezosContract } from '../TezosContract';\ninterface TezosContractRemoteDataFactoryExtra extends RemoteDataFactoryExtra {\n    contract: TezosContract;\n    networkResolver?: TezosProtocolNetworkResolver;\n}\nexport declare class TezosContractRemoteDataFactory extends RemoteDataFactory<TezosContractRemoteDataFactoryExtra> {\n    constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/remote-data/TezosStorageRemoteData.d.ts",dts:"import { RawData, RemoteData } from '../../../../utils/remote-data/RemoteData';\nimport { TezosProtocolNetworkResolver } from '../../TezosProtocolOptions';\nimport { TezosContract } from '../TezosContract';\nexport declare class TezosStorageRemoteData<T> extends RemoteData<T> {\n    private readonly contract;\n    private readonly key;\n    private constructor();\n    static create<T>(uri: string, contract: TezosContract, networkResolver?: TezosProtocolNetworkResolver): TezosStorageRemoteData<T> | undefined;\n    static validate(uri: string): boolean;\n    get(): Promise<T | undefined>;\n    getRaw(): Promise<RawData | undefined>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContract.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosProtocolNetwork, TezosProtocolNetworkResolver } from '../TezosProtocolOptions';\nimport { BigMapRequest } from '../types/contract/BigMapRequest';\nimport { BigMapResponse } from '../types/contract/BigMapResult';\nimport { TezosContractMetadata } from '../types/contract/TezosContractMetadata';\nimport { MichelineNode, MichelineTypeNode } from '../types/micheline/MichelineNode';\nimport { MichelsonType } from '../types/michelson/MichelsonType';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosContractCall } from './TezosContractCall';\nimport { TezosContractEntrypoint } from './TezosContractEntrypoint';\nimport { TezosContractStorage } from './TezosContractStorage';\nexport declare class TezosContract {\n    readonly address: string;\n    readonly network: TezosProtocolNetwork;\n    private static readonly DEFAULT_ENTRYPOINT;\n    entrypoints?: Map<string, TezosContractEntrypoint>;\n    storage?: TezosContractStorage;\n    private codePromise?;\n    bigMapIDs?: number[];\n    private bigMapIDsPromise?;\n    private readonly remoteDataFactory;\n    constructor(address: string, network: TezosProtocolNetwork);\n    copy(values?: {\n        address?: string;\n        network?: TezosProtocolNetwork;\n    }): TezosContract;\n    findBigMap(name: string): Promise<number | undefined>;\n    bigMapValue(bigMapID: number, valueSchema: MichelineTypeNode): Promise<MichelsonType | undefined>;\n    bigMapValue(bigMapID: number, key: unknown, keySchema: MichelineTypeNode, valueSchema: MichelineTypeNode): Promise<MichelsonType | undefined>;\n    bigMapValues(bigMapID: number, valueSchema: MichelineTypeNode): Promise<MichelsonType[]>;\n    conseilBigMapValues(request?: BigMapRequest): Promise<BigMapResponse[]>;\n    readStorage(): Promise<MichelsonType | undefined>;\n    metadata(networkResolver?: TezosProtocolNetworkResolver): Promise<TezosContractMetadata | undefined>;\n    balance(): Promise<string>;\n    createContractCall(entrypointName: string, value: unknown, amount?: BigNumber): Promise<TezosContractCall>;\n    parseContractCall(json: TezosTransactionParameters): Promise<TezosContractCall>;\n    areValidParameters(data: unknown): boolean;\n    parseParameters(parameters: string): TezosTransactionParameters;\n    normalizeContractCallParameters(json: (Partial<TezosTransactionParameters> & Pick<TezosTransactionParameters, 'value'>) | MichelineNode, fallbackEntrypoint?: string): Promise<TezosTransactionParameters>;\n    private createDefaultContractCall;\n    private createEntrypointContractCall;\n    private getBigMapID;\n    private waitForBigMapIDs;\n    private waitForContractCode;\n    private normalizeContractCode;\n    private getMetadataRemoteData;\n    private bigMapRequest;\n    private contractRequest;\n    private conseilRequest;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContractCall.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { MichelsonType } from '../types/michelson/MichelsonType';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nexport declare class TezosContractCall {\n    readonly entrypoint: string;\n    readonly michelsonValue: MichelsonType | undefined;\n    readonly amount?: BigNumber | undefined;\n    constructor(entrypoint: string, michelsonValue: MichelsonType | undefined, amount?: BigNumber | undefined);\n    args(): any | undefined;\n    toJSON(): TezosTransactionParameters;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContractEntrypoint.d.ts",dts:"import { MichelineTypeNode } from '../types/micheline/MichelineNode';\nimport { MichelsonTypeMeta } from '../types/michelson/MichelsonTypeMeta';\nexport declare class TezosContractEntrypoint {\n    readonly name: string;\n    readonly type: MichelsonTypeMeta;\n    static fromJSON(entrypoints: Record<string, MichelineTypeNode>): TezosContractEntrypoint[];\n    constructor(name: string, type: MichelsonTypeMeta);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContractStorage.d.ts",dts:"import { MichelineTypeNode } from '../types/micheline/MichelineNode';\nimport { MichelsonTypeMeta } from '../types/michelson/MichelsonTypeMeta';\nexport declare class TezosContractStorage {\n    readonly type: MichelsonTypeMeta;\n    static fromJSON(storage: MichelineTypeNode): TezosContractStorage | undefined;\n    constructor(type: MichelsonTypeMeta);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/domains/TezosDomains.d.ts",dts:"import { TezosProtocolNetwork } from '../TezosProtocolOptions';\nexport declare class TezosDomains {\n    private readonly contract;\n    private readonly cache;\n    private bigMapIDs?;\n    private bigMapIDsPromise?;\n    constructor(network: TezosProtocolNetwork, contractAddress: string);\n    nameToAddress(name: string): Promise<string | undefined>;\n    addressToName(address: string): Promise<string | undefined>;\n    private resolveName;\n    private resolveAddress;\n    private waitForBigMapIDs;\n    private normalizeDomainName;\n    private checkIfExpired;\n    private parseRecord;\n    private parseReverseRecord;\n    private parseExpiryTimestamp;\n    private nameCacheKey;\n    private addressCacheKey;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosBTC.d.ts",dts:"import { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosBTC extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static readonly bigMapKeyLedgerPrefix;\n    constructor(options?: TezosFAProtocolOptions);\n    getTotalMinted(source?: string, callbackContract?: string): Promise<string>;\n    getTotalBurned(source?: string, callbackContract?: string): Promise<string>;\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosCTez.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolConfig, TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosCTez extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n}\nexport declare class TezosCTezProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosETHtz.d.ts",dts:"import { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosETHtz extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static readonly extractAmountRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA1Protocol.d.ts",dts:"import { IAirGapTransaction } from '../../..';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosFAProtocol } from './TezosFAProtocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosFA1Protocol extends TezosFAProtocol {\n    private readonly defaultCallbackContractMap;\n    constructor(options: TezosFAProtocolOptions);\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    getBalance(address: string, source?: string, callbackContract?: string): Promise<string>;\n    getTotalSupply(source?: string, callbackContract?: string): Promise<string>;\n    transfer(fromAddress: string, toAddress: string, amount: string, fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n    protected getContractCallIntResult(transferCall: TezosContractCall, source: string): Promise<string>;\n    private createTransferCalls;\n    protected callbackContract(): string;\n    private isTransferRequest;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA1p2Protocol.d.ts",dts:"import { RawTezosTransaction } from '../../../serializer/types';\nimport { TezosFATokenMetadata } from '../types/fa/TezosFATokenMetadata';\nimport { TezosFA1Protocol } from './TezosFA1Protocol';\nexport declare class TezosFA1p2Protocol extends TezosFA1Protocol {\n    getTokenMetadata(): Promise<TezosFATokenMetadata | undefined>;\n    getAllowance(ownerAddress: string, spenderAddress: string, callbackContract?: string, source?: string): Promise<string>;\n    approve(spenderAddress: string, amount: string, fee: string, publicKey: string): Promise<RawTezosTransaction>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA2Protocol.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ConseilPredicate } from '../types/contract/ConseilPredicate';\nimport { TezosFA2BalanceOfRequest } from '../types/fa/TezosFA2BalanceOfRequest';\nimport { TezosFA2BalanceOfResponse } from '../types/fa/TezosFA2BalanceOfResponse';\nimport { TezosFA2TransferRequest } from '../types/fa/TezosFA2TransferRequest';\nimport { TezosFA2UpdateOperatorRequest } from '../types/fa/TezosFA2UpdateOperatorRequest';\nimport { TezosFATokenMetadata } from '../types/fa/TezosFATokenMetadata';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosFAProtocol } from './TezosFAProtocol';\nimport { TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\ndeclare enum TezosFA2ContractEntrypoint {\n    BALANCE = \"balance_of\",\n    TRANSFER = \"transfer\",\n    UPDATE_OPERATORS = \"update_operators\"\n}\nexport declare class TezosFA2Protocol extends TezosFAProtocol {\n    readonly options: TezosFA2ProtocolOptions;\n    readonly tokenID?: number;\n    private readonly defaultCallbackContract;\n    constructor(options: TezosFA2ProtocolOptions);\n    getBalanceOfPublicKey(publicKey: string, data?: {\n        addressIndex?: number;\n        assetID?: string;\n        [key: string]: any;\n    }): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[], data?: {\n        assetID?: string;\n        [key: string]: any;\n    }): Promise<string>;\n    getBalanceOfAddresses(addresses: string[], data?: {\n        assetID?: string;\n        [key: string]: any;\n    }): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: {\n        addressIndex?: number;\n        tokenID?: number;\n    }): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex?: number;\n        assetID?: number;\n    }): Promise<RawTezosTransaction>;\n    transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    balanceOf(balanceRequests: TezosFA2BalanceOfRequest[], source?: string, callbackContract?: string): Promise<TezosFA2BalanceOfResponse[]>;\n    transfer(transferRequests: TezosFA2TransferRequest[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    updateOperators(updateRequests: TezosFA2UpdateOperatorRequest[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    getTokenMetadata(tokenID?: number): Promise<TezosFATokenMetadata | undefined>;\n    private static readonly extractAddressRegex;\n    fetchTokenHolders(tokenID?: number): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n    getTotalSupply(tokenID?: number): Promise<string>;\n    protected getAdditionalTransactionQueryPredicates(_address: string, _addressQueryType: 'string' | 'bytes'): ConseilPredicate[];\n    private createTransferCall;\n    protected callbackContract(entrypoint: TezosFA2ContractEntrypoint): string;\n    private isTransferRequest;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFAProtocol.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { RemoteDataFactory } from '../../../utils/remote-data/RemoteDataFactory';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { TezosContract } from '../contract/TezosContract';\nimport { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { TezosProtocolNetworkResolver } from '../TezosProtocolOptions';\nimport { ConseilPredicate } from '../types/contract/ConseilPredicate';\nimport { TezosContractMetadata } from '../types/contract/TezosContractMetadata';\nimport { TezosFATokenMetadata } from '../types/fa/TezosFATokenMetadata';\nimport { MichelineDataNode } from '../types/micheline/MichelineNode';\nimport { TezosTransactionOperation, TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosTransactionCursor } from '../types/TezosTransactionCursor';\nimport { TezosTransactionResult } from '../types/TezosTransactionResult';\nimport { TezosNetwork } from './../TezosProtocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport interface TezosFAProtocolConfiguration {\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    identifier: ProtocolSymbols;\n    contractAddress: string;\n    feeDefaults: FeeDefaults;\n    decimals?: number;\n    jsonRPCAPI?: string;\n    baseApiUrl?: string;\n    network?: TezosNetwork;\n    baseApiKey?: string;\n    baseApiNetwork?: string;\n}\nexport declare abstract class TezosFAProtocol extends TezosProtocol implements ICoinSubProtocol {\n    readonly options: TezosFAProtocolOptions;\n    readonly isSubProtocol: boolean;\n    readonly subProtocolType: SubProtocolType;\n    readonly contractAddress: string;\n    readonly tokenMetadataBigMapID?: number;\n    protected readonly contract: TezosContract;\n    protected readonly defaultSourceAddress: string;\n    protected readonly remoteDataFactory: RemoteDataFactory;\n    constructor(options: TezosFAProtocolOptions);\n    abstract transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    bigMapValue(key: string, isKeyHash?: boolean, bigMapID?: number): Promise<string | null>;\n    contractMetadata(networkResolver?: TezosProtocolNetworkResolver): Promise<TezosContractMetadata | undefined>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string, data?: any): Promise<string>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactionQueryPredicates(address: string, addressQueryType: 'string' | 'bytes'): ConseilPredicate[];\n    protected getAdditionalTransactionQueryPredicates(address: string, addressQueryType: 'string' | 'bytes'): ConseilPredicate[];\n    getTransactions(limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    normalizeTransactionParameters(parameters: string, fallbackEntrypointName?: string): Promise<TezosTransactionParameters>;\n    getAllTokenMetadata(): Promise<Record<number, TezosFATokenMetadata> | undefined>;\n    protected getTokenMetadataForTokenID(tokenID: number): Promise<TezosFATokenMetadata | undefined>;\n    private createRemoteData;\n    protected getTransactionOperationDetails(transactionOperation: TezosTransactionOperation): Promise<Partial<IAirGapTransaction>[]>;\n    private parseParameters;\n    private transactionToAirGapTransactions;\n    protected runContractCall(contractCall: TezosContractCall, source: string): Promise<MichelineDataNode>;\n    protected prepareContractCall(contractCalls: TezosContractCall[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    protected requireSource(source?: string, defaultSource?: string, ...excludedPrefixes: string[]): string;\n    private prepareMockContractCall;\n    private url;\n    private isTokenMetadata;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFAProtocolOptions.d.ts",dts:"import { ProtocolOptions } from '../../../utils/ProtocolOptions';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosProtocolConfig, TezosProtocolNetwork } from '../TezosProtocolOptions';\nexport declare class TezosFAProtocolConfig extends TezosProtocolConfig {\n    readonly contractAddress: string;\n    readonly identifier: ProtocolSymbols;\n    readonly symbol?: string | undefined;\n    readonly name?: string | undefined;\n    readonly marketSymbol?: string | undefined;\n    readonly feeDefaults?: FeeDefaults | undefined;\n    readonly decimals?: number | undefined;\n    readonly tokenMetadataBigMapID?: number | undefined;\n    constructor(contractAddress: string, identifier: ProtocolSymbols, symbol?: string | undefined, name?: string | undefined, marketSymbol?: string | undefined, feeDefaults?: FeeDefaults | undefined, decimals?: number | undefined, tokenMetadataBigMapID?: number | undefined);\n}\nexport declare class TezosFA2ProtocolConfig extends TezosFAProtocolConfig {\n    readonly defaultTokenID?: number | undefined;\n    readonly ledgerBigMapID?: number | undefined;\n    readonly totalSupplyBigMapID?: number | undefined;\n    constructor(contractAddress: string, identifier: ProtocolSymbols, symbol?: string, name?: string, marketSymbol?: string, feeDefaults?: FeeDefaults, decimals?: number, defaultTokenID?: number | undefined, tokenMetadataBigMapID?: number, ledgerBigMapID?: number | undefined, totalSupplyBigMapID?: number | undefined);\n}\nexport declare class TezosBTCProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosETHtzProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosWrappedProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosKolibriUSDProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosStakerProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosUSDProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosUUSDProtocolConfig extends TezosFA2ProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number, tokenId?: number, tokenMetadataBigMapID?: number, ledgerBigMapID?: number);\n}\nexport declare class TezosYOUProtocolConfig extends TezosFA2ProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number, tokenId?: number, tokenMetadataBigMapID?: number, ledgerBigMapID?: number);\n}\nexport declare class TezosFAProtocolOptions implements ProtocolOptions<TezosFAProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosFAProtocolConfig;\n    constructor(network: TezosProtocolNetwork, config: TezosFAProtocolConfig);\n}\nexport declare class TezosFA2ProtocolOptions implements ProtocolOptions<TezosFA2ProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosFA2ProtocolConfig;\n    constructor(network: TezosProtocolNetwork, config: TezosFA2ProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosKolibriUSD.d.ts",dts:"import { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosKolibriUSD extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static readonly extractValueRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosPlanty.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolConfig, TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosPlenty extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n}\nexport declare class TezosPlentyProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosQUIPU.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA2Protocol } from './TezosFA2Protocol';\nimport { TezosFA2ProtocolConfig, TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosQUIPU extends TezosFA2Protocol {\n    readonly options: TezosFA2ProtocolOptions;\n    constructor(options?: TezosFA2ProtocolOptions);\n}\nexport declare class TezosQUIPUProtocolConfig extends TezosFA2ProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number, tokenId?: number, tokenMetadataBigMapID?: number, ledgerBigMapID?: number);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosStaker.d.ts",dts:"import { TezosFA1Protocol } from './TezosFA1Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosStaker extends TezosFA1Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosUDEFI.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA2Protocol } from './TezosFA2Protocol';\nimport { TezosFA2ProtocolConfig, TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosUDEFI extends TezosFA2Protocol {\n    readonly options: TezosFA2ProtocolOptions;\n    constructor(options?: TezosFA2ProtocolOptions);\n}\nexport declare class TezosUDEFIProtocolConfig extends TezosFA2ProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number, tokenId?: number, tokenMetadataBigMapID?: number, ledgerBigMapID?: number);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosUSD.d.ts",dts:"import { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosUSD extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static readonly extractAmountRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosUUSD.d.ts",dts:"import { TezosFA2Protocol } from './TezosFA2Protocol';\nimport { TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosUUSD extends TezosFA2Protocol {\n    readonly options: TezosFA2ProtocolOptions;\n    constructor(options?: TezosFA2ProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosWRAP.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA2Protocol } from './TezosFA2Protocol';\nimport { TezosFA2ProtocolConfig, TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosWRAP extends TezosFA2Protocol {\n    readonly options: TezosFA2ProtocolOptions;\n    constructor(options?: TezosFA2ProtocolOptions);\n}\nexport declare class TezosWRAPProtocolConfig extends TezosFA2ProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number, tokenId?: number, tokenMetadataBigMapID?: number, ledgerBigMapID?: number);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosWrapped.d.ts",dts:"import { TezosFA1p2Protocol } from './TezosFA1p2Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosWrapped extends TezosFA1p2Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosYOU.d.ts",dts:"import { TezosFA2Protocol } from './TezosFA2Protocol';\nimport { TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosYOU extends TezosFA2Protocol {\n    readonly options: TezosFA2ProtocolOptions;\n    constructor(options?: TezosFA2ProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/kt/TezosKtAddress.d.ts",dts:"import { TezosAddress } from '../TezosAddress';\nexport declare class TezosKtAddress extends TezosAddress {\n    static from(value: string): Promise<TezosKtAddress>;\n    static isKtAddress(address: string): boolean;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/kt/TezosKtProtocol.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { TezosKtAddress } from './TezosKtAddress';\nexport declare class TezosKtProtocol extends TezosProtocol implements ICoinSubProtocol {\n    identifier: ProtocolSymbols;\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    addressValidationPattern: string;\n    migrationFee: BigNumber;\n    getAddressFromPublicKey(publicKey: string, addressIndex?: number): Promise<TezosKtAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<TezosKtAddress[]>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string, data?: {\n        addressIndex?: number;\n    }): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(_publicKey: string, _recipients: string[], _values: string[], _fee: string, _data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    originate(publicKey: string, delegate?: string, amount?: BigNumber): Promise<RawTezosTransaction>;\n    delegate(publicKey: string, delegate?: string): Promise<RawTezosTransaction>;\n    migrateKtContract(publicKey: string, destinationContract: string): Promise<{\n        binaryTransaction: string;\n    }>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculation005.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosBakingRewards, TezosEndorsingRewards, TezosEndorsingRight, TezosProtocol } from '../TezosProtocol';\nimport { TezosRewardsCalculationDefault } from './TezosRewardCalculationDefault';\nexport declare class TezosRewardsCalculation005 extends TezosRewardsCalculationDefault {\n    protocol: TezosProtocol;\n    constructor(protocol: TezosProtocol);\n    protected computeBakingRewards(bakingRights: {\n        level: number;\n        priority: number;\n    }[], isFutureCycle: boolean): Promise<TezosBakingRewards>;\n    protected specificBakingCalculation(e: number, p: number): BigNumber;\n    protected computeEndorsingRewards(endorsingRights: TezosEndorsingRight[], isFutureCycle: boolean): Promise<TezosEndorsingRewards>;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculation006.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { TezosRewardsCalculation005 } from './TezosRewardCalculation005';\nexport declare class TezosRewardsCalculation006 extends TezosRewardsCalculation005 {\n    protocol: TezosProtocol;\n    constructor(protocol: TezosProtocol);\n    protected specificBakingCalculation(e: number, p: number): BigNumber;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculationDefault.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosBakingRewards, TezosBakingRight, TezosEndorsingRewards, TezosEndorsingRight, TezosNodeConstants, TezosProtocol, TezosRewards, TezosRewardsCalculations } from '../TezosProtocol';\nexport declare class TezosRewardsCalculationDefault implements TezosRewardsCalculations {\n    protocol: TezosProtocol;\n    protected tezosNodeConstants: TezosNodeConstants;\n    constructor(protocol: TezosProtocol);\n    protected getConstants(currentLevel: number, useHead: boolean): Promise<void>;\n    calculateRewards(bakerAddress: string, cycle: number, breakdownRewards?: boolean, currentCycleIn?: number): Promise<TezosRewards>;\n    private calculatePastRewards;\n    private calculateFutureRewards;\n    private fetchEndorsementOperations;\n    private fetchFrozenBalances;\n    protected computeBakingRewards(bakingRights: {\n        level: number;\n        priority: number;\n    }[], isFutureCycle: boolean): Promise<TezosBakingRewards>;\n    protected computeEndorsingRewards(endorsingRights: TezosEndorsingRight[], isFutureCycle: boolean): Promise<TezosEndorsingRewards>;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n    private computeSnapshotBlockLevel;\n    private fetchBakerInfo;\n    private fetchBlocksForBaker;\n    private readonly blockLevelFieldNameMap;\n    private fetchBlockLevelFieldPromise?;\n    private fetchBlockLevelFieldName;\n    protected fetchBakingRights(bakerAddress: string, cycle: number): Promise<TezosBakingRight[]>;\n    protected fetchEndorsingRights(bakerAddress: string, cycle: number): Promise<TezosEndorsingRight[]>;\n    protected fetchEndorsementOperationCountAndTotalFees(blockLevels: number[]): Promise<Map<number, {\n        sum_number_of_slots: string;\n        block_level: number;\n        sum_fee: number;\n    }>>;\n    protected fetchBlockPriorities(blockLevels: number[]): Promise<{\n        priority: number;\n        level: number;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/node/TezosSaplingNodeClient.d.ts",dts:"import { TezosSaplingStateDiff } from '../../types/sapling/TezosSaplingStateDiff';\nexport declare class TezosSaplingNodeClient {\n    private readonly rpcUrl;\n    private readonly contractAddress;\n    constructor(rpcUrl: string, contractAddress: string);\n    getSaplingStateDiff(): Promise<TezosSaplingStateDiff>;\n    getChainId(): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/utils/TezosSaplingBookkeeper.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapTransaction } from '../../../../interfaces/IAirGapTransaction';\nimport { ProtocolNetwork } from '../../../../utils/ProtocolNetwork';\nimport { ProtocolSymbols } from '../../../../utils/ProtocolSymbols';\nimport { TezosSaplingCiphertext } from '../../types/sapling/TezosSaplingCiphertext';\nimport { TezosSaplingInput } from '../../types/sapling/TezosSaplingInput';\nimport { TezosSaplingOutput } from '../../types/sapling/TezosSaplingOutput';\nimport { TezosSaplingWrappedTransaction } from '../../types/sapling/TezosSaplingWrappedTransaction';\nimport { TezosSaplingAddress } from '../TezosSaplingAddress';\nimport { TezosSaplingCryptoClient } from '../TezosSaplingCryptoClient';\nimport { TezosSaplingEncoder } from './TezosSaplingEncoder';\nexport declare class TezosSaplingBookkeeper {\n    private readonly identifier;\n    private readonly network;\n    private readonly cryptoClient;\n    private readonly encoder;\n    constructor(identifier: ProtocolSymbols, network: ProtocolNetwork, cryptoClient: TezosSaplingCryptoClient, encoder: TezosSaplingEncoder);\n    getUnsignedTransactionDetails(sender: TezosSaplingAddress, inputs: TezosSaplingInput[], outputs: TezosSaplingOutput[], wrappedTransactions: TezosSaplingWrappedTransaction[]): IAirGapTransaction[];\n    getWrappedTransactionsPartialDetails(wrappedTransactions: TezosSaplingWrappedTransaction[], knownViewingKeys?: string[]): Promise<Partial<IAirGapTransaction>[]>;\n    private getTransactionPartialDetails;\n    private findSender;\n    private findRecipient;\n    private decodeDetailsFromOutputDescription;\n    sumNotes(notes: (TezosSaplingInput | TezosSaplingOutput)[]): BigNumber;\n    getIncomingInputs(viewingKey: Buffer | string, commitmentsWithCiphertext: [string, TezosSaplingCiphertext, BigNumber][]): Promise<TezosSaplingInput[]>;\n    getOutgoingInputs(viewingKey: Buffer | string, commitmentsWithCiphertext: [string, TezosSaplingCiphertext, BigNumber][]): Promise<TezosSaplingInput[]>;\n    getUnspends(viewingKey: Buffer | string, commitmentsWithCiphertext: [string, TezosSaplingCiphertext][], nullifiers: string[]): Promise<TezosSaplingInput[]>;\n    private getInputs;\n    private getReceiverInputFromCiphertext;\n    private getSenderInputFromCiphertext;\n    private getIncomingInputFromCiphertext;\n    private getOutgoingInputFromCiphertext;\n    private verifyCommitment;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/utils/TezosSaplingEncoder.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosSaplingCiphertext } from '../../types/sapling/TezosSaplingCiphertext';\nimport { TezosSaplingOutputDescription, TezosSaplingSpendDescription, TezosSaplingTransaction } from '../../types/sapling/TezosSaplingTransaction';\nexport declare class TezosSaplingEncoder {\n    encodeTransaction(transaction: TezosSaplingTransaction): Buffer;\n    encodeSpendDescriptions(descriptions: TezosSaplingSpendDescription[]): Buffer;\n    encodeSpendDescription(description: TezosSaplingSpendDescription): Buffer;\n    encodeOutputDescriptions(descriptions: TezosSaplingOutputDescription[]): Buffer;\n    encodeOutputDescription(description: TezosSaplingOutputDescription): Buffer;\n    private encodeDescriptions;\n    private encodeCiphertext;\n    decodeTransaction(transaction: Buffer): TezosSaplingTransaction;\n    decodeSpendDescriptions(bytes: Buffer): TezosSaplingSpendDescription[];\n    decodeSpendDescription(bytes: Buffer): TezosSaplingSpendDescription;\n    decodeOutputDescriptions(bytes: Buffer): TezosSaplingOutputDescription[];\n    private decodeDescriptions;\n    decodeOutputDescription(bytes: Buffer): TezosSaplingOutputDescription;\n    decodeCiphertext(bytes: Buffer): TezosSaplingCiphertext;\n    decodeBalanceFromTransaction(transaction: Buffer): BigNumber;\n    private decodeBalance;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/utils/TezosSaplingForger.d.ts",dts:"/// <reference types=\"node\" />\nimport { TezosSaplingInput } from '../../types/sapling/TezosSaplingInput';\nimport { TezosSaplingOutput } from '../../types/sapling/TezosSaplingOutput';\nimport { TezosSaplingStateTree } from '../../types/sapling/TezosSaplingStateTree';\nimport { TezosSaplingTransaction } from '../../types/sapling/TezosSaplingTransaction';\nimport { TezosSaplingCryptoClient } from '../TezosSaplingCryptoClient';\nimport { TezosSaplingExternalMethodProvider } from '../TezosSaplingProtocolOptions';\nimport { TezosSaplingEncoder } from './TezosSaplingEncoder';\nimport { TezosSaplingState } from './TezosSaplingState';\nexport declare class TezosSaplingForger {\n    private readonly cryptoClient;\n    private readonly state;\n    private readonly encoder;\n    private readonly externalProvider?;\n    constructor(cryptoClient: TezosSaplingCryptoClient, state: TezosSaplingState, encoder: TezosSaplingEncoder, externalProvider?: TezosSaplingExternalMethodProvider | undefined);\n    forgeSaplingTransaction(inputs: TezosSaplingInput[], outputs: TezosSaplingOutput[], merkleTree: TezosSaplingStateTree, antiReplay: string, spendingKey?: Buffer): Promise<TezosSaplingTransaction>;\n    private forgeSaplingInputs;\n    private forgeSaplingOutputs;\n    private createTransactionSighash;\n    private createInputSighash;\n    private calculateTransactionBalance;\n    private withProvingContext;\n    private prepareSpendDescription;\n    private preparePartialOutputDescription;\n    private createBindingSignature;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/utils/TezosSaplingState.d.ts",dts:"import BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosSaplingStateDiff } from '../../types/sapling/TezosSaplingStateDiff';\nimport { TezosSaplingStateTree } from '../../types/sapling/TezosSaplingStateTree';\nexport declare class TezosSaplingState {\n    readonly treeHeight: number;\n    private readonly uncommitedMerkleHash;\n    private readonly uncommitedMerkleHashes;\n    private stateTree;\n    constructor(treeHeight: number);\n    getStateTreeFromStateDiff(saplingStateDiff: TezosSaplingStateDiff, skipConstruction?: boolean): Promise<TezosSaplingStateTree>;\n    getWitness(stateTree: TezosSaplingStateTree, position: BigNumber): Promise<string>;\n    private constructMerkleTree;\n    private verifyMerkleTree;\n    private getMerkleHash;\n    private createUncommitedMerkleHashes;\n    private getNeighboringHashes;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/TezosSaplingAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { TezosAddress } from '../TezosAddress';\nexport declare class TezosSaplingAddress extends TezosAddress {\n    readonly raw: Buffer;\n    readonly diversifierIndex?: string | undefined;\n    private constructor();\n    static fromViewingKey(viewingKey: string, index?: Buffer | string | number): Promise<TezosSaplingAddress>;\n    static fromRaw(raw: Buffer, diversifierIndex?: Buffer): Promise<TezosSaplingAddress>;\n    static fromValue(value: string, diversifierIndex?: string): Promise<TezosSaplingAddress>;\n    static next(viewingKey: string, current: TezosSaplingAddress): Promise<TezosSaplingAddress>;\n    static isZetAddress(address: string): boolean;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/TezosSaplingCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { SaplingPartialOutputDescription } from '@airgap/sapling-wasm';\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { Ed25519CryptoClient } from '../../Ed25519CryptoClient';\nimport { TezosCryptoClient } from '../TezosCryptoClient';\nimport { TezosSaplingCiphertext } from '../types/sapling/TezosSaplingCiphertext';\nimport { TezosSaplingOutput } from '../types/sapling/TezosSaplingOutput';\ninterface PayloadEnc {\n    diversifier: Buffer;\n    address: Buffer;\n    amount: BigNumber;\n    rcm: Buffer;\n    memo: Buffer;\n}\ninterface PayloadOut {\n    pkd: Buffer;\n    esk: Buffer;\n}\nexport declare class TezosSaplingCryptoClient extends Ed25519CryptoClient {\n    private readonly tezosCryptoClient;\n    private readonly ockKey;\n    private readonly kdfKey;\n    constructor(tezosCryptoClient: TezosCryptoClient);\n    signMessage(message: string, keypair: {\n        publicKey?: string | undefined;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptCiphertext(tezosOutput: TezosSaplingOutput, saplingDescription: SaplingPartialOutputDescription, rcm: Buffer, esk: Buffer, viewingKey?: Buffer): Promise<TezosSaplingCiphertext>;\n    decryptCiphertextEnc(viewingKey: Buffer | string, ciphertext: TezosSaplingCiphertext, mode?: 'sender' | 'receiver', commitment?: Buffer | string): Promise<PayloadEnc>;\n    decryptCiphertextOut(viewingKey: Buffer | string, ciphertext: TezosSaplingCiphertext, commitment: Buffer | string): Promise<PayloadOut>;\n    private getSymmetricKey;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/TezosSaplingProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { SignedTezosTransaction } from '../../../serializer/schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../../../serializer/schemas/definitions/unsigned-transaction-tezos';\nimport { UnsignedTezosSaplingTransaction } from '../../../serializer/schemas/definitions/unsigned-transaction-tezos-sapling';\nimport { RawTezosSaplingTransaction, RawTezosTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../../ICoinProtocol';\nimport { ICoinSubProtocol } from '../../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../../NonExtendedProtocol';\nimport { TezosContract } from '../contract/TezosContract';\nimport { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosSaplingTransactionCursor } from '../types/sapling/TezosSaplingTransactionCursor';\nimport { TezosSaplingTransactionResult } from '../types/sapling/TezosSaplingTransactionResult';\nimport { TezosSaplingWrappedTransaction } from '../types/sapling/TezosSaplingWrappedTransaction';\nimport { TezosSaplingNodeClient } from './node/TezosSaplingNodeClient';\nimport { TezosSaplingAddress } from './TezosSaplingAddress';\nimport { TezosSaplingCryptoClient } from './TezosSaplingCryptoClient';\nimport { TezosSaplingProtocolOptions } from './TezosSaplingProtocolOptions';\nimport { TezosSaplingBookkeeper } from './utils/TezosSaplingBookkeeper';\nimport { TezosSaplingEncoder } from './utils/TezosSaplingEncoder';\nimport { TezosSaplingForger } from './utils/TezosSaplingForger';\nimport { TezosSaplingState } from './utils/TezosSaplingState';\nexport declare abstract class TezosSaplingProtocol extends NonExtendedProtocol implements ICoinProtocol {\n    readonly options: TezosSaplingProtocolOptions;\n    private static readonly TRANSACTION_PLACEHOLDER;\n    readonly symbol: string;\n    readonly name: string;\n    readonly marketSymbol: string;\n    readonly feeSymbol: string;\n    readonly feeDefaults: FeeDefaults;\n    readonly decimals: number;\n    readonly feeDecimals: number;\n    readonly identifier: ProtocolSymbols;\n    readonly units: CurrencyUnit[];\n    readonly supportsHD: boolean;\n    readonly standardDerivationPath: string;\n    readonly addressIsCaseSensitive: boolean;\n    readonly addressValidationPattern: string;\n    readonly addressPlaceholder: string;\n    readonly cryptoClient: TezosSaplingCryptoClient;\n    readonly nodeClient: TezosSaplingNodeClient;\n    readonly contract: TezosContract;\n    readonly bookkeeper: TezosSaplingBookkeeper;\n    readonly encoder: TezosSaplingEncoder;\n    readonly forger: TezosSaplingForger;\n    readonly state: TezosSaplingState;\n    protected readonly tezosProtocol: TezosProtocol;\n    constructor(options: TezosSaplingProtocolOptions);\n    abstract prepareContractCalls(transactions: TezosSaplingWrappedTransaction[]): Promise<TezosContractCall[]>;\n    abstract parseParameters(parameters: TezosTransactionParameters): Promise<TezosSaplingWrappedTransaction[]>;\n    initParameters(spendParams: Buffer, outputParams: Buffer): Promise<void>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string | undefined): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string | undefined): Promise<Buffer>;\n    private getSeedFromMnemonic;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(viewingKey: string): Promise<TezosSaplingAddress>;\n    getAddressesFromPublicKey(viewingKey: string): Promise<TezosSaplingAddress[]>;\n    getAddressFromViewingKey(viewingKey: string, index: string): Promise<TezosSaplingAddress>;\n    getNextAddressFromPublicKey(viewingKey: string, current: TezosSaplingAddress): Promise<TezosSaplingAddress>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: TezosSaplingTransactionCursor): Promise<TezosSaplingTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawTezosSaplingTransaction): Promise<string>;\n    getTransactionDetails(transaction: UnsignedTezosTransaction | UnsignedTezosSaplingTransaction, data?: {\n        knownViewingKeys: string[];\n    }): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedTezosTransaction, data?: {\n        knownViewingKeys: string[];\n    }): Promise<IAirGapTransaction[]>;\n    private getTransactionDetailsFromWrappedOperation;\n    private getPartialDetailsFromContractParameters;\n    private filterOutPaybacks;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getTransactionStatuses(transactionHash: string[]): Promise<AirGapTransactionStatus[]>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string | undefined): Promise<string>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<RawTezosSaplingTransaction>;\n    wrapSaplingTransactions(publicKey: string, transactions: TezosSaplingWrappedTransaction[] | string, fee: string, overrideFees?: boolean): Promise<RawTezosTransaction>;\n    private prepareTezosOperation;\n    prepareShieldTransaction(publicKey: string, recipient: string, value: string, fee: string, data?: {\n        overrideFees?: boolean;\n    }): Promise<RawTezosTransaction>;\n    prepareUnshieldTransaction(viewingKey: string, recipient: string, value: string, data?: any): Promise<RawTezosSaplingTransaction>;\n    prepareSaplingTransaction(viewingKey: string, recipient: string, value: string, data?: any): Promise<RawTezosSaplingTransaction>;\n    private chooseInputs;\n    private preparePartialContractCall;\n    private createDummyInput;\n    private createDummyOutput;\n    private getDummyAddress;\n    private getAntiReplay;\n    broadcastTransaction(rawTransaction: any): Promise<string>;\n    signMessage(message: string, keypair: {\n        publicKey?: string | undefined;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey?: string | undefined;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(payload: string, privateKey: Buffer): Promise<string>;\n    decryptAES(encryptedPayload: string, privateKey: Buffer): Promise<string>;\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: TezosSaplingTransactionCursor): Promise<TezosSaplingTransactionResult>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    private isRawTezosSaplingTransaction;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/TezosSaplingProtocolOptions.d.ts",dts:"/// <reference types=\"node\" />\nimport { SaplingPartialOutputDescription, SaplingUnsignedSpendDescription } from '@airgap/sapling-wasm';\nimport { ProtocolOptions } from '../../../utils/ProtocolOptions';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { TezosProtocolConfig, TezosProtocolNetwork } from '../TezosProtocolOptions';\nimport { TezosSaplingTransaction } from '../types/sapling/TezosSaplingTransaction';\nexport interface TezosSaplingExternalMethodProvider {\n    initParameters?: (spendParams: Buffer, outputParams: Buffer) => Promise<void>;\n    withProvingContext?: (action: (context: number) => Promise<TezosSaplingTransaction>) => Promise<TezosSaplingTransaction>;\n    prepareSpendDescription?: (context: number, spendingKey: Buffer, address: Buffer, rcm: string, ar: Buffer, value: string, root: string, merklePath: string) => Promise<SaplingUnsignedSpendDescription>;\n    preparePartialOutputDescription?: (context: number, address: Buffer, rcm: Buffer, esk: Buffer, value: string) => Promise<SaplingPartialOutputDescription>;\n    createBindingSignature?: (context: number, balance: string, sighash: Buffer) => Promise<Buffer>;\n}\nexport declare class TezosSaplingProtocolConfig extends TezosProtocolConfig {\n    readonly name: string;\n    readonly identifier: ProtocolSymbols;\n    readonly contractAddress: string;\n    readonly memoSize: number;\n    readonly merkleTreeHeight: number;\n    readonly symbol?: string | undefined;\n    readonly marketSymbol?: string | undefined;\n    readonly feeDefaults?: FeeDefaults | undefined;\n    readonly decimals?: number | undefined;\n    readonly units?: CurrencyUnit[] | undefined;\n    readonly externalProvider?: TezosSaplingExternalMethodProvider | undefined;\n    constructor(name: string, identifier: ProtocolSymbols, contractAddress: string, memoSize: number, merkleTreeHeight?: number, symbol?: string | undefined, marketSymbol?: string | undefined, feeDefaults?: FeeDefaults | undefined, decimals?: number | undefined, units?: CurrencyUnit[] | undefined, externalProvider?: TezosSaplingExternalMethodProvider | undefined);\n}\nexport declare class TezosShieldedTezProtocolConfig extends TezosSaplingProtocolConfig {\n    readonly name: string;\n    readonly identifier: ProtocolSymbols;\n    readonly contractAddress: string;\n    readonly externalProvider?: TezosSaplingExternalMethodProvider | undefined;\n    readonly memoSize: number;\n    readonly merkleTreeHeight: number;\n    constructor(name?: string, identifier?: ProtocolSymbols, contractAddress?: string, externalProvider?: TezosSaplingExternalMethodProvider | undefined, memoSize?: number, merkleTreeHeight?: number);\n}\nexport declare class TezosSaplingProtocolOptions implements ProtocolOptions<TezosSaplingProtocolConfig> {\n    network: TezosProtocolNetwork;\n    config: TezosSaplingProtocolConfig;\n    constructor(network?: TezosProtocolNetwork, config?: TezosSaplingProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/sapling/TezosShieldedTezProtocol.d.ts",dts:"import { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosSaplingWrappedTransaction } from '../types/sapling/TezosSaplingWrappedTransaction';\nimport { TezosSaplingProtocol } from './TezosSaplingProtocol';\nimport { TezosSaplingProtocolOptions } from './TezosSaplingProtocolOptions';\nexport declare class TezosShieldedTezProtocol extends TezosSaplingProtocol {\n    constructor(options?: TezosSaplingProtocolOptions);\n    prepareContractCalls(transactions: TezosSaplingWrappedTransaction[]): Promise<TezosContractCall[]>;\n    parseParameters(parameters: TezosTransactionParameters): Promise<TezosSaplingWrappedTransaction[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/contract/BigMapPredicate.d.ts",dts:"import { ConseilPredicate } from './ConseilPredicate';\nexport interface BigMapPredicate extends ConseilPredicate {\n    field: 'account_id' | 'big_map_id' | 'key' | 'key_hash' | 'value' | 'value_type' | 'key_type';\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/contract/BigMapRequest.d.ts",dts:"import { BigMapPredicate } from './BigMapPredicate';\nexport interface BigMapRequest {\n    bigMapID?: number;\n    predicates?: BigMapPredicate[];\n    bigMapFilter?: BigMapPredicate[];\n    limit?: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/contract/BigMapResult.d.ts",dts:"export interface BigMapResponse {\n    big_map_id: number;\n    key: string;\n    key_hash: string;\n    value: string | null;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/contract/ConseilPredicate.d.ts",dts:"export interface ConseilPredicate {\n    field: string;\n    operation: 'in' | 'between' | 'like' | 'lt' | 'gt' | 'eq' | 'startsWith' | 'endsWith' | 'before' | 'after' | 'isnull';\n    set: any[];\n    inverse?: boolean;\n    group?: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/contract/TezosContractMetadata.d.ts",dts:"import { MichelineCodeNode, MichelineDataNode, MichelineTypeNode } from '../micheline/MichelineNode';\ninterface MetadataLicense {\n    name: string;\n    details?: string;\n}\ninterface MetadataSource {\n    tools?: string;\n    location?: string;\n}\ninterface MetadataErrorBase {\n    languages?: string[];\n}\ninterface MetadataErrorStatic extends MetadataErrorBase {\n    error: MichelineDataNode;\n    expansion: MichelineDataNode;\n}\ninterface MetadataErrorDynamic extends MetadataErrorBase {\n    view: string;\n}\ndeclare type MetadataError = MetadataErrorStatic | MetadataErrorDynamic;\ninterface MetadataAnnotation {\n    name: string;\n    description: string;\n}\ninterface MetadataMichelsonStorageView {\n    parameter?: MichelineTypeNode;\n    returnType: MichelineTypeNode;\n    code: MichelineCodeNode;\n    annotations?: MetadataAnnotation[];\n    version?: string;\n}\ninterface MetadataRestApiQuery {\n    specificationUri: string;\n    baseUri?: string;\n    path: string;\n    method?: string;\n}\ndeclare type MetadataViewImplementations = {\n    michelsonStorageView: MetadataMichelsonStorageView;\n} | {\n    restApiQuery: MetadataRestApiQuery;\n};\ninterface MetadataView {\n    name: string;\n    description?: string;\n    implementations: MetadataViewImplementations[];\n    pure?: boolean;\n}\nexport interface TezosContractMetadata {\n    name?: string;\n    description?: string;\n    version?: string;\n    license?: MetadataLicense;\n    authors?: string[];\n    homepage?: string;\n    source?: MetadataSource;\n    interfaces?: string[];\n    errors?: MetadataError[];\n    views?: MetadataView[];\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/domains/TezosDomainsRecord.d.ts",dts:"export interface TezosDomainsRecord {\n    address?: string;\n    expiryKey?: string;\n    expiryTimestamp?: number;\n    level: number;\n    owner: string;\n    tokenId?: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/domains/TezosDomainsReverseRecord.d.ts",dts:"export interface TezosDomainsReverseRecord {\n    name?: string;\n    owner: string;\n    expiryTimestamp?: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2BalanceOfRequest.d.ts",dts:"export interface TezosFA2BalanceOfRequest {\n    address: string;\n    tokenID: number | string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2BalanceOfResponse.d.ts",dts:"export interface TezosFA2BalanceOfResponse {\n    address: string;\n    tokenID: number;\n    amount: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2TransferRequest.d.ts",dts:"export interface TezosFA2TransferRequest {\n    from: string;\n    txs: {\n        to: string;\n        tokenID: number;\n        amount: string;\n    }[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2UpdateOperatorRequest.d.ts",dts:"export interface TezosFA2UpdateOperatorRequest {\n    operation: 'add' | 'remove';\n    owner: string;\n    operator: string;\n    tokenId: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFATokenMetadata.d.ts",dts:"export interface TezosFATokenMetadata {\n    symbol: string;\n    name: string;\n    decimals: number;\n    [key: string]: string | number | boolean;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/micheline/MichelineNode.d.ts",dts:"import { MichelsonGrammarData } from '../michelson/grammar/MichelsonGrammarData';\nimport { MichelsonGrammarInstruction } from '../michelson/grammar/MichelsonGrammarInstruction';\nimport { MichelsonGrammarType } from '../michelson/grammar/MichelsonGrammarType';\nexport declare type MichelineGenericNode<T extends MichelsonGrammarType | MichelsonGrammarData> = MichelinePrimitive<'int'> | MichelinePrimitive<'string'> | MichelinePrimitive<'bytes'> | MichelinePrimitiveApplication<T> | MichelineGenericNode<T>[];\nexport declare type MichelineNode = MichelineGenericNode<MichelsonGrammarType | MichelsonGrammarData>;\nexport declare type MichelineTypeNode = MichelineGenericNode<MichelsonGrammarType>;\nexport declare type MichelineDataNode = MichelineGenericNode<MichelsonGrammarData>;\nexport declare type MichelineCodeNode = MichelineGenericNode<MichelsonGrammarInstruction>;\nexport declare type MichelinePrimitiveType = 'int' | 'string' | 'bytes';\nexport declare type MichelinePrimitive<T extends MichelinePrimitiveType> = Record<T, string>;\nexport interface MichelinePrimitiveApplication<T extends MichelsonGrammarType | MichelsonGrammarData> {\n    prim: T;\n    args?: MichelineGenericNode<T>[];\n    annots?: string[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/micheline/MichelineNodeUtils.d.ts",dts:"import { MichelsonGrammarData } from '../michelson/grammar/MichelsonGrammarData';\nimport { MichelsonGrammarType } from '../michelson/grammar/MichelsonGrammarType';\nimport { MichelineGenericNode } from './MichelineNode';\nexport declare class MichelineNodeUtils {\n    static normalize<T extends MichelsonGrammarData | MichelsonGrammarType>(node: MichelineGenericNode<T>): MichelineGenericNode<T>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonList.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonList extends MichelsonType {\n    readonly elements: Lazy<MichelsonType[]>;\n    constructor(elements: Lazy<MichelsonType[]>, name?: string);\n    static from(value: unknown, mappingFunction?: unknown, name?: string): MichelsonList;\n    asRawValue(): Record<string, Record<string, any>[]> | Record<string, any>[];\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonMap.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelineNode } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonMap extends MichelsonType {\n    readonly entries: [Lazy<MichelsonType>, Lazy<MichelsonType>][];\n    constructor(entries: [Lazy<MichelsonType>, Lazy<MichelsonType>][], name?: string);\n    static from(value: unknown, keyMappingFunction?: unknown, valueMappingFunction?: unknown, name?: string): MichelsonMap;\n    static fromMicheline(micheline: MichelineNode, keyMappingFunction: unknown, valueMappingFunction: unknown, name?: string): MichelsonMap;\n    static fromUnknown(unknownValue: unknown, keyMappingFunction: unknown, valueMappingFunction: unknown, name?: string): MichelsonMap;\n    private static createMapEntry;\n    asRawValue(): Record<string, Map<unknown, unknown>> | Map<unknown, unknown>;\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonOption.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare type MichelsonOptionType = 'Some' | 'None';\nexport declare abstract class MichelsonOption extends MichelsonType {\n    protected abstract type: MichelsonOptionType;\n    static from(value: unknown, mappingFunction?: unknown, name?: string): MichelsonOption;\n    static fromMichelson(michelson: string, mappingFunction: unknown, name?: string): MichelsonOption;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, mappingFunction: unknown, name?: string): MichelsonOption;\n    static fromUnknown(unknownValue: unknown, mappingFunction: unknown, name?: string): MichelsonOption;\n}\nexport declare class MichelsonSome extends MichelsonOption {\n    readonly value: Lazy<MichelsonType>;\n    protected type: MichelsonOptionType;\n    constructor(value: Lazy<MichelsonType>, name?: string);\n    asRawValue(): any;\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\nexport declare class MichelsonNone extends MichelsonOption {\n    protected type: MichelsonOptionType;\n    asRawValue(): Record<string, undefined> | undefined;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonOr.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare type MichelsonOrType = 'Left' | 'Right';\nexport declare abstract class MichelsonOr extends MichelsonType {\n    readonly value: Lazy<MichelsonType>;\n    protected abstract type: MichelsonOrType;\n    constructor(value: Lazy<MichelsonType>, name?: string);\n    static from(or: unknown, firstMappingFunction?: unknown, secondMappingFunction?: unknown, name?: string): MichelsonOr;\n    static fromMichelson(michelson: string, firstMappingFunction: unknown, secondMappingFunction: unknown, name?: string): MichelsonOr;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, firstMappingFunction: unknown, secondMappingFunction: unknown, name?: string): MichelsonOr;\n    static fromUnknown(unknownValue: unknown, firstMappingFunction: unknown, secondMappingFunction: unknown, name?: string): MichelsonOr;\n    static isOr(unknownValue: unknown): unknownValue is MichelsonOr;\n    private static create;\n    asRawValue(): Record<string, any> | any;\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\nexport declare class MichelsonLeft extends MichelsonOr {\n    protected readonly type = \"Left\";\n}\nexport declare class MichelsonRight extends MichelsonOr {\n    protected readonly type = \"Right\";\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonPair.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonPair extends MichelsonType {\n    readonly items: Lazy<MichelsonType>[];\n    constructor(items: Lazy<MichelsonType>[], name?: string);\n    static from(pair: unknown, name?: string, ...mappingFunctions: unknown[]): MichelsonPair;\n    static fromMichelson(michelson: string, mappingFunctions: unknown[], name?: string): MichelsonPair;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, mappingFunctions: unknown[], name?: string): MichelsonPair;\n    static fromUnknown(unknownValue: MichelsonType | unknown, mappingFunctions: unknown[], name?: string): MichelsonPair;\n    private static asRawValue;\n    asRawValue(): Record<string, any> | [any, any];\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n    private normalized;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarData.d.ts",dts:"import { MichelsonGrammarInstruction } from './MichelsonGrammarInstruction';\nexport declare type MichelsonGrammarData = 'Unit' | 'True' | 'False' | 'Pair' | 'Left' | 'Right' | 'Some' | 'None' | 'Elt' | MichelsonGrammarInstruction;\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarInstruction.d.ts",dts:"export declare type MichelsonGrammarInstruction = 'ADD' | 'IF_NONE' | 'SWAP' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'CREATE_CONTRACT' | 'NEG' | 'BLAKE2B' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'PAIR' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'COMPARE' | 'UNPACK' | 'NEQ' | 'INT' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'MEM' | 'MAP' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'CAST' | 'SIZE' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'RENAME' | 'FAILWITH' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'AND';\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarType.d.ts",dts:"export declare type MichelsonGrammarType = 'nat' | 'int' | 'string' | 'bytes' | 'mutez' | 'bool' | 'key_hash' | 'timestamp' | 'address' | 'key' | 'unit' | 'signature' | 'option' | 'list' | 'set' | 'operation' | 'contract' | 'pair' | 'or' | 'lambda' | 'map' | 'big_map' | 'chain_id' | 'sapling_transaction';\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonAddress.d.ts",dts:"import { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nimport { MichelsonBytes } from './MichelsonBytes';\nimport { MichelsonString } from './MichelsonString';\nexport declare class MichelsonAddress extends MichelsonType {\n    readonly address: MichelsonString | MichelsonBytes;\n    constructor(address: MichelsonString | MichelsonBytes, name?: string);\n    static from(value: unknown, name?: string): MichelsonAddress;\n    static fromMicheline(micheline: MichelinePrimitive<'string'> | MichelinePrimitive<'bytes'>, name?: string): MichelsonAddress;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonAddress;\n    encode(): string;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonBool.d.ts",dts:"import { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonBool extends MichelsonType {\n    readonly value: boolean;\n    constructor(value: boolean, name?: string);\n    static from(value: unknown, name?: string): MichelsonBool;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, name?: string): MichelsonBool;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonBool;\n    asRawValue(): Record<string, boolean> | boolean;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonBytes.d.ts",dts:"/// <reference types=\"node\" />\nimport { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonBytes extends MichelsonType {\n    readonly value: Buffer;\n    constructor(value: Buffer | string, name?: string);\n    static from(value: unknown, name?: string): MichelsonBytes;\n    static fromMicheline(micheline: MichelinePrimitive<'bytes'>, name?: string): MichelsonBytes;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonBytes;\n    encode(): string;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonInt.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonInt extends MichelsonType {\n    readonly value: BigNumber;\n    constructor(value: number | string | BigNumber, name?: string);\n    static from(value: unknown, name?: string): MichelsonInt;\n    static fromMicheline(micheline: MichelinePrimitive<'int'>, name?: string): MichelsonInt;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonInt;\n    encode(): string;\n    asRawValue(): Record<string, BigNumber> | BigNumber;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonString.d.ts",dts:"import { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonString extends MichelsonType {\n    readonly value: string;\n    constructor(value: string, name?: string);\n    static from(value: unknown, name?: string): MichelsonString;\n    static fromMicheline(micheline: MichelinePrimitive<'string'>, name?: string): MichelsonString;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonString;\n    encode(): string;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonUnit.d.ts",dts:"import { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonUnit extends MichelsonType {\n    static from(value: unknown, name?: string): MichelsonUnit;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, name?: string): MichelsonUnit;\n    asRawValue(): any;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/MichelsonType.d.ts",dts:"import { MichelineDataNode } from '../micheline/MichelineNode';\nexport declare abstract class MichelsonType {\n    name?: string | undefined;\n    constructor(name?: string | undefined);\n    abstract asRawValue(): any;\n    abstract toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n    encode(): string;\n    setName(name: string): void;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/MichelsonTypeMeta.d.ts",dts:"import { Lazy } from '../../../../data/Lazy';\nimport { MichelinePrimitiveApplication, MichelineTypeNode } from '../../types/micheline/MichelineNode';\nimport { MichelsonGrammarType } from '../../types/michelson/grammar/MichelsonGrammarType';\nimport { MichelsonType } from './MichelsonType';\nexport declare enum MichelsonAnnotationPrefix {\n    TYPE = \":\",\n    VARIABLE = \"@\",\n    FIELD = \"%\"\n}\nexport interface MichelsonTypeMetaCreateValueConfiguration {\n    lazyEval?: boolean;\n    readAnnots?: boolean;\n    beforeNext?(meta: MichelsonTypeMeta, raw: unknown): void;\n    onNext?(meta: MichelsonTypeMeta, raw: unknown, value: MichelsonType): void;\n}\nexport declare class MichelsonTypeMeta {\n    readonly type: MichelsonGrammarType;\n    readonly parent?: MichelsonGenericTypeMeta | undefined;\n    readonly annots: string[];\n    constructor(type: MichelsonGrammarType, parent?: MichelsonGenericTypeMeta | undefined, annots?: string[]);\n    static fromMichelineNode(node: MichelineTypeNode): MichelsonTypeMeta | undefined;\n    static fromMichelinePrimitiveApplication(primitiveApplication: MichelinePrimitiveApplication<any>, parent?: MichelsonGenericTypeMeta): MichelsonTypeMeta;\n    static from(type: MichelsonGrammarType, annots: string[], args: MichelinePrimitiveApplication<any>[], parent?: MichelsonGenericTypeMeta): MichelsonTypeMeta;\n    createValue(value: unknown, configuration?: MichelsonTypeMetaCreateValueConfiguration): MichelsonType;\n    getAnnotation(...prefixes: MichelsonAnnotationPrefix[]): string | undefined;\n    protected getMichelsonValue(raw: unknown, _configuration?: MichelsonTypeMetaCreateValueConfiguration): MichelsonType;\n    protected getRawValue(value: unknown): unknown;\n}\nexport declare class MichelsonGenericTypeMeta extends MichelsonTypeMeta {\n    readonly generics: Lazy<MichelsonTypeMeta>[];\n    constructor(type: MichelsonGrammarType, genericTypes: MichelinePrimitiveApplication<any>[], parent?: MichelsonGenericTypeMeta, annots?: string[]);\n    protected getMichelsonValue(raw: unknown, configuration?: MichelsonTypeMetaCreateValueConfiguration): MichelsonType;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/MichelsonTypeUtils.d.ts",dts:"/// <reference types=\"node\" />\nimport { MichelsonGrammarType } from './grammar/MichelsonGrammarType';\nimport { MichelsonType } from './MichelsonType';\nexport declare class MichelsonTypeUtils {\n    static readonly literalPrefixes: {\n        int: Buffer;\n        string: Buffer;\n        bytes: Buffer;\n    };\n    static readonly primPrefixes: {\n        pair: Buffer;\n    };\n    static readonly sequencePrefixes: {\n        list: Buffer;\n    };\n    private static readonly michelsonTypeFactories;\n    static create(type: MichelsonGrammarType, ...args: unknown[]): MichelsonType;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/ActivateAccount.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosActivateAccountOperation extends TezosOperation {\n    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n    pkh: string;\n    secret: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Ballot.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosBallotOperation extends TezosOperation {\n    kind: TezosOperationType.BALLOT;\n    source: string;\n    period: string;\n    proposal: string;\n    ballot: 'nay' | 'yay' | 'pass';\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Delegation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosDelegationOperation extends TezosOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/DoubleBakingEvidence.d.ts",dts:"import { TezosBlockHeader } from '../TezosBlockHeader';\nimport { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosDoubleBakingEvidenceOperation extends TezosOperation {\n    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n    bh1: TezosBlockHeader;\n    bh2: TezosBlockHeader;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/DoubleEndorsementEvidence.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents {\n    kind: 'endorsement';\n    level: string;\n}\nexport interface TezosDoubleEndorsementEvidenceOperation extends TezosOperation {\n    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Endorsement.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosEndorsementOperation extends TezosOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Origination.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosOriginationOperation extends TezosOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Proposal.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosProposalOperation extends TezosOperation {\n    kind: TezosOperationType.PROPOSALS;\n    period: string;\n    proposals: string[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Reveal.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosRevealOperation extends TezosOperation {\n    kind: TezosOperationType.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/SeedNonceRevelation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosSeedNonceRevelationOperation extends TezosOperation {\n    kind: TezosOperationType.SEED_NONCE_REVELATION;\n    level: string;\n    nonce: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/TezosOperation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nexport interface TezosOperation {\n    kind: TezosOperationType;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Transaction.d.ts",dts:"import { MichelineNode } from '../micheline/MichelineNode';\nimport { TezosOperationType } from '../TezosOperationType';\nimport { TezosWrappedOperation } from '../TezosWrappedOperation';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosTransactionParameters {\n    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n    value: MichelineNode;\n}\nexport interface TezosWrappedTransactionOperation extends TezosWrappedOperation {\n    contents: TezosTransactionOperation[];\n    signature: string;\n}\nexport interface TezosTransactionOperation extends TezosOperation {\n    kind: TezosOperationType.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TezosTransactionParameters;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingCiphertext.d.ts",dts:"export interface TezosSaplingCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingInput.d.ts",dts:"export interface TezosSaplingInput {\n    rcm: string;\n    pos: string;\n    value: string;\n    address: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingOutput.d.ts",dts:"export interface TezosSaplingOutput {\n    address: string;\n    value: string;\n    memo: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingStateDiff.d.ts",dts:"import { TezosSaplingCiphertext } from './TezosSaplingCiphertext';\nexport interface TezosSaplingStateDiff {\n    root: string;\n    commitments_and_ciphertexts: [string, TezosSaplingCiphertext][];\n    nullifiers: string[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingStateTree.d.ts",dts:"export interface TezosSaplingStateTree {\n    height: number;\n    size: number;\n    root: string;\n    tree: MerkleTree;\n}\nexport declare type MerkleTree = undefined | string | [string, MerkleTree, MerkleTree];\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingTransaction.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosSaplingCiphertext } from './TezosSaplingCiphertext';\nexport interface TezosSaplingSpendDescription {\n    cv: Buffer;\n    nf: Buffer;\n    rk: Buffer;\n    proof: Buffer;\n    signature: Buffer;\n}\nexport interface TezosSaplingOutputDescription {\n    cm: Buffer;\n    proof: Buffer;\n    ciphertext: TezosSaplingCiphertext;\n}\nexport interface TezosSaplingTransaction {\n    spendDescriptions: TezosSaplingSpendDescription[];\n    outputDescriptions: TezosSaplingOutputDescription[];\n    bindingSignature: Buffer;\n    balance: BigNumber;\n    root: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingTransactionCursor.d.ts",dts:"export interface TezosSaplingTransactionCursor {\n    page: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingTransactionResult.d.ts",dts:"import { IAirGapTransaction } from '../../../../interfaces/IAirGapTransaction';\nimport { TezosSaplingTransactionCursor } from './TezosSaplingTransactionCursor';\nexport interface TezosSaplingTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: TezosSaplingTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/sapling/TezosSaplingWrappedTransaction.d.ts",dts:"import { TezosAddress } from '../../TezosAddress';\nexport interface TezosSaplingWrappedTransaction {\n    signed: string;\n    unshieldTarget?: TezosAddress;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosBlockHeader.d.ts",dts:"export interface TezosBlockHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosBlockMetadata.d.ts",dts:"import { TezosBlockHeader } from './TezosBlockHeader';\nexport interface TezosBlockMetadata {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    metadata: TezosBlockHeader;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosContractCode.d.ts",dts:"import { MichelinePrimitiveApplication, MichelineTypeNode } from './micheline/MichelineNode';\nexport interface TezosContractCode extends MichelinePrimitiveApplication<any> {\n    prim: 'parameter' | 'storage';\n    args: MichelineTypeNode[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosOperationType.d.ts",dts:'export declare enum TezosOperationType {\n    ENDORSEMENT = "endorsement",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    ACTIVATE_ACCOUNT = "activate_account",\n    PROPOSALS = "proposals",\n    BALLOT = "ballot",\n    REVEAL = "reveal",\n    TRANSACTION = "transaction",\n    ORIGINATION = "origination",\n    DELEGATION = "delegation"\n}\n'},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosTransactionCursor.d.ts",dts:"export interface TezosTransactionCursor {\n    lastBlockLevel: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosTransactionResult.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { TezosTransactionCursor } from './TezosTransactionCursor';\nexport interface TezosTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: TezosTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosWrappedOperation.d.ts",dts:"import { TezosOperation } from './operations/TezosOperation';\nexport interface TezosWrappedOperation {\n    branch: string;\n    contents: TezosOperation[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/utils.d.ts",dts:"import { MichelineNode, MichelinePrimitive, MichelinePrimitiveApplication } from './micheline/MichelineNode';\nexport declare function isMichelineNode(node: unknown): node is MichelineNode;\nexport declare function isMichelinePrimitive<T extends 'int' | 'string' | 'bytes'>(type: T, node: unknown): node is MichelinePrimitive<T>;\nexport declare function isMichelinePrimitiveApplication(node: unknown): node is MichelinePrimitiveApplication<any>;\nexport declare function isMichelineSequence(node: unknown, recursive?: boolean): node is MichelineNode[];\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { CoinAddress } from '../ICoinProtocol';\nexport declare class TezosAddress implements CoinAddress {\n    private readonly value;\n    protected constructor(value: string);\n    static fromPublicKey(publicKey: string): Promise<TezosAddress>;\n    static fromValue(value: string): Promise<TezosAddress>;\n    static fromRawTz(rawTz: string | Buffer): Promise<TezosAddress>;\n    static isTzAddress(address: string): boolean;\n    getValue(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Ed25519CryptoClient } from '../Ed25519CryptoClient';\nimport { RawTezosTransaction } from '../../serializer/types';\nexport declare class TezosCryptoClient extends Ed25519CryptoClient {\n    readonly edsigPrefix: Uint8Array;\n    constructor(edsigPrefix?: Uint8Array);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    operationSignature(privateKey: Buffer, transaction: RawTezosTransaction): Promise<Buffer>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    toBuffer(message: string): Promise<Buffer>;\n    hash(message: Buffer, size?: number): Promise<Buffer>;\n    blake2bLedgerHash(message: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedTezosTransaction } from '../../serializer/schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-tezos';\nimport { RawTezosTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { TezosAddress } from './TezosAddress';\nimport { TezosCryptoClient } from './TezosCryptoClient';\nimport { TezosProtocolOptions } from './TezosProtocolOptions';\nimport { TezosRevealOperation } from './types/operations/Reveal';\nimport { TezosOperation } from './types/operations/TezosOperation';\nimport { TezosTransactionOperation } from './types/operations/Transaction';\nimport { TezosTransactionCursor } from './types/TezosTransactionCursor';\nimport { TezosTransactionResult } from './types/TezosTransactionResult';\nimport { TezosWrappedOperation } from './types/TezosWrappedOperation';\nexport interface TezosVotingInfo {\n    pkh: string;\n    rolls: number;\n}\nexport interface BakerInfo {\n    balance: BigNumber;\n    delegatedBalance: BigNumber;\n    stakingBalance: BigNumber;\n    selfBond: BigNumber;\n    bakerCapacity: BigNumber;\n    bakerUsage: BigNumber;\n}\nexport interface DelegationRewardInfo {\n    cycle: number;\n    reward: BigNumber;\n    deposit: BigNumber;\n    delegatedBalance: BigNumber;\n    stakingBalance: BigNumber;\n    totalRewards: BigNumber;\n    totalFees: BigNumber;\n    payout: Date;\n}\nexport interface DelegationInfo {\n    isDelegated: boolean;\n    value?: string;\n    delegatedOpLevel?: number;\n    delegatedDate?: Date;\n}\nexport declare enum TezosDelegatorAction {\n    DELEGATE = \"delegate\",\n    UNDELEGATE = \"undelegate\",\n    CHANGE_BAKER = \"change_baker\"\n}\nexport interface TezosPayoutInfo {\n    delegator: string;\n    share: string;\n    payout: string;\n    balance: string;\n}\nexport interface RunOperationBalanceUpdate {\n    kind: string;\n    contract: string;\n    change: string;\n    category: string;\n    delegate: string;\n    cycle?: number;\n}\nexport interface RunOperationOperationBalanceUpdate {\n    kind: string;\n    contract: string;\n    change: string;\n}\nexport interface RunOperationOperationResult {\n    status: string;\n    errors?: unknown;\n    balance_updates: RunOperationOperationBalanceUpdate[];\n    consumed_gas: string;\n    paid_storage_size_diff?: string;\n    originated_contracts?: string[];\n    allocated_destination_contract?: boolean;\n}\ninterface RunOperationInternalOperationResult {\n    result?: {\n        errors?: unknown;\n        consumed_gas: string;\n        paid_storage_size_diff?: string;\n        originated_contracts?: string[];\n        allocated_destination_contract?: boolean;\n    };\n    parameters?: {\n        entrypoint: string;\n        value: unknown;\n    };\n}\nexport interface RunOperationMetadata {\n    balance_updates: RunOperationBalanceUpdate[];\n    operation_result: RunOperationOperationResult;\n    internal_operation_results?: RunOperationInternalOperationResult[];\n}\nexport declare enum TezosNetwork {\n    MAINNET = \"mainnet\",\n    EDONET = \"edonet\",\n    FLORENCENET = \"florencenet\",\n    GRANADANET = \"granadanet\",\n    HANGZHOUNET = \"hangzhounet\"\n}\nexport declare class TezosProtocol extends NonExtendedProtocol implements ICoinDelegateProtocol {\n    readonly options: TezosProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    get subProtocols(): ICoinSubProtocol[];\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    minCycleDuration: number;\n    protected readonly transactionFee: BigNumber;\n    protected readonly originationSize: BigNumber;\n    protected readonly storageCostPerByte: BigNumber;\n    protected readonly revealFee: BigNumber;\n    protected readonly activationBurn: BigNumber;\n    protected readonly originationBurn: BigNumber;\n    readonly cryptoClient: TezosCryptoClient;\n    get jsonRPCAPI(): string;\n    get baseApiUrl(): string;\n    get baseApiNetwork(): string;\n    readonly headers: {\n        'Content-Type': string;\n        apiKey: string;\n    };\n    constructor(options?: TezosProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    /**\n     * Returns the PublicKey as String, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    /**\n     * Returns the PrivateKey as Buffer, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<TezosAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<TezosAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: TezosAddress): Promise<TezosAddress>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawTezosTransaction): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(unsignedTx: UnsignedTezosTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedTezosTransaction): Promise<IAirGapTransaction[]>;\n    getAirGapTxFromWrappedOperations(wrappedOperations: TezosWrappedOperation): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[], _data?: any): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string, data?: any): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[], data?: any): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    private estimateMaxTansactionValueWithBalance;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], _data?: any): Promise<FeeDefaults>;\n    estimateFeeDefaultsForOperations(publicKey: string, operations: TezosOperation[]): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    prepareTransactionsFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }, operationsPerGroup?: number): Promise<RawTezosTransaction[]>;\n    protected getTransactionOperationDetails(transactionOperation: TezosTransactionOperation): Promise<Partial<IAirGapTransaction>[]>;\n    private createTransactionOperations;\n    forgeAndWrapOperations(tezosWrappedOperation: TezosWrappedOperation): Promise<RawTezosTransaction>;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    private getDelegatorDetails;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: TezosDelegatorAction, data?: any): Promise<RawTezosTransaction[]>;\n    prepareOperations(publicKey: string, operationRequests: TezosOperation[], overrideParameters?: boolean): Promise<TezosWrappedOperation>;\n    estimateAndReplaceLimitsAndFee(tezosWrappedOperation: TezosWrappedOperation, overrideParameters?: boolean, startingCounter?: BigNumber): Promise<TezosWrappedOperation>;\n    getDelegationInfo(delegatedAddress: string, fetchExtraInfo?: boolean): Promise<DelegationInfo>;\n    bakerInfo(tzAddress: string | undefined): Promise<BakerInfo>;\n    getDelegationRewardsForAddress(address: string): Promise<DelegationRewardInfo[]>;\n    getDelegationRewards(bakerAddress: string, delegatorAddress?: string): Promise<DelegationRewardInfo[]>;\n    undelegate(publicKey: string): Promise<RawTezosTransaction>;\n    delegate(publicKey: string, delegate?: string | string[]): Promise<RawTezosTransaction>;\n    private getAmountUsedByPreviousOperations;\n    broadcastTransaction(rawTransaction: IAirGapSignedTransaction): Promise<string>;\n    protected checkAndRemovePrefixToHex(base58CheckEncodedPayload: string, tezosPrefix: Uint8Array): string;\n    unforgeSignedTezosWrappedOperation(hexString: string): Promise<TezosWrappedOperation>;\n    unforgeUnsignedTezosWrappedOperation(hexString: string): Promise<TezosWrappedOperation>;\n    forgeTezosOperation(tezosWrappedOperation: TezosWrappedOperation): Promise<string>;\n    createRevealOperation(counter: BigNumber, publicKey: string, address: string, fee?: string): Promise<TezosRevealOperation>;\n    getTezosVotingInfo(blockHash: string): Promise<TezosVotingInfo[]>;\n    fetchCurrentCycle(): Promise<number>;\n    private static readonly FIRST_005_CYCLE;\n    private static readonly FIRST_006_CYCLE;\n    private static readonly FIRST_010_CYCLE;\n    private static readonly BLOCKS_PER_CYCLE;\n    private static readonly TIME_BETWEEN_BLOCKS;\n    timeIntervalBetweenCycles(fromCycle: number, toCycle: number): number;\n    cycleToBlockLevel(cycle: number): number;\n    blockLevelToCycle(blockLevel: number): number;\n    private readonly rewardCalculations;\n    calculateRewards(bakerAddress: string, cycle: number, currentCycle?: number, breakDownRewards?: boolean): Promise<TezosRewards>;\n    calculatePayouts(rewards: TezosRewards, offsetOrAddresses: number | string[], limit?: number): Promise<TezosPayoutInfo[]>;\n    calculatePayout(address: string, rewards: TezosRewards): Promise<TezosPayoutInfo>;\n    private calculatePayoutForAddresses;\n    private fetchBlockMetadata;\n    private fetchBalances;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\nexport interface TezosBakingRight {\n    level: number;\n    delegate: string;\n    priority: number;\n}\nexport interface TezosBakingRewards {\n    totalBakingRewards: string;\n    rewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n        fees?: string;\n    }[];\n}\nexport interface TezosEndorsingRewards {\n    totalEndorsingRewards: string;\n    rewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n    }[];\n}\nexport interface TezosEndorsingRight {\n    level: number;\n    block_level?: number;\n    delegate: string;\n    number_of_slots: number;\n}\nexport interface TezosRewardsCalculations {\n    protocol: TezosProtocol;\n    calculateRewards(bakerAddress: string, cycle: number, breakDownRewards: boolean, currentCycleIn?: number): Promise<TezosRewards>;\n}\nexport interface TezosRewards {\n    baker: string;\n    stakingBalance: string;\n    bakingRewards: string;\n    bakingDeposits: string;\n    endorsingDeposits: string;\n    endorsingRewards: string;\n    fees: string;\n    deposit: string;\n    totalRewards: string;\n    cycle: number;\n    snapshotBlockLevel: number;\n    delegatedContracts: string[];\n    bakingRewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n        fees?: string;\n    }[];\n    endorsingRewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n    }[];\n    endorsingRightsCount: number;\n}\nexport interface TezosBakerInfo {\n    balance: string;\n    frozen_balance: string;\n    frozen_balance_by_cycle: TezosFrozenBalance[];\n    staking_balance: string;\n    delegated_contracts: string[];\n    delegated_balance: string;\n    deactivated: boolean;\n    grace_period: number;\n}\nexport interface TezosFrozenBalance {\n    cycle: number;\n    deposit?: string;\n    deposits: string;\n    fees: string;\n    rewards: string;\n}\nexport interface TezosNodeConstants {\n    proof_of_work_nonce_size: number;\n    nonce_length: number;\n    max_revelations_per_block: number;\n    max_operation_data_length: number;\n    max_proposals_per_delegate: number;\n    preserved_cycles: number;\n    blocks_per_cycle: number;\n    blocks_per_commitment: number;\n    blocks_per_roll_snapshot: number;\n    blocks_per_voting_period: number;\n    time_between_blocks: number[];\n    endorsers_per_block: number;\n    hard_gas_limit_per_operation: string;\n    hard_gas_limit_per_block: string;\n    proof_of_work_threshold: number;\n    tokens_per_roll: string;\n    michelson_maximum_type_size: number;\n    seed_nonce_revelation_tip: string;\n    origination_size: number;\n    block_security_deposit: string;\n    endorsement_security_deposit: string;\n    cost_per_byte: string;\n    hard_storage_limit_per_operation: string;\n    test_chain_duration: string;\n    quorum_min: number;\n    quorum_max: number;\n    min_proposal_quorum: number;\n    initial_endorsers: number;\n    delay_per_missing_endorsement: string;\n}\nexport interface TezosNodeConstantsV1 extends TezosNodeConstants {\n    block_reward: string;\n    endorsement_reward: string;\n}\nexport interface TezosNodeConstantsV2 extends TezosNodeConstants {\n    baking_reward_per_endorsement: string[];\n    endorsement_reward: string[];\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { TezosDomains } from './domains/TezosDomains';\nimport { TezosNetwork } from './TezosProtocol';\nexport declare type TezosProtocolNetworkResolver = (network: string) => TezosProtocolNetwork;\nexport declare class TezosProtocolNetworkExtras {\n    readonly network: TezosNetwork;\n    readonly conseilUrl: string;\n    readonly conseilNetwork: TezosNetwork;\n    readonly conseilApiKey: string;\n    constructor(network?: TezosNetwork, conseilUrl?: string, conseilNetwork?: TezosNetwork, conseilApiKey?: string);\n}\nexport declare class TezblockBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class TezosProtocolNetwork extends ProtocolNetwork<TezosProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: TezosProtocolNetworkExtras);\n}\nexport declare class TezosProtocolConfig {\n    readonly domains?: TezosDomains | undefined;\n    constructor(domains?: TezosDomains | undefined);\n}\nexport declare class TezosProtocolOptions implements ProtocolOptions<TezosProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosProtocolConfig;\n    constructor(network?: TezosProtocolNetwork, config?: TezosProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosUtils.d.ts",dts:"/// <reference types=\"node\" />\nimport { MichelsonType } from './types/michelson/MichelsonType';\nexport declare class TezosUtils {\n    static readonly tezosPrefixes: {\n        tz1: Buffer;\n        tz2: Buffer;\n        tz3: Buffer;\n        kt: Buffer;\n        edpk: Buffer;\n        edsk: Buffer;\n        edsig: Buffer;\n        branch: Buffer;\n        sask: Buffer;\n        zet1: Buffer;\n        expr: Buffer;\n    };\n    static readonly watermark: {\n        block: string;\n        endorsement: string;\n        operation: string;\n        message: string;\n    };\n    static parseAddress(bytes: string | Buffer): string;\n    static encodeAddress(address: string): Buffer;\n    static packMichelsonType(type: MichelsonType): string;\n    static parseHex(rawHex: string | string[]): MichelsonType;\n    static encodeExpr(value: MichelsonType): Promise<string>;\n    private static decodeSignedInt;\n    private static hexStringToArray;\n    private static parsePair;\n    private static parseList;\n    private static hexToString;\n    private static hexToLength;\n    private static splitAndReturnRest;\n    static parseTzAddress(bytes: string | Buffer): string;\n    private static encodeTzAddress;\n    private static prefixAndBase58CheckEncode;\n    private static prefixAndBase58CheckDecode;\n}\n"},{name:"@airgap/coinlib-core/protocols/BlockExplorerProtocol.d.ts",dts:"import { ProtocolOptions } from '../utils/ProtocolOptions';\nexport declare abstract class BlockExplorerProtocol {\n    abstract options: ProtocolOptions;\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/CryptoClient.d.ts",dts:'/// <reference types="node" />\nexport declare abstract class CryptoClient {\n    abstract signMessage(message: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    abstract verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAES(payload: string, privateKey: Buffer): Promise<string>;\n    decryptAES(encryptedPayload: string, privateKey: Buffer): Promise<string>;\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    recoverPublicKeyFromSignature(): Promise<void>;\n}\n'},{name:"@airgap/coinlib-core/protocols/Ed25519CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Ed25519CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinDelegateProtocol.d.ts",dts:"import { ICoinProtocol } from './ICoinProtocol';\nexport interface DelegateeDetails {\n    name?: string;\n    status?: any;\n    address: string;\n}\nexport interface DelegatorAction {\n    type: any;\n    args?: string[];\n}\nexport interface DelegatorDetails {\n    address: string;\n    balance: string;\n    delegatees: string[];\n    availableActions?: DelegatorAction[];\n    rewards?: DelegatorReward[];\n}\nexport interface DelegatorReward {\n    index: number;\n    amount: string;\n    collected?: boolean;\n    timestamp: number;\n}\nexport interface DelegationDetails {\n    delegator: DelegatorDetails;\n    delegatees: DelegateeDetails[];\n}\nexport interface ICoinDelegateProtocol extends ICoinProtocol {\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: any, data?: any): Promise<any[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from '..';\nimport { IAirGapSignedTransaction } from '../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction, IAirGapTransactionResult } from '../interfaces/IAirGapTransaction';\nimport { SignedTransaction } from '../serializer/schemas/definitions/signed-transaction';\nimport { UnsignedTransaction } from '../serializer/schemas/definitions/unsigned-transaction';\nimport { ProtocolOptions } from '../utils/ProtocolOptions';\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IProtocolTransactionCursor } from './../interfaces/IAirGapTransaction';\nimport { ICoinSubProtocol } from './ICoinSubProtocol';\nexport interface FeeDefaults {\n    low: string;\n    medium: string;\n    high: string;\n}\nexport interface CurrencyUnit {\n    unitSymbol: string;\n    factor: string;\n}\nexport interface CoinAddress {\n    getValue(): string;\n}\nexport interface ICoinProtocol {\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: {\n        unitSymbol: string;\n        factor: string;\n    }[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    subProtocols?: ICoinSubProtocol[];\n    options: ProtocolOptions;\n    cryptoClient: CryptoClient;\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string): Promise<CoinAddress>;\n    getAddressesFromPublicKey(publicKey: string): Promise<CoinAddress[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<CoinAddress>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<CoinAddress[]>;\n    getNextAddressFromPublicKey(publicKey: string, current: CoinAddress): Promise<CoinAddress>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any, childDerivationPath?: string): Promise<IAirGapSignedTransaction>;\n    signWithPrivateKey(privateKey: Buffer, transaction: any): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(transaction: UnsignedTransaction, data?: {\n        [key: string]: unknown;\n    }): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedTransaction, data?: {\n        [key: string]: unknown;\n    }): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[], data?: {\n        [key: string]: unknown;\n    }): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string, data?: {\n        addressIndex?: number;\n        [key: string]: unknown;\n    }): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset: number, data?: {\n        [key: string]: unknown;\n    }): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[], data?: {\n        [key: string]: unknown;\n    }): Promise<string>;\n    getTransactionStatuses(transactionHash: string[]): Promise<AirGapTransactionStatus[]>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string, data?: {\n        [key: string]: unknown;\n    }): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string, data?: {\n        addressIndex?: number;\n        [key: string]: unknown;\n    }): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: {\n        [key: string]: unknown;\n    }): Promise<FeeDefaults>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: {\n        [key: string]: unknown;\n    }): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string, extras?: {\n        [key: string]: unknown;\n    }): Promise<any>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, extras?: {\n        [key: string]: unknown;\n    }): Promise<any>;\n    broadcastTransaction(rawTransaction: any): Promise<string>;\n    signMessage(message: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(payload: string, privateKey: Buffer): Promise<string>;\n    decryptAES(encryptedPayload: string, privateKey: Buffer): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinSubProtocol.d.ts",dts:'import { ICoinProtocol } from \'./ICoinProtocol\';\nexport declare enum SubProtocolType {\n    ACCOUNT = "account",\n    TOKEN = "token"\n}\nexport interface ICoinSubProtocol extends ICoinProtocol {\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    contractAddress?: string;\n}\n'},{name:"@airgap/coinlib-core/protocols/NonExtendedProtocol.d.ts",dts:"import { IProtocolTransactionCursor } from '../interfaces/IAirGapTransaction';\nimport { FeeDefaults, CoinAddress } from './ICoinProtocol';\nimport { TezosTransactionResult } from './tezos/types/TezosTransactionResult';\nexport declare abstract class NonExtendedProtocol {\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset: number): Promise<string>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any, childDerivationPath: string): Promise<string>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<CoinAddress>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<CoinAddress[]>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor: IProtocolTransactionCursor): Promise<TezosTransactionResult>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/protocols/Secp256k1CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Secp256k1CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/Sr25519CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Sr25519CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/serializer/payloads/chunked-payload.d.ts",dts:"/// <reference types=\"node\" />\nimport { RLPData } from '../utils/toBuffer';\nimport { Payload } from './payload';\ninterface DecodedChunkedPayload {\n    currentPage: number;\n    total: number;\n    payload: Buffer;\n}\nexport declare class ChunkedPayload implements Payload {\n    currentPage: number;\n    total: number;\n    buffer: Buffer;\n    constructor(currentPage: number, total: number, buffer: Buffer);\n    static fromDecoded(object: DecodedChunkedPayload): ChunkedPayload;\n    static fromEncoded(buf: [Buffer, Buffer, Buffer]): ChunkedPayload;\n    asArray(): RLPData;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/payloads/full-payload.d.ts",dts:"/// <reference types=\"node\" />\nimport { IACMessageDefinitionObject } from '../message';\nimport { RLPData } from '../utils/toBuffer';\nimport { Payload } from './payload';\nexport declare class FullPayload implements Payload {\n    private readonly messages;\n    constructor(messages: IACMessageDefinitionObject[]);\n    static fromDecoded(object: IACMessageDefinitionObject[]): FullPayload;\n    static fromEncoded(buf: Buffer[]): FullPayload;\n    asJson(): IACMessageDefinitionObject[];\n    asArray(): RLPData;\n    asBuffer(): Buffer;\n    asString(): string;\n}\n"},{name:"@airgap/coinlib-core/serializer/payloads/payload.d.ts",dts:"import { RLPData } from '../utils/toBuffer';\nexport interface Payload {\n    asArray(): RLPData;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/account-share-request.d.ts",dts:"export interface AccountShareRequest {\n    protocols: string[];\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/account-share-response.d.ts",dts:"export interface AccountShareResponse {\n    publicKey: string;\n    derivationPath: string;\n    isExtendedPublicKey: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/config-set-request.d.ts",dts:"export interface ConfigSetRequest {\n    key: string;\n    value: string;\n    peerId: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/config-set-response.d.ts",dts:"export interface ConfigSetResponse {\n    key: string;\n    success: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/hex-string.d.ts",dts:"export declare type HexString = string;\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-retrieve-request.d.ts",dts:"export interface ItemStoreRequest {\n    storageId: string;\n    encryptionPublicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-retrieve-response.d.ts",dts:"export interface ItemStoreResponse {\n    payload: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-store-request.d.ts",dts:"export interface ItemStoreRequest {\n    id: string;\n    payload: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-store-response.d.ts",dts:"export interface ItemStoreResponse {\n    storageId: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-encrypt-request.d.ts",dts:"export interface MessageEncryptRequest {\n    method: 'symmetric' | 'asymmetric';\n    message: string;\n    publicKey: string;\n    protocol: string;\n    publicKeyToEncryptResponse: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-encrypt-response.d.ts",dts:"export interface MessageEncryptResponse {\n    encryptedMessage: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-sign-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-sign-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-verify-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-verify-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n    isValid: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/multisig-request.d.ts",dts:"export interface MultisigRequest {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/multisig-response.d.ts",dts:"export interface MultisigResponse {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/pair-request.d.ts",dts:"export interface PairRequest {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/pair-response.d.ts",dts:"export interface PairResponse {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-aeternity.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedAeternityTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-bitcoin.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedBitcoinTransaction extends SignedTransaction {\n    from: string[];\n    to: string[];\n    amount: string;\n    fee: string;\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-cosmos.d.ts",dts:"import { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { SignedTransaction } from './signed-transaction';\nexport interface SignedCosmosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: IAirGapSignedTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-ethereum.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedEthereumTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-substrate.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedSubstrateTransaction extends SignedTransaction {\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-tezos-sapling.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedTezosSaplingTransaction extends SignedTransaction {\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-tezos.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedTezosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction.d.ts",dts:"export interface SignedTransaction {\n    transaction: string;\n    accountIdentifier: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-aeternity.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedAeternityTransaction extends UnsignedTransaction {\n    transaction: RawAeternityTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-bitcoin.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\ninterface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\ninterface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface UnsignedBitcoinTransaction extends UnsignedTransaction {\n    transaction: RawBitcoinTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-cosmos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface CosmosCoin {\n    denom: string;\n    amount: string;\n}\ninterface CosmosFee {\n    amount: CosmosCoin[];\n    gas: string;\n}\ndeclare enum CosmosMessageTypeIndex {\n    SEND = 0,\n    DELEGATE = 1,\n    UNDELEGATE = 2,\n    WITHDRAW_DELEGATION_REWARD = 3\n}\ninterface CosmosMessage {\n    type: CosmosMessageTypeIndex;\n    amount: CosmosCoin[];\n    fromAddress: string;\n    toAddress: string;\n}\ninterface CosmosTransaction {\n    messages: CosmosMessage[];\n    fee: CosmosFee;\n    memo: string;\n    chainID: string;\n    accountNumber: string;\n    sequence: string;\n}\nexport interface SerializableUnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-ethereum.d.ts",dts:"import { HexString } from './hex-string';\nimport { UnsignedTransaction } from './unsigned-transaction';\ninterface RawEthereumTransaction {\n    nonce: HexString;\n    gasPrice: HexString;\n    gasLimit: HexString;\n    to: HexString;\n    value: HexString;\n    chainId: number;\n    data: HexString;\n}\nexport interface UnsignedEthereumTransaction extends UnsignedTransaction {\n    transaction: RawEthereumTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-substrate.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawSubstrateTransaction {\n    encoded: string;\n}\nexport interface UnsignedSubstrateTransaction extends UnsignedTransaction {\n    transaction: RawSubstrateTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-tezos-sapling.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface TezosSaplingInput {\n    rcm: string;\n    pos: string;\n    value: string;\n    address: string;\n}\ninterface TezosSaplingOutput {\n    address: string;\n    value: string;\n    memo: string;\n}\ninterface TezosSaplingStateDiff {\n    root: string;\n    commitments_and_ciphertexts: [string, TezosSaplingCiphertext][];\n    nullifiers: string[];\n}\ninterface TezosSaplingCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\ninterface RawTezosSaplingTransaction {\n    ins: TezosSaplingInput[];\n    outs: TezosSaplingOutput[];\n    chainId: string;\n    stateDiff: TezosSaplingStateDiff;\n    callParameters: string;\n}\nexport interface UnsignedTezosSaplingTransaction extends UnsignedTransaction {\n    transaction: RawTezosSaplingTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-tezos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface UnsignedTezosTransaction extends UnsignedTransaction {\n    transaction: RawTezosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction.d.ts",dts:"export interface UnsignedTransaction {\n    transaction: any;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/schema.d.ts",dts:'export declare type SchemaTransformer = (value: any) => any;\nexport declare enum SchemaTypes {\n    STRING = "string",\n    NUMBER = "number",\n    INTEGER = "integer",\n    BOOLEAN = "boolean",\n    NULL = "null",\n    ARRAY = "array",\n    OBJECT = "object",\n    HEX_STRING = "hexString"\n}\nexport interface SchemaRoot {\n    $ref: string;\n    $schema: string;\n    definitions: SchemaDefinition;\n}\nexport interface SchemaItem {\n    $ref?: string;\n    type?: SchemaTypes;\n    additionalProperties?: boolean;\n    properties?: SchemaItem;\n    required?: string[];\n}\nexport interface SchemaDefinition {\n    [key: string]: SchemaItem;\n}\nexport interface SchemaInfo {\n    schema: SchemaRoot;\n    transformer?: SchemaTransformer;\n}\n'},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/aeternity-transactions.validator.d.ts",dts:"import { SignedAeternityTransaction } from '../schemas/definitions/signed-transaction-aeternity';\nimport { UnsignedAeternityTransaction } from '../schemas/definitions/unsigned-transaction-aeternity';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class AeternityTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedAeternityTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedAeternityTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/bitcoin-transactions.validator.d.ts",dts:"import { SignedBitcoinTransaction } from '../schemas/definitions/signed-transaction-bitcoin';\nimport { UnsignedBitcoinTransaction } from '../schemas/definitions/unsigned-transaction-bitcoin';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class BitcoinTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedBitcoinTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedBitcoinTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/cosmos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class CosmosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/ethereum-transactions.validator.d.ts",dts:"import { SignedEthereumTransaction } from '../schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedEthereumTransaction } from '../schemas/definitions/unsigned-transaction-ethereum';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class EthereumTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedEthereumTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedEthereumTransaction): any;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/substrate-transactions.validator.d.ts",dts:"import { SignedSubstrateTransaction } from '../schemas/definitions/signed-transaction-substrate';\nimport { UnsignedSubstrateTransaction } from '../schemas/definitions/unsigned-transaction-substrate';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class SubstrateTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedSubstrateTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedSubstrateTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/tezos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/xtz-btc-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosBTCTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n    private assertDestination;\n    private assertParameters;\n    private assertNoHiddenXTZAmount;\n}\n"},{name:"@airgap/coinlib-core/serializer/utils/generateId.d.ts",dts:"export declare function generateIdV2(length: number): string;\n"},{name:"@airgap/coinlib-core/serializer/utils/json-to-rlp.d.ts",dts:"import { SchemaItem, SchemaRoot } from '../schemas/schema';\nimport { RLPData } from './toBuffer';\nexport declare function getDefinitionByRefPath(schema: SchemaRoot, refPath: string): SchemaItem;\nexport declare function unwrapSchema(schema: SchemaRoot): SchemaItem;\nexport declare function jsonToArray(key: string, schema: SchemaItem, value: Object): RLPData;\nexport declare function rlpArrayToJson(schema: SchemaItem, decoded: RLPData): {\n    [key: string]: unknown;\n};\n"},{name:"@airgap/coinlib-core/serializer/utils/toBuffer.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport declare type RLPData = number | string | boolean | BigNumber | Buffer;\nexport declare function toBuffer(rlpArray: RLPData): Buffer | Buffer[];\n"},{name:"@airgap/coinlib-core/serializer/validators/transactions.validator.d.ts",dts:"import { SignedTransaction } from '../schemas/definitions/signed-transaction';\nimport { UnsignedTransaction } from '../schemas/definitions/unsigned-transaction';\nexport declare abstract class TransactionValidator {\n    abstract validateUnsignedTransaction(transaction: UnsignedTransaction): Promise<boolean>;\n    abstract validateSignedTransaction(transaction: SignedTransaction): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/serializer/validators/validators.d.ts",dts:"export declare function validateSyncScheme(syncScheme: unknown): Promise<any>;\n"},{name:"@airgap/coinlib-core/serializer/constants.d.ts",dts:'declare const SERIALIZER_VERSION = 1;\nexport { SERIALIZER_VERSION };\nexport declare enum TezosBTCDetails {\n    CONTRACT_ADDRESS = "KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn"\n}\nexport declare enum TezosETHtzDetails {\n    CONTRACT_ADDRESS = "KT19at7rQUvyjxnZ2fBv7D9zc8rkyG7gAoU8"\n}\nexport declare enum TezosUUSDDetails {\n    CONTRACT_ADDRESS = "KT1XRPEPXbZK25r3Htzp2o1x7xdMMmfocKNW"\n}\nexport declare enum TezosYOUDetails {\n    CONTRACT_ADDRESS = "KT1Xobej4mc6XgEjDoJoHtTKgbD1ELMvcQuL"\n}\nexport declare enum TezosWrappedDetails {\n    CONTRACT_ADDRESS = "KT1VYsVfmobT7rsMVivvZ4J8i3bPiqz12NaH"\n}\nexport declare enum TezosKolibriUSDDetails {\n    CONTRACT_ADDRESS = "KT1K9gCRgaLRFKTErYt1wVxA3Frb9FjasjTV"\n}\n'},{name:"@airgap/coinlib-core/serializer/inter-app-communication-protocol.d.ts",dts:"import { IACMessageDefinitionObject } from './message';\nimport { Payload } from './payloads/payload';\nimport { IACPayloadType } from './serializer';\nexport declare type IACProtocolVersion = number;\nexport declare type IACProtocolType = [IACProtocolVersion, IACPayloadType, Payload];\nexport declare class IACProtocol {\n    readonly version: number;\n    readonly payloadType: IACPayloadType;\n    payload: Payload;\n    constructor(data: Payload);\n    decoded(): IACProtocolType;\n    encoded(): string;\n    static fromDecoded(data: IACMessageDefinitionObject[], singleChunkSize?: number, multiChunkSize?: number): IACProtocol[];\n    static fromEncoded(data: string[]): IACProtocol[];\n}\n"},{name:"@airgap/coinlib-core/serializer/interfaces.d.ts",dts:"export declare enum IACMessageType {\n    AccountShareRequest = 3,\n    AccountShareResponse = 4,\n    TransactionSignRequest = 5,\n    TransactionSignResponse = 6,\n    MessageSignRequest = 7,\n    MessageSignResponse = 8\n}\n"},{name:"@airgap/coinlib-core/serializer/message.d.ts",dts:"/// <reference types=\"node\" />\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageType } from './interfaces';\nimport { AccountShareResponse } from './schemas/definitions/account-share-response';\nimport { MessageSignRequest } from './schemas/definitions/message-sign-request';\nimport { MessageSignResponse } from './schemas/definitions/message-sign-response';\nimport { SignedAeternityTransaction } from './schemas/definitions/signed-transaction-aeternity';\nimport { SignedBitcoinTransaction } from './schemas/definitions/signed-transaction-bitcoin';\nimport { SignedCosmosTransaction } from './schemas/definitions/signed-transaction-cosmos';\nimport { SignedEthereumTransaction } from './schemas/definitions/signed-transaction-ethereum';\nimport { SignedSubstrateTransaction } from './schemas/definitions/signed-transaction-substrate';\nimport { SignedTezosTransaction } from './schemas/definitions/signed-transaction-tezos';\nimport { SignedTezosSaplingTransaction } from './schemas/definitions/signed-transaction-tezos-sapling';\nimport { UnsignedAeternityTransaction } from './schemas/definitions/unsigned-transaction-aeternity';\nimport { UnsignedBitcoinTransaction } from './schemas/definitions/unsigned-transaction-bitcoin';\nimport { UnsignedEthereumTransaction } from './schemas/definitions/unsigned-transaction-ethereum';\nimport { UnsignedSubstrateTransaction } from './schemas/definitions/unsigned-transaction-substrate';\nimport { UnsignedTezosTransaction } from './schemas/definitions/unsigned-transaction-tezos';\nimport { UnsignedTezosSaplingTransaction } from './schemas/definitions/unsigned-transaction-tezos-sapling';\nimport { UnsignedCosmosTransaction } from './types';\nimport { RLPData } from './utils/toBuffer';\nexport declare type IACMessages = AccountShareResponse | MessageSignRequest | MessageSignResponse | UnsignedTezosTransaction | UnsignedTezosSaplingTransaction | UnsignedAeternityTransaction | UnsignedBitcoinTransaction | UnsignedCosmosTransaction | UnsignedEthereumTransaction | UnsignedSubstrateTransaction | SignedTezosTransaction | SignedTezosSaplingTransaction | SignedAeternityTransaction | SignedBitcoinTransaction | SignedCosmosTransaction | SignedEthereumTransaction | SignedSubstrateTransaction;\nexport interface IACMessageDefinitionObject {\n    id: string;\n    type: IACMessageType;\n    protocol: ProtocolSymbols;\n    payload: IACMessages;\n}\nexport interface MessageDefinitionArray {\n    [0]: Buffer;\n    [1]: Buffer;\n    [2]: Buffer;\n    [3]: Buffer;\n    [4]: Buffer;\n}\nexport declare class Message implements IACMessageDefinitionObject {\n    private readonly version;\n    private readonly schema;\n    readonly id: string;\n    readonly type: IACMessageType;\n    readonly protocol: ProtocolSymbols;\n    readonly payload: IACMessages;\n    constructor(type: IACMessageType, protocol: ProtocolSymbols, payload: IACMessages, id?: string, version?: string);\n    asJson(): IACMessageDefinitionObject;\n    asArray(): RLPData;\n    static fromDecoded(object: IACMessageDefinitionObject): Message;\n    static fromEncoded(buf: MessageDefinitionArray): Message;\n    private static parseVersion;\n    private static parseType;\n    private static parseProtocol;\n    private static parseId;\n    private static parsePayload;\n    private static validateProperty;\n}\n"},{name:"@airgap/coinlib-core/serializer/serializer.d.ts",dts:"import { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageDefinitionObject } from './message';\nimport { SchemaInfo } from './schemas/schema';\nimport { TransactionValidator } from './validators/transactions.validator';\nexport declare enum IACPayloadType {\n    FULL = 0,\n    CHUNKED = 1\n}\nexport declare class Serializer {\n    private static readonly schemas;\n    static addSchema(schemaId: number, schema: SchemaInfo, protocol?: ProtocolSymbols): void;\n    static getSchema(schemaId: number, protocol?: ProtocolSymbols): SchemaInfo;\n    private static getSchemaName;\n    serialize(messages: IACMessageDefinitionObject[], singleChunkSize?: number, multiChunkSize?: number): Promise<string[]>;\n    deserialize(data: string[]): Promise<IACMessageDefinitionObject[]>;\n    serializationValidatorByProtocolIdentifier(protocolIdentifier: ProtocolSymbols): TransactionValidator;\n}\n"},{name:"@airgap/coinlib-core/serializer/types.d.ts",dts:"import { CosmosTransaction } from '../protocols/cosmos/CosmosTransaction';\nimport { TezosSaplingInput } from '../protocols/tezos/types/sapling/TezosSaplingInput';\nimport { TezosSaplingOutput } from '../protocols/tezos/types/sapling/TezosSaplingOutput';\nimport { TezosSaplingStateDiff } from '../protocols/tezos/types/sapling/TezosSaplingStateDiff';\nimport { UnsignedTransaction } from './schemas/definitions/unsigned-transaction';\nexport interface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface RawTezosSaplingTransaction {\n    ins: TezosSaplingInput[];\n    outs: TezosSaplingOutput[];\n    chainId: string;\n    stateDiff: TezosSaplingStateDiff;\n    callParameters: string;\n}\nexport interface RawEthereumTransaction {\n    nonce: string;\n    gasPrice: string;\n    gasLimit: string;\n    to: string;\n    value: string;\n    chainId: number;\n    data: string;\n}\nexport interface RawTypedEthereumTransaction {\n    serialized: string;\n    derivationPath: string;\n    masterFingerprint: string;\n}\nexport interface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\nexport interface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\nexport interface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport interface RawSubstrateTransaction {\n    encoded: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/account-share-request.d.ts",dts:"export interface AccountShareRequest {\n    protocols: string[];\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/account-share-response.d.ts",dts:"export interface AccountShareResponse {\n    publicKey: string;\n    derivationPath: string;\n    isExtendedPublicKey: boolean;\n    masterFingerprint: string;\n    isActive: boolean;\n    groupId: string;\n    groupLabel: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/config-set-request.d.ts",dts:"export interface ConfigSetRequest {\n    key: string;\n    value: string;\n    peerId: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/config-set-response.d.ts",dts:"export interface ConfigSetResponse {\n    key: string;\n    success: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/hex-string.d.ts",dts:"export declare type HexString = string;\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/item-retrieve-request.d.ts",dts:"export interface ItemStoreRequest {\n    storageId: string;\n    encryptionPublicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/item-retrieve-response.d.ts",dts:"export interface ItemStoreResponse {\n    payload: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/item-store-request.d.ts",dts:"export interface ItemStoreRequest {\n    id: string;\n    payload: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/item-store-response.d.ts",dts:"export interface ItemStoreResponse {\n    storageId: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-encrypt-request.d.ts",dts:"export interface MessageEncryptRequest {\n    method: 'symmetric' | 'asymmetric';\n    message: string;\n    publicKey: string;\n    protocol: string;\n    publicKeyToEncryptResponse: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-encrypt-response.d.ts",dts:"export interface MessageEncryptResponse {\n    encryptedMessage: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-sign-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-sign-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-verify-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/message-verify-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n    isValid: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/multisig-request.d.ts",dts:"export interface MultisigRequest {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/multisig-response.d.ts",dts:"export interface MultisigResponse {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/pair-request.d.ts",dts:"export interface PairRequest {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/pair-response.d.ts",dts:"export interface PairResponse {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-aeternity.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedAeternityTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-bitcoin-segwit.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedBitcoinSegwitTransaction extends SignedTransaction {\n    transaction: string;\n    accountIdentifier: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-bitcoin.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedBitcoinTransaction extends SignedTransaction {\n    from: string[];\n    to: string[];\n    amount: string;\n    fee: string;\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-cosmos.d.ts",dts:"import { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { SignedTransaction } from './signed-transaction';\nexport interface SignedCosmosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: IAirGapSignedTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-ethereum.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedEthereumTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-substrate.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedSubstrateTransaction extends SignedTransaction {\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-tezos-sapling.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedTezosSaplingTransaction extends SignedTransaction {\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction-tezos.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedTezosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/signed-transaction.d.ts",dts:"export interface SignedTransaction {\n    transaction: string;\n    accountIdentifier: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-aeternity.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedAeternityTransaction extends UnsignedTransaction {\n    transaction: RawAeternityTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-bitcoin-segwit.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawBitcoinSegwitTransaction {\n    psbt: string;\n}\nexport interface UnsignedBitcoinSegwitTransaction extends UnsignedTransaction {\n    transaction: RawBitcoinSegwitTransaction;\n    publicKey: string;\n    callbackURL?: string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-bitcoin.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\ninterface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\ninterface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface UnsignedBitcoinTransaction extends UnsignedTransaction {\n    transaction: RawBitcoinTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-cosmos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface CosmosCoin {\n    denom: string;\n    amount: string;\n}\ninterface CosmosFee {\n    amount: CosmosCoin[];\n    gas: string;\n}\ndeclare enum CosmosMessageTypeIndex {\n    SEND = 0,\n    DELEGATE = 1,\n    UNDELEGATE = 2,\n    WITHDRAW_DELEGATION_REWARD = 3\n}\ninterface CosmosMessage {\n    type: CosmosMessageTypeIndex;\n    amount: CosmosCoin[];\n    fromAddress: string;\n    toAddress: string;\n}\ninterface CosmosTransaction {\n    messages: CosmosMessage[];\n    fee: CosmosFee;\n    memo: string;\n    chainID: string;\n    accountNumber: string;\n    sequence: string;\n}\nexport interface SerializableUnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-ethereum-typed.d.ts",dts:"import { HexString } from './hex-string';\nimport { UnsignedTransaction } from './unsigned-transaction';\ninterface RawTypedEthereumTransaction {\n    serialized: HexString;\n    derivationPath: string;\n    masterFingerprint: string;\n}\nexport interface UnsignedTypedEthereumTransaction extends UnsignedTransaction {\n    transaction: RawTypedEthereumTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-ethereum.d.ts",dts:"import { HexString } from './hex-string';\nimport { UnsignedTransaction } from './unsigned-transaction';\ninterface RawEthereumTransaction {\n    nonce: HexString;\n    gasPrice: HexString;\n    gasLimit: HexString;\n    to: HexString;\n    value: HexString;\n    chainId: number;\n    data: HexString;\n}\nexport interface UnsignedEthereumTransaction extends UnsignedTransaction {\n    transaction: RawEthereumTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-substrate.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawSubstrateTransaction {\n    encoded: string;\n}\nexport interface UnsignedSubstrateTransaction extends UnsignedTransaction {\n    transaction: RawSubstrateTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-tezos-sapling.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface TezosSaplingInput {\n    rcm: string;\n    pos: string;\n    value: string;\n    address: string;\n}\ninterface TezosSaplingOutput {\n    address: string;\n    value: string;\n    memo: string;\n}\ninterface TezosSaplingStateDiff {\n    root: string;\n    commitments_and_ciphertexts: [string, TezosSaplingCiphertext][];\n    nullifiers: string[];\n}\ninterface TezosSaplingCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\ninterface RawTezosSaplingTransaction {\n    ins: TezosSaplingInput[];\n    outs: TezosSaplingOutput[];\n    chainId: string;\n    stateDiff: TezosSaplingStateDiff;\n    callParameters: string;\n}\nexport interface UnsignedTezosSaplingTransaction extends UnsignedTransaction {\n    transaction: RawTezosSaplingTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction-tezos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface UnsignedTezosTransaction extends UnsignedTransaction {\n    transaction: RawTezosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/definitions/unsigned-transaction.d.ts",dts:"export interface UnsignedTransaction {\n    transaction: any;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/schemas/schema.d.ts",dts:'export declare type SchemaTransformer = (value: any) => any;\nexport declare enum SchemaTypes {\n    STRING = "string",\n    NUMBER = "number",\n    INTEGER = "integer",\n    BOOLEAN = "boolean",\n    NULL = "null",\n    ARRAY = "array",\n    OBJECT = "object"\n}\nexport interface SchemaRoot {\n    $ref: string;\n    $schema: string;\n    definitions: SchemaDefinition;\n}\nexport interface SchemaItem {\n    $ref?: string;\n    type?: SchemaTypes;\n    additionalProperties?: boolean;\n    properties?: SchemaItem;\n    required?: string[];\n}\nexport interface SchemaDefinition {\n    [key: string]: SchemaItem;\n}\nexport interface SchemaInfo {\n    schema: SchemaRoot;\n    transformer?: SchemaTransformer;\n}\n'},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/aeternity-transactions.validator.d.ts",dts:"import { SignedAeternityTransaction } from '../schemas/definitions/signed-transaction-aeternity';\nimport { UnsignedAeternityTransaction } from '../schemas/definitions/unsigned-transaction-aeternity';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class AeternityTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedAeternityTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedAeternityTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/bitcoin-transactions.validator.d.ts",dts:"import { SignedBitcoinTransaction } from '../schemas/definitions/signed-transaction-bitcoin';\nimport { UnsignedBitcoinTransaction } from '../schemas/definitions/unsigned-transaction-bitcoin';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class BitcoinTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedBitcoinTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedBitcoinTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/cosmos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class CosmosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/ethereum-transactions.validator.d.ts",dts:"import { SignedEthereumTransaction } from '../schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedEthereumTransaction } from '../schemas/definitions/unsigned-transaction-ethereum';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class EthereumTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedEthereumTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedEthereumTransaction): any;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/substrate-transactions.validator.d.ts",dts:"import { SignedSubstrateTransaction } from '../schemas/definitions/signed-transaction-substrate';\nimport { UnsignedSubstrateTransaction } from '../schemas/definitions/unsigned-transaction-substrate';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class SubstrateTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedSubstrateTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedSubstrateTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/tezos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/unsigned-transactions/xtz-btc-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosBTCTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n    private assertDestination;\n    private assertParameters;\n    private assertNoHiddenXTZAmount;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/utils/generateId.d.ts",dts:"export declare const ID_LENGTH: number;\nexport declare function generateId(length?: number): number;\n"},{name:"@airgap/coinlib-core/serializer-v3/utils/json-to-rlp.d.ts",dts:"import { SchemaItem, SchemaRoot } from '../schemas/schema';\nimport { CBORData } from './toBuffer';\nexport declare function getDefinitionByRefPath(schema: SchemaRoot, refPath: string): SchemaItem;\nexport declare function unwrapSchema(schema: SchemaRoot): SchemaItem;\nexport declare function jsonToArray(key: string, schema: SchemaItem, value: Object): CBORData;\nexport declare function rlpArrayToJson(schema: SchemaItem, decoded: CBORData): {\n    [key: string]: unknown;\n};\n"},{name:"@airgap/coinlib-core/serializer-v3/utils/toBuffer.d.ts",dts:'/// <reference types="node" />\nexport declare type CBORData = number | string | boolean | Buffer | CBORData[];\n'},{name:"@airgap/coinlib-core/serializer-v3/validators/transactions.validator.d.ts",dts:"import { SignedTransaction } from '../schemas/definitions/signed-transaction';\nimport { UnsignedTransaction } from '../schemas/definitions/unsigned-transaction';\nexport declare abstract class TransactionValidator {\n    abstract validateUnsignedTransaction(transaction: UnsignedTransaction): Promise<boolean>;\n    abstract validateSignedTransaction(transaction: SignedTransaction): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/validators/validators.d.ts",dts:"export declare function validateSyncScheme(syncScheme: unknown): Promise<any>;\n"},{name:"@airgap/coinlib-core/serializer-v3/constants.d.ts",dts:'declare const SERIALIZER_VERSION = 1;\nexport { SERIALIZER_VERSION };\nexport declare enum TezosBTCDetails {\n    CONTRACT_ADDRESS = "KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn"\n}\nexport declare enum TezosETHtzDetails {\n    CONTRACT_ADDRESS = "KT19at7rQUvyjxnZ2fBv7D9zc8rkyG7gAoU8"\n}\nexport declare enum TezosWrappedDetails {\n    CONTRACT_ADDRESS = "KT1VYsVfmobT7rsMVivvZ4J8i3bPiqz12NaH"\n}\nexport declare enum TezosKolibriUSDDetails {\n    CONTRACT_ADDRESS = "KT1K9gCRgaLRFKTErYt1wVxA3Frb9FjasjTV"\n}\n'},{name:"@airgap/coinlib-core/serializer-v3/iac-message-wrapper.d.ts",dts:"import { IACMessageDefinitionObjectV3, MessageDefinitionArray } from './message';\nimport { Payload } from './payload';\nexport declare type IACMessageWrapperVersion = number;\nexport declare type IACMessageWrapperArray = [IACMessageWrapperVersion, Payload];\nexport declare type IACMessageWrapperArrayEncoded = [IACMessageWrapperVersion, MessageDefinitionArray[]];\nexport declare class IACMessageWrapper {\n    readonly version: number;\n    payload: Payload;\n    constructor(data: Payload);\n    decoded(): IACMessageWrapperArray;\n    encoded(): string;\n    static fromDecoded(data: IACMessageDefinitionObjectV3[]): IACMessageWrapper;\n    static fromEncoded(data: string): IACMessageWrapper;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/interfaces.d.ts",dts:"export declare enum IACMessageType {\n    AccountShareRequest = 3,\n    AccountShareResponse = 4,\n    TransactionSignRequest = 5,\n    TransactionSignResponse = 6,\n    MessageSignRequest = 7,\n    MessageSignResponse = 8\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/message.d.ts",dts:"import { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageType } from './interfaces';\nimport { AccountShareResponse } from './schemas/definitions/account-share-response';\nimport { MessageSignRequest } from './schemas/definitions/message-sign-request';\nimport { MessageSignResponse } from './schemas/definitions/message-sign-response';\nimport { SignedAeternityTransaction } from './schemas/definitions/signed-transaction-aeternity';\nimport { SignedBitcoinTransaction } from './schemas/definitions/signed-transaction-bitcoin';\nimport { SignedBitcoinSegwitTransaction } from './schemas/definitions/signed-transaction-bitcoin-segwit';\nimport { SignedCosmosTransaction } from './schemas/definitions/signed-transaction-cosmos';\nimport { SignedEthereumTransaction } from './schemas/definitions/signed-transaction-ethereum';\nimport { SignedSubstrateTransaction } from './schemas/definitions/signed-transaction-substrate';\nimport { SignedTezosTransaction } from './schemas/definitions/signed-transaction-tezos';\nimport { SignedTezosSaplingTransaction } from './schemas/definitions/signed-transaction-tezos-sapling';\nimport { UnsignedAeternityTransaction } from './schemas/definitions/unsigned-transaction-aeternity';\nimport { UnsignedBitcoinTransaction } from './schemas/definitions/unsigned-transaction-bitcoin';\nimport { UnsignedBitcoinSegwitTransaction } from './schemas/definitions/unsigned-transaction-bitcoin-segwit';\nimport { UnsignedEthereumTransaction } from './schemas/definitions/unsigned-transaction-ethereum';\nimport { UnsignedTypedEthereumTransaction } from './schemas/definitions/unsigned-transaction-ethereum-typed';\nimport { UnsignedSubstrateTransaction } from './schemas/definitions/unsigned-transaction-substrate';\nimport { UnsignedTezosTransaction } from './schemas/definitions/unsigned-transaction-tezos';\nimport { UnsignedTezosSaplingTransaction } from './schemas/definitions/unsigned-transaction-tezos-sapling';\nimport { UnsignedCosmosTransaction } from './types';\nimport { CBORData } from './utils/toBuffer';\nexport declare type IACMessages = AccountShareResponse | MessageSignRequest | MessageSignResponse | UnsignedTezosTransaction | UnsignedTezosSaplingTransaction | UnsignedAeternityTransaction | UnsignedBitcoinTransaction | UnsignedBitcoinSegwitTransaction | UnsignedCosmosTransaction | UnsignedEthereumTransaction | UnsignedTypedEthereumTransaction | UnsignedSubstrateTransaction | SignedTezosTransaction | SignedTezosSaplingTransaction | SignedAeternityTransaction | SignedBitcoinTransaction | SignedBitcoinSegwitTransaction | SignedCosmosTransaction | SignedEthereumTransaction | SignedSubstrateTransaction;\nexport interface IACMessageDefinitionObjectV3 {\n    id: number;\n    type: IACMessageType;\n    protocol: ProtocolSymbols;\n    payload: IACMessages;\n}\nexport declare type MessageDefinitionArray = [\n    number,\n    number,\n    ProtocolSymbols,\n    number,\n    CBORData\n];\nexport declare function isMessageDefinitionArray(value: unknown): value is MessageDefinitionArray;\nexport declare class Message implements IACMessageDefinitionObjectV3 {\n    private readonly version;\n    readonly id: number;\n    readonly type: IACMessageType;\n    readonly protocol: ProtocolSymbols;\n    readonly payload: IACMessages;\n    constructor(type: IACMessageType, protocol: ProtocolSymbols, payload: IACMessages, id?: number, version?: number);\n    asJson(): IACMessageDefinitionObjectV3;\n    asArray(): MessageDefinitionArray;\n    static fromDecoded(object: IACMessageDefinitionObjectV3): Message;\n    static fromEncoded(buf: MessageDefinitionArray): Message;\n    private static validateVersion;\n    private static validateType;\n    private static validateProtocol;\n    private static validateId;\n    private static validatePayload;\n    private static validateProperty;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/payload.d.ts",dts:"import { IACMessageDefinitionObjectV3, MessageDefinitionArray } from './message';\nexport declare class Payload {\n    private readonly messages;\n    constructor(messages: IACMessageDefinitionObjectV3[]);\n    static fromDecoded(object: IACMessageDefinitionObjectV3[]): Payload;\n    static fromEncoded(encoded: MessageDefinitionArray[]): Payload;\n    asJson(): IACMessageDefinitionObjectV3[];\n    asArray(): MessageDefinitionArray[];\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/serializer.d.ts",dts:"import { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageDefinitionObjectV3 } from './message';\nimport { SchemaInfo } from './schemas/schema';\nimport { TransactionValidator } from './validators/transactions.validator';\nexport declare class SerializerV3 {\n    private static readonly schemas;\n    static addSchema(schemaId: number, schema: SchemaInfo, protocol?: ProtocolSymbols): void;\n    static getSchemas(schemaId: number, protocol?: ProtocolSymbols): SchemaInfo[];\n    private static getSchemaName;\n    serialize(messages: IACMessageDefinitionObjectV3[]): Promise<string>;\n    deserialize(data: string): Promise<IACMessageDefinitionObjectV3[]>;\n    serializationValidatorByProtocolIdentifier(protocolIdentifier: ProtocolSymbols): TransactionValidator;\n}\n"},{name:"@airgap/coinlib-core/serializer-v3/types.d.ts",dts:"import { CosmosTransaction } from '../protocols/cosmos/CosmosTransaction';\nimport { TezosSaplingInput } from '../protocols/tezos/types/sapling/TezosSaplingInput';\nimport { TezosSaplingOutput } from '../protocols/tezos/types/sapling/TezosSaplingOutput';\nimport { TezosSaplingStateDiff } from '../protocols/tezos/types/sapling/TezosSaplingStateDiff';\nimport { UnsignedTransaction } from './schemas/definitions/unsigned-transaction';\nexport interface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface RawTezosSaplingTransaction {\n    ins: TezosSaplingInput[];\n    outs: TezosSaplingOutput[];\n    chainId: string;\n    stateDiff: TezosSaplingStateDiff;\n    callParameters: string;\n}\nexport interface RawEthereumTransaction {\n    nonce: string;\n    gasPrice: string;\n    gasLimit: string;\n    to: string;\n    value: string;\n    chainId: number;\n    data: string;\n}\nexport interface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\nexport interface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\nexport interface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface RawBitcoinSegwitTransaction {\n    psbt: string;\n}\nexport interface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport interface RawSubstrateTransaction {\n    encoded: string;\n}\n"},{name:"@airgap/coinlib-core/utils/remote-data/HttpRemoteData.d.ts",dts:"import { RawData, RemoteData } from './RemoteData';\nexport declare class HttpRemoteData<T> extends RemoteData<T> {\n    static from<T>(uri: string): HttpRemoteData<T> | undefined;\n    static validate(uri: string): boolean;\n    get(): Promise<T | undefined>;\n    getRaw(): Promise<RawData | undefined>;\n    private getData;\n}\n"},{name:"@airgap/coinlib-core/utils/remote-data/IpfsRemoteData.d.ts",dts:"import { RawData, RemoteData } from './RemoteData';\nexport declare class IpfsRemoteData<T> extends RemoteData<T> {\n    static from<T>(uri: string): IpfsRemoteData<T> | undefined;\n    static validate(uri: string): boolean;\n    get(): Promise<T | undefined>;\n    getRaw(): Promise<RawData | undefined>;\n    private getData;\n}\n"},{name:"@airgap/coinlib-core/utils/remote-data/RemoteData.d.ts",dts:'/// <reference types="node" />\nexport interface RawData {\n    bytes: Buffer;\n    contentType?: string;\n}\nexport declare abstract class RemoteData<T> {\n    readonly uri: string;\n    protected constructor(uri: string);\n    abstract get(): Promise<T | undefined>;\n    abstract getRaw(): Promise<RawData | undefined>;\n}\n'},{name:"@airgap/coinlib-core/utils/remote-data/RemoteDataFactory.d.ts",dts:"import { RemoteData } from './RemoteData';\ndeclare type Validator = (uri: string) => boolean;\ndeclare type Factory<T> = <S>(uri: string, extra: T) => RemoteData<S> | undefined;\nexport interface RemoteDataFactoryExtra {\n}\nexport declare class RemoteDataFactory<T extends RemoteDataFactoryExtra = any> {\n    protected readonly factoriesWithValidators: [Validator, Factory<T>][];\n    constructor(extraFactoriesWithValidators?: [Validator, Factory<T>][]);\n    create<S>(uri: string, extra: T): RemoteData<S> | undefined;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/utils/remote-data/Sha256RemoteData.d.ts",dts:"/// <reference types=\"node\" />\nimport { RawData, RemoteData } from './RemoteData';\nexport declare class Sha256RemoteData<T> extends RemoteData<T> {\n    private readonly hash;\n    private readonly path;\n    protected constructor(uri: string, hash: Buffer, path: string);\n    static from<T>(uri: string): Sha256RemoteData<T> | undefined;\n    static validate(uri: string): boolean;\n    get(): Promise<T | undefined>;\n    getRaw(): Promise<RawData | undefined>;\n}\n"},{name:"@airgap/coinlib-core/utils/AES.d.ts",dts:"/// <reference types=\"node\" />\nexport declare class AES {\n    readonly AES_KEY_SIZE: number;\n    readonly KEY_DERIVATION_ITERATION_COUNT: number;\n    readonly ALGORITHM: 'aes-256-gcm';\n    readonly encoding: 'base64' | 'hex';\n    constructor(AES_KEY_SIZE?: number, KEY_DERIVATION_ITERATION_COUNT?: number, ALGORITHM?: 'aes-256-gcm', encoding?: 'base64' | 'hex');\n    encryptString(plainText: string, privateKey: Buffer): Promise<string>;\n    decryptString(encryptedValue: string, privateKey: Buffer): Promise<string>;\n    private deriveKeyFromPrivateKey;\n}\n"},{name:"@airgap/coinlib-core/utils/ErrorWithData.d.ts",dts:"export declare class ErrorWithData extends Error {\n    data: unknown;\n    constructor(message: string, data: unknown);\n}\n"},{name:"@airgap/coinlib-core/utils/Network.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nexport declare const isNetworkEqual: (network1: ProtocolNetwork, network2: ProtocolNetwork) => boolean;\n"},{name:"@airgap/coinlib-core/utils/ProtocolBlockExplorer.d.ts",dts:"export declare abstract class ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer: string);\n    abstract getAddressLink(address: string): Promise<string>;\n    abstract getTransactionLink(transactionId: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/utils/ProtocolNetwork.d.ts",dts:'import { ProtocolBlockExplorer } from \'./ProtocolBlockExplorer\';\nexport declare enum NetworkType {\n    MAINNET = "MAINNET",\n    TESTNET = "TESTNET",\n    CUSTOM = "CUSTOM"\n}\nexport declare abstract class ProtocolNetwork<T = unknown> {\n    readonly name: string;\n    readonly type: NetworkType;\n    readonly rpcUrl: string;\n    readonly blockExplorer: ProtocolBlockExplorer;\n    readonly extras: T;\n    get identifier(): string;\n    constructor(name: string, type: NetworkType, rpcUrl: string, blockExplorer: ProtocolBlockExplorer, extras: T);\n}\n'},{name:"@airgap/coinlib-core/utils/ProtocolOptions.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nexport interface ProtocolOptions<T = unknown> {\n    network: ProtocolNetwork;\n    config: T;\n}\n"},{name:"@airgap/coinlib-core/utils/ProtocolSymbols.d.ts",dts:'export declare enum MainProtocolSymbols {\n    AE = "ae",\n    BTC = "btc",\n    BTC_SEGWIT = "btc_segwit",\n    ETH = "eth",\n    XTZ = "xtz",\n    XTZ_SHIELDED = "xtz_shielded",\n    GRS = "grs",\n    COSMOS = "cosmos",\n    POLKADOT = "polkadot",\n    KUSAMA = "kusama",\n    MOONBASE = "moonbase",\n    MOONRIVER = "moonriver",\n    MOONBEAM = "moonbeam"\n}\nexport declare enum SubProtocolSymbols {\n    XTZ_KT = "xtz-kt",\n    XTZ_BTC = "xtz-btc",\n    XTZ_USD = "xtz-usd",\n    XTZ_KUSD = "xtz-kusd",\n    XTZ_STKR = "xtz-stkr",\n    XTZ_ETHTZ = "xtz-eth",\n    XTZ_UUSD = "xtz-uusd",\n    XTZ_YOU = "xtz-you",\n    XTZ_W = "xtz-w",\n    XTZ_UDEFI = "xtz-udefi",\n    XTZ_CTEZ = "xtz-ctez",\n    XTZ_PLENTY = "xtz-plenty",\n    XTZ_WRAP = "xtz-wrap",\n    XTZ_QUIPU = "xtz-quipu",\n    ETH_ERC20 = "eth-erc20",\n    ETH_ERC20_XCHF = "eth-erc20-xchf"\n}\nexport declare type ProtocolSymbols = MainProtocolSymbols | SubProtocolSymbols;\nexport declare function isMainProtocolSymbol(identifier: string): identifier is MainProtocolSymbols;\nexport declare function isSubProtocolSymbol(identifier: string): identifier is SubProtocolSymbols;\nexport declare function isProtocolSymbol(identifier: string): identifier is ProtocolSymbols;\n'},{name:"@airgap/coinlib-core/utils/array.d.ts",dts:"export declare function shuffledArray<T>(array: T[]): T[];\nexport declare function chunkedArray<T>(array: T[], chunkSize: number): (T | undefined)[][];\nexport declare function flattenArray<T>(array: T[][]): T[];\nexport declare function zippedArrays<T, R>(a1: T[], a2: R[]): [T, R][];\n"},{name:"@airgap/coinlib-core/utils/assert.d.ts",dts:"export declare const assertNever: (x: never) => void;\nexport declare function assertFields(name: string, object: any, ...fields: string[]): void;\n"},{name:"@airgap/coinlib-core/utils/base64Check.d.ts",dts:'/// <reference types="node" />\ndeclare const bs64check: {\n    encode(input: any): string;\n    decode(input: Buffer | string): any;\n    checkSum: (payload: Buffer | string) => any;\n};\nexport default bs64check;\n'},{name:"@airgap/coinlib-core/utils/blake2b.d.ts",dts:"export declare function blake2bAsHex(data: Uint8Array | string, bitLength: number, config?: {\n    withPrefix: boolean;\n    key?: Uint8Array;\n}): string;\nexport declare function blake2bAsBytes(data: Uint8Array | string, bitLength: number, config?: {\n    key?: Uint8Array;\n}): Uint8Array;\n"},{name:"@airgap/coinlib-core/utils/buffer.d.ts",dts:'/// <reference types="node" />\nexport declare const bufferFrom: (data: any, encoding: BufferEncoding) => Buffer;\n'},{name:"@airgap/coinlib-core/utils/cache.d.ts",dts:"interface CacheConfig<T> {\n    cacheValue: boolean;\n    validate?: (value: T) => boolean;\n}\nexport declare class Cache {\n    expirationTime: number;\n    constructor(expirationTime: number);\n    private readonly cachedValues;\n    private readonly promises;\n    get<T>(key: string): Promise<T>;\n    save<T>(key: string, promise: Promise<T>, config?: CacheConfig<T>): Promise<T>;\n    delete(key: string): void;\n    private isValidOrDelete;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/utils/coinlibReady.d.ts",dts:"declare const isCoinlibReady: () => Promise<boolean>;\nexport { isCoinlibReady };\n"},{name:"@airgap/coinlib-core/utils/error.d.ts",dts:"export declare function invalidArgumentTypeError(name: string, expected: string, actual: string): Error;\n"},{name:"@airgap/coinlib-core/utils/hex.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport declare function addHexPrefix(raw: string): string;\nexport declare function stripHexPrefix(hex: string): string;\nexport declare function isHex(value: string): boolean;\nexport declare function toHexBuffer(value: number | BigNumber, bitLength?: number): Buffer;\nexport declare function toHexStringRaw(value: number | BigNumber, bitLength?: number): string;\nexport declare function toHexString(value: number | BigNumber, bitLength?: number): string;\nexport declare function hexToBytes(hex: string | Uint8Array | Buffer): Buffer;\nexport declare function bytesToHex(bytes: Uint8Array | Buffer | string, config?: {\n    withPrefix: boolean;\n}): string;\nexport declare function changeEndianness(hex: string): string;\n"},{name:"@airgap/coinlib-core/utils/object.d.ts",dts:"export declare function recursivelyFind<T>(unknownValue: unknown, field: string): T | undefined;\n"},{name:"@airgap/coinlib-core/utils/padStart.d.ts",dts:"export declare function padStart(targetString: string, targetLength: number, padString: string): string;\n"},{name:"@airgap/coinlib-core/utils/protocolOptionsByIdentifier.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolOptions } from './ProtocolOptions';\nimport { ProtocolSymbols } from './ProtocolSymbols';\ndeclare const getProtocolOptionsByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ProtocolOptions;\nexport { getProtocolOptionsByIdentifier };\n"},{name:"@airgap/coinlib-core/utils/protocolsByIdentifier.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolSymbols } from './ProtocolSymbols';\nexport declare const getProtocolByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ICoinProtocol;\n"},{name:"@airgap/coinlib-core/utils/sr25519.d.ts",dts:"import { KeyPair } from '../data/KeyPair';\nexport declare function createSr25519KeyPair(secret: string | Uint8Array, derivationPath: string): Promise<KeyPair>;\n"},{name:"@airgap/coinlib-core/utils/string.d.ts",dts:"export declare function extractGroups(str: string, options: {\n    groupStart: string[];\n    groupEnd: string[];\n    groupSeparator?: string;\n}): string[];\nexport declare function trimStart(value: string, char: string): string;\nexport declare function capitalize(value: string): string;\n"},{name:"@airgap/coinlib-core/utils/subProtocols.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { ICoinSubProtocol } from '../protocols/ICoinSubProtocol';\nimport { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolSymbols } from './ProtocolSymbols';\ndeclare const getSubProtocolsByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ICoinSubProtocol[];\ndeclare const addSubProtocol: (protocol: ICoinProtocol, subProtocol: ICoinSubProtocol) => void;\ndeclare const removeSubProtocol: (protocol: ICoinProtocol, subProtocol: ICoinSubProtocol) => void;\nexport { addSubProtocol, removeSubProtocol, getSubProtocolsByIdentifier };\n"},{name:"@airgap/coinlib-core/utils/supportedProtocols.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\ndeclare const supportedProtocols: () => ICoinProtocol[];\ndeclare const addSupportedProtocol: (newProtocol: ICoinProtocol) => void;\ndeclare const removeSupportedProtocol: (protocolToRemove: ICoinProtocol) => void;\nexport { addSupportedProtocol, removeSupportedProtocol, supportedProtocols };\n"},{name:"@airgap/coinlib-core/utils/type.d.ts",dts:"export declare function isRecord(obj: unknown): obj is Record<string, any>;\n"},{name:"@airgap/coinlib-core/utils/xxhash.d.ts",dts:'/// <reference types="node" />\nexport declare function xxhashAsHex(data: string | Uint8Array | Buffer, bitLength: number, config?: {\n    littleEndian: boolean;\n    withPrefix: boolean;\n}): string;\n'},{name:"@airgap/coinlib-core/wallet/AirGapCoinWallet.d.ts",dts:'import BigNumber from \'../dependencies/src/bignumber.js-9.0.0/bignumber\';\nimport { AirGapMarketWallet } from \'./AirGapMarketWallet\';\nexport declare enum TimeInterval {\n    HOURS = "24h",\n    DAYS = "7d",\n    MONTH = "30d"\n}\nexport declare class AirGapCoinWallet extends AirGapMarketWallet {\n    private currentBalance;\n    getCurrentBalance(): BigNumber | undefined;\n    setCurrentBalance(balance: BigNumber | undefined): void;\n    currentMarketPrice: BigNumber | undefined;\n    getCurrentMarketPrice(): BigNumber | undefined;\n    setCurrentMarketPrice(marketPrice: BigNumber | undefined): void;\n    protected _synchronize(): Promise<void>;\n    protected reset(): void;\n    fetchCurrentMarketPrice(baseSymbol?: string): Promise<BigNumber>;\n    balanceOf(): Promise<BigNumber>;\n}\n'},{name:"@airgap/coinlib-core/wallet/AirGapMarketWallet.d.ts",dts:"import BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapTransaction, IAirGapTransactionResult, IProtocolTransactionCursor } from '../interfaces/IAirGapTransaction';\nimport { FeeDefaults, ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { AirGapWallet, AirGapWalletStatus } from './AirGapWallet';\nexport interface AirGapWalletPriceService {\n    getCurrentMarketPrice(protocol: ICoinProtocol, baseSymbol: string): Promise<BigNumber>;\n}\nexport declare abstract class AirGapMarketWallet extends AirGapWallet {\n    protocol: ICoinProtocol;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    masterFingerprint: string;\n    status: AirGapWalletStatus;\n    priceService: AirGapWalletPriceService;\n    addressIndex?: number | undefined;\n    private synchronizePromise?;\n    constructor(protocol: ICoinProtocol, publicKey: string, isExtendedPublicKey: boolean, derivationPath: string, masterFingerprint: string, status: AirGapWalletStatus, priceService: AirGapWalletPriceService, addressIndex?: number | undefined);\n    abstract getCurrentBalance(...args: any): BigNumber | undefined;\n    abstract setCurrentBalance(balance: BigNumber | undefined, ...args: any): void;\n    abstract getCurrentMarketPrice(...args: any): BigNumber | undefined;\n    abstract setCurrentMarketPrice(balance: BigNumber | undefined, ...args: any): void;\n    abstract fetchCurrentMarketPrice(...args: any): Promise<BigNumber>;\n    abstract balanceOf(...args: any): Promise<BigNumber>;\n    protected abstract _synchronize(...args: any): Promise<void>;\n    protected abstract reset(): void;\n    protected addressesToCheck(): string[];\n    setProtocol(protocol: ICoinProtocol): Promise<void>;\n    synchronize(...args: any): Promise<void>;\n    fetchTransactions(limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    prepareTransaction(recipients: string[], values: string[], fee: string, data?: {\n        [key: string]: unknown;\n    }): Promise<IAirGapTransaction>;\n    getMaxTransferValue(recipients: string[], fee?: string, data?: {\n        [key: string]: unknown;\n    }): Promise<BigNumber>;\n    estimateFees(recipients: string[], values: string[], data?: {\n        [key: string]: unknown;\n    }): Promise<FeeDefaults>;\n}\n"},{name:"@airgap/coinlib-core/wallet/AirGapNFTWallet.d.ts",dts:"import BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapMarketWallet } from './AirGapMarketWallet';\nexport declare class AirGapNFTWallet extends AirGapMarketWallet {\n    private currentBalance;\n    getCurrentBalance(assetID: string): BigNumber | undefined;\n    setCurrentBalance(balance: BigNumber | undefined, assetID: string): void;\n    private currentMarketPrice;\n    getCurrentMarketPrice(assetID: string): BigNumber | undefined;\n    setCurrentMarketPrice(marketPrice: BigNumber | undefined, assetID: string): void;\n    synchronize(assetsID?: string[]): Promise<void>;\n    protected _synchronize(assetIDs?: string[]): Promise<void>;\n    protected reset(): void;\n    fetchCurrentMarketPrice(_assetID: string, _baseSymbol?: string): Promise<BigNumber>;\n    balanceOf(assetID: string): Promise<BigNumber>;\n}\n"},{name:"@airgap/coinlib-core/wallet/AirGapWallet.d.ts",dts:'import { IAirGapWallet } from \'../interfaces/IAirGapWallet\';\nimport { ICoinProtocol } from \'../protocols/ICoinProtocol\';\nimport { ProtocolSymbols } from \'../utils/ProtocolSymbols\';\nexport declare enum AirGapWalletStatus {\n    ACTIVE = "active",\n    HIDDEN = "hidden",\n    DELETED = "deleted",\n    TRANSIENT = "transient"\n}\nexport interface SerializedAirGapWallet {\n    protocolIdentifier: ProtocolSymbols;\n    networkIdentifier: string;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    addresses: string[];\n    masterFingerprint?: string;\n    status?: AirGapWalletStatus;\n    addressIndex?: number;\n}\nexport declare class AirGapWallet implements IAirGapWallet {\n    protocol: ICoinProtocol;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    masterFingerprint: string;\n    status: AirGapWalletStatus;\n    addressIndex?: number | undefined;\n    addresses: string[];\n    constructor(protocol: ICoinProtocol, publicKey: string, isExtendedPublicKey: boolean, derivationPath: string, masterFingerprint: string, status: AirGapWalletStatus, addressIndex?: number | undefined);\n    readonly receivingPublicAddress: string;\n    setProtocol(protocol: ICoinProtocol): Promise<void>;\n    deriveAddresses(amount?: number): Promise<string[]>;\n    toJSON(): SerializedAirGapWallet;\n}\n'},{name:"@airgap/coinlib-core/index.d.ts",dts:"import { EthereumProtocol } from './protocols/ethereum/EthereumProtocol';\nimport { ProtocolNotSupported, ProtocolVersionMismatch, SerializerVersionMismatch, TypeNotSupported, NetworkError } from './errors';\nimport { Domain } from './errors/coinlib-error';\nimport { IAirGapTransaction, IAirGapTransactionResult, IProtocolTransactionCursor } from './interfaces/IAirGapTransaction';\nimport { IAirGapWallet } from './interfaces/IAirGapWallet';\nimport { AeternityProtocol } from './protocols/aeternity/AeternityProtocol';\nimport { BitcoinProtocol } from './protocols/bitcoin/BitcoinProtocol';\nimport { BitcoinTestnetProtocol } from './protocols/bitcoin/BitcoinTestnetProtocol';\nimport { CosmosDelegationActionType, CosmosProtocol } from './protocols/cosmos/CosmosProtocol';\nimport { GenericERC20 } from './protocols/ethereum/erc20/GenericERC20';\nimport { EthereumClassicProtocol } from './protocols/ethereum/EthereumClassicProtocol';\nimport { EthereumRopstenProtocol } from './protocols/ethereum/EthereumRopstenProtocol';\nimport { GroestlcoinProtocol } from './protocols/groestlcoin/GroestlcoinProtocol';\nimport { GroestlcoinTestnetProtocol } from './protocols/groestlcoin/GroestlcoinTestnetProtocol';\nimport { DelegateeDetails, DelegatorAction, DelegatorDetails, DelegatorReward, ICoinDelegateProtocol } from './protocols/ICoinDelegateProtocol';\nimport { FeeDefaults, ICoinProtocol } from './protocols/ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from './protocols/ICoinSubProtocol';\nimport { SubstrateAddress } from './protocols/substrate/common/data/account/SubstrateAddress';\nimport { SubstratePayee } from './protocols/substrate/common/data/staking/SubstratePayee';\nimport { SubstrateNodeClient } from './protocols/substrate/common/node/SubstrateNodeClient';\nimport { SubstrateNetwork } from './protocols/substrate/SubstrateNetwork';\nimport { KusamaProtocol } from './protocols/substrate/kusama/KusamaProtocol';\nimport { PolkadotProtocol } from './protocols/substrate/polkadot/PolkadotProtocol';\nimport { SubstrateProtocol } from './protocols/substrate/SubstrateProtocol';\nimport { SubstrateDelegateProtocol } from './protocols/substrate/SubstrateDelegateProtocol';\nimport { TezosBTC } from './protocols/tezos/fa/TezosBTC';\nimport { TezosFAProtocol } from './protocols/tezos/fa/TezosFAProtocol';\nimport { TezosStaker } from './protocols/tezos/fa/TezosStaker';\nimport { TezosKtProtocol } from './protocols/tezos/kt/TezosKtProtocol';\nimport { TezosUSD } from './protocols/tezos/fa/TezosUSD';\nimport { BakerInfo, DelegationInfo, DelegationRewardInfo, TezosDelegatorAction, TezosNetwork, TezosPayoutInfo, TezosProtocol } from './protocols/tezos/TezosProtocol';\nimport { IACMessageType } from './serializer/interfaces';\nimport { IACMessageDefinitionObject, Message } from './serializer/message';\nimport { AccountShareResponse as AccountShareResponseV2 } from './serializer/schemas/definitions/account-share-response';\nimport { AccountShareResponse } from './serializer-v3/schemas/definitions/account-share-response';\nimport { MessageSignRequest } from './serializer/schemas/definitions/message-sign-request';\nimport { MessageSignResponse } from './serializer/schemas/definitions/message-sign-response';\nimport { SignedTransaction } from './serializer/schemas/definitions/signed-transaction';\nimport { SignedAeternityTransaction } from './serializer/schemas/definitions/signed-transaction-aeternity';\nimport { SignedBitcoinTransaction } from './serializer/schemas/definitions/signed-transaction-bitcoin';\nimport { SignedCosmosTransaction } from './serializer/schemas/definitions/signed-transaction-cosmos';\nimport { SignedEthereumTransaction } from './serializer/schemas/definitions/signed-transaction-ethereum';\nimport { SignedTezosTransaction } from './serializer/schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTransaction } from './serializer/schemas/definitions/unsigned-transaction';\nimport { UnsignedAeternityTransaction } from './serializer/schemas/definitions/unsigned-transaction-aeternity';\nimport { UnsignedBitcoinTransaction } from './serializer/schemas/definitions/unsigned-transaction-bitcoin';\nimport { UnsignedEthereumTransaction } from './serializer/schemas/definitions/unsigned-transaction-ethereum';\nimport { UnsignedTezosTransaction } from './serializer/schemas/definitions/unsigned-transaction-tezos';\nimport { Serializer } from './serializer/serializer';\nimport { SerializerV3 } from './serializer-v3/serializer';\nimport { RawAeternityTransaction, RawBitcoinTransaction, RawEthereumTransaction, RawSubstrateTransaction, RawTezosTransaction, UnsignedCosmosTransaction } from './serializer/types';\nimport { isCoinlibReady } from './utils/coinlibReady';\nimport { isNetworkEqual } from './utils/Network';\nimport { getProtocolByIdentifier } from './utils/protocolsByIdentifier';\nimport { addSubProtocol, getSubProtocolsByIdentifier } from './utils/subProtocols';\nimport { getProtocolOptionsByIdentifier } from './utils/protocolOptionsByIdentifier';\nimport { addSupportedProtocol, supportedProtocols } from './utils/supportedProtocols';\nimport { AirGapCoinWallet, TimeInterval } from './wallet/AirGapCoinWallet';\nimport { AirGapNFTWallet } from './wallet/AirGapNFTWallet';\nimport { AirGapMarketWallet, AirGapWalletPriceService } from './wallet/AirGapMarketWallet';\nimport { AirGapWallet, AirGapWalletStatus, SerializedAirGapWallet } from './wallet/AirGapWallet';\nimport { AeternityProtocolOptions, AeternalBlockExplorer, AeternityProtocolNetwork } from './protocols/aeternity/AeternityProtocolOptions';\nimport { AeternityCryptoClient } from './protocols/aeternity/AeternityCryptoClient';\nimport { BitcoinCryptoClient } from './protocols/bitcoin/BitcoinCryptoClient';\nimport { BitcoinProtocolNetworkExtras, BitcoinProtocolNetwork, BitcoinProtocolConfig, BlockcypherBlockExplorer, BitcoinProtocolOptions } from './protocols/bitcoin/BitcoinProtocolOptions';\nimport { CosmosCryptoClient } from './protocols/cosmos/CosmosCryptoClient';\nimport { MintscanBlockExplorer, CosmosProtocolNetwork, CosmosProtocolConfig, CosmosProtocolOptions } from './protocols/cosmos/CosmosProtocolOptions';\nimport { EthereumCryptoClient } from './protocols/ethereum/EthereumCryptoClient';\nimport { SubstrateCryptoClient } from './protocols/substrate/SubstrateCryptoClient';\nimport { TezosCryptoClient } from './protocols/tezos/TezosCryptoClient';\nimport { EthereumProtocolNetworkExtras, EtherscanBlockExplorer, EthereumProtocolNetwork, EthereumProtocolConfig, EthereumProtocolOptions, EthereumERC20ProtocolConfig, EthereumERC20ProtocolOptions } from './protocols/ethereum/EthereumProtocolOptions';\nimport { ProtocolBlockExplorer } from './utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from './utils/ProtocolNetwork';\nimport { GroestlcoinProtocolNetworkExtras, CryptoidBlockExplorer, GroestlcoinProtocolNetwork, GroestlcoinProtocolConfig, GroestlcoinProtocolOptions } from './protocols/groestlcoin/GroestlcoinProtocolOptions';\nimport { SubstrateProtocolNetworkExtras, SubstrateProtocolConfig, SubstrateProtocolNetwork, SubstrateProtocolOptions } from './protocols/substrate/SubstrateProtocolOptions';\nimport { KusamaProtocolNetworkExtras, KusamaSubscanBlockExplorer, KusamaProtocolConfig, KusamaProtocolNetwork, KusamaProtocolOptions } from './protocols/substrate/kusama/KusamaProtocolOptions';\nimport { PolkadotProtocolNetworkExtras, PolkadotSubscanBlockExplorer, PolkadotProtocolConfig, PolkadotProtocolNetwork, PolkadotProtocolOptions } from './protocols/substrate/polkadot/PolkadotProtocolOptions';\nimport { CryptoClient } from './protocols/CryptoClient';\nimport { TezosProtocolNetworkExtras, TezblockBlockExplorer, TezosProtocolNetwork, TezosProtocolConfig, TezosProtocolOptions } from './protocols/tezos/TezosProtocolOptions';\nimport { TezosFAProtocolConfig, TezosBTCProtocolConfig, TezosStakerProtocolConfig, TezosUSDProtocolConfig, TezosFAProtocolOptions, TezosFA2ProtocolConfig, TezosFA2ProtocolOptions, TezosETHtzProtocolConfig, TezosUUSDProtocolConfig, TezosYOUProtocolConfig, TezosWrappedProtocolConfig, TezosKolibriUSDProtocolConfig } from './protocols/tezos/fa/TezosFAProtocolOptions';\nimport { TezosTransactionResult } from './protocols/tezos/types/TezosTransactionResult';\nimport { TezosTransactionCursor } from './protocols/tezos/types/TezosTransactionCursor';\nimport { generateId } from './serializer-v3/utils/generateId';\nimport { generateIdV2 } from './serializer/utils/generateId';\nimport { ProtocolSymbols, MainProtocolSymbols, SubProtocolSymbols, isProtocolSymbol, isMainProtocolSymbol, isSubProtocolSymbol } from './utils/ProtocolSymbols';\nimport { TezosUtils } from './protocols/tezos/TezosUtils';\nimport { TezosFA2Protocol } from './protocols/tezos/fa/TezosFA2Protocol';\nimport { TezosFA1Protocol } from './protocols/tezos/fa/TezosFA1Protocol';\nimport { TezosFA1p2Protocol } from './protocols/tezos/fa/TezosFA1p2Protocol';\nimport { TezosSaplingProtocol } from './protocols/tezos/sapling/TezosSaplingProtocol';\nimport { TezosShieldedTezProtocol } from './protocols/tezos/sapling/TezosShieldedTezProtocol';\nimport { ImportAccountAction, ImportAccoutActionContext } from './actions/GetKtAccountsAction';\nimport { CosmosUnbondingDelegation, CosmosValidator } from './protocols/cosmos/CosmosNodeClient';\nimport { SubstrateElectionStatus } from './protocols/substrate/common/data/staking/SubstrateEraElectionStatus';\nimport { SubstrateNominationStatus } from './protocols/substrate/common/data/staking/SubstrateNominationStatus';\nimport { SubstrateNominatorDetails, SubstrateStakingDetails } from './protocols/substrate/common/data/staking/SubstrateNominatorDetails';\nimport { SubstrateStakingActionType } from './protocols/substrate/common/data/staking/SubstrateStakingActionType';\nimport { SubstrateValidatorDetails } from './protocols/substrate/common/data/staking/SubstrateValidatorDetails';\nimport { IAirGapSignedTransaction } from './interfaces/IAirGapSignedTransaction';\nimport { Action } from './actions/Action';\nimport { SubstrateTransaction } from './protocols/substrate/common/data/transaction/SubstrateTransaction';\nimport { LinkedAction } from './actions/LinkedAction';\nimport { SimpleAction } from './actions/SimpleAction';\nimport { RepeatableAction } from './actions/RepeatableAction';\nimport { TezosWrappedOperation } from './protocols/tezos/types/TezosWrappedOperation';\nimport { assertNever } from './utils/assert';\nimport { CosmosTransaction } from './protocols/cosmos/CosmosTransaction';\nimport { CosmosAddress } from './protocols/cosmos/CosmosAddress';\nimport { TezosETHtz } from './protocols/tezos/fa/TezosETHtz';\nimport { TezosUUSD } from './protocols/tezos/fa/TezosUUSD';\nimport { TezosYOU } from './protocols/tezos/fa/TezosYOU';\nimport { TezosWrapped } from './protocols/tezos/fa/TezosWrapped';\nimport { TezosKolibriUSD } from './protocols/tezos/fa/TezosKolibriUSD';\nimport { TezosSaplingExternalMethodProvider, TezosSaplingProtocolConfig, TezosSaplingProtocolOptions, TezosShieldedTezProtocolConfig } from './protocols/tezos/sapling/TezosSaplingProtocolOptions';\nimport { TezosSaplingTransaction } from './protocols/tezos/types/sapling/TezosSaplingTransaction';\nimport { TezosDomains } from './protocols/tezos/domains/TezosDomains';\nimport { AeternityAddress } from './protocols/aeternity/AeternityAddress';\nimport { BitcoinAddress } from './protocols/bitcoin/BitcoinAddress';\nimport { EthereumAddress } from './protocols/ethereum/EthereumAddress';\nimport { TezosAddress } from './protocols/tezos/TezosAddress';\nimport { IACMessageDefinitionObjectV3 } from './serializer-v3/message';\nimport { IACMessages as IACMessagesV2 } from './serializer/message';\nimport { IACMessages } from './serializer-v3/message';\nimport { bufferFrom } from './utils/buffer';\nimport { BitcoinSegwitProtocol } from './protocols/bitcoin/BitcoinSegwitProtocol';\nimport { BitcoinSegwitAddress } from './protocols/bitcoin/BitcoinSegwitAddress';\nimport { RawBitcoinSegwitTransaction } from './serializer-v3/types';\nimport { MoonbaseProtocol } from './protocols/substrate/moonbeam/moonbase/MoonbaseProtocol';\nimport { MoonriverProtocol } from './protocols/substrate/moonbeam/moonriver/MoonriverProtocol';\nimport { MoonbaseProtocolConfig, MoonbaseProtocolNetwork, MoonbaseProtocolNetworkExtras, MoonbaseProtocolOptions, MoonbaseSubscanBlockExplorer } from './protocols/substrate/moonbeam/moonbase/MoonbaseProtocolOptions';\nimport { MoonriverProtocolConfig, MoonriverProtocolNetwork, MoonriverProtocolNetworkExtras, MoonriverProtocolOptions, MoonriverSubscanBlockExplorer } from './protocols/substrate/moonbeam/moonriver/MoonriverProtocolOptions';\nimport { MoonbeamProtocol } from './protocols/substrate/moonbeam/MoonbeamProtocol';\nimport { SignedBitcoinSegwitTransaction } from './serializer-v3/schemas/definitions/signed-transaction-bitcoin-segwit';\nimport { UnsignedBitcoinSegwitTransaction } from './serializer-v3/schemas/definitions/unsigned-transaction-bitcoin-segwit';\nimport { TezosUDEFI, TezosUDEFIProtocolConfig } from './protocols/tezos/fa/TezosUDEFI';\nimport { TezosCTez, TezosCTezProtocolConfig } from './protocols/tezos/fa/TezosCTez';\nimport { TezosPlenty, TezosPlentyProtocolConfig } from './protocols/tezos/fa/TezosPlanty';\nimport { TezosWRAP, TezosWRAPProtocolConfig } from './protocols/tezos/fa/TezosWRAP';\nimport { TezosQUIPU, TezosQUIPUProtocolConfig } from './protocols/tezos/fa/TezosQUIPU';\nimport { UnsignedTypedEthereumTransaction } from './serializer-v3/schemas/definitions/unsigned-transaction-ethereum-typed';\nexport { AirGapWallet, AirGapMarketWallet, AirGapCoinWallet, AirGapWalletStatus, AirGapNFTWallet, IAirGapWallet, IAirGapTransaction, ICoinProtocol, ICoinSubProtocol, ICoinDelegateProtocol, CryptoClient, ProtocolBlockExplorer, ProtocolNetwork, ProtocolSymbols, MainProtocolSymbols, SubProtocolSymbols, NetworkType, FeeDefaults };\nexport { AeternityProtocol, AeternityCryptoClient, AeternityProtocolOptions, AeternalBlockExplorer, AeternityProtocolNetwork, AeternityAddress, RawAeternityTransaction };\nexport { BitcoinProtocol, BitcoinTestnetProtocol, BitcoinCryptoClient, BitcoinProtocolNetworkExtras, BlockcypherBlockExplorer, BitcoinProtocolNetwork, BitcoinProtocolConfig, BitcoinProtocolOptions, BitcoinAddress, RawBitcoinTransaction };\nexport { BitcoinSegwitProtocol, BitcoinSegwitAddress, RawBitcoinSegwitTransaction };\nexport { CosmosProtocol, CosmosCryptoClient, MintscanBlockExplorer, CosmosProtocolNetwork, CosmosProtocolConfig, CosmosProtocolOptions, CosmosUnbondingDelegation, CosmosValidator, CosmosDelegationActionType, CosmosAddress, CosmosTransaction };\nexport { EthereumProtocol, EthereumRopstenProtocol, EthereumClassicProtocol, GenericERC20, EthereumCryptoClient, EthereumProtocolNetworkExtras, EtherscanBlockExplorer, EthereumProtocolNetwork, EthereumProtocolConfig, EthereumProtocolOptions, EthereumERC20ProtocolConfig, EthereumERC20ProtocolOptions, EthereumAddress, RawEthereumTransaction };\nexport { GroestlcoinProtocol, GroestlcoinTestnetProtocol, GroestlcoinProtocolNetworkExtras, CryptoidBlockExplorer, GroestlcoinProtocolNetwork, GroestlcoinProtocolConfig, GroestlcoinProtocolOptions };\nexport { SubstrateProtocol, SubstrateDelegateProtocol, PolkadotProtocol, KusamaProtocol, MoonbeamProtocol, MoonbaseProtocol, MoonriverProtocol, SubstrateNetwork, SubstratePayee, SubstrateCryptoClient, SubstrateProtocolNetworkExtras, SubstrateProtocolConfig, SubstrateProtocolNetwork, SubstrateProtocolOptions, SubstrateNodeClient, KusamaProtocolNetworkExtras, KusamaSubscanBlockExplorer as KusamaPolkascanBlockExplorer, KusamaProtocolConfig, KusamaProtocolNetwork, KusamaProtocolOptions, PolkadotProtocolNetworkExtras, PolkadotSubscanBlockExplorer, PolkadotProtocolConfig, PolkadotProtocolNetwork, PolkadotProtocolOptions, MoonbaseProtocolNetworkExtras, MoonbaseSubscanBlockExplorer, MoonbaseProtocolConfig, MoonbaseProtocolNetwork, MoonbaseProtocolOptions, MoonriverProtocolNetworkExtras, MoonriverSubscanBlockExplorer, MoonriverProtocolConfig, MoonriverProtocolNetwork, MoonriverProtocolOptions, SubstrateElectionStatus, SubstrateNominationStatus, SubstrateNominatorDetails, SubstrateStakingDetails, SubstrateStakingActionType, SubstrateValidatorDetails, SubstrateTransaction, SubstrateAddress, RawSubstrateTransaction };\nexport { TezosProtocol, TezosKtProtocol, TezosFAProtocol, TezosFA1Protocol, TezosFA1p2Protocol, TezosFA2Protocol, TezosBTC, TezosStaker, TezosUSD, TezosETHtz as TezosETH, TezosUUSD, TezosYOU, TezosUDEFI, TezosWrapped, TezosWRAP, TezosKolibriUSD, TezosCTez, TezosPlenty, TezosQUIPU, TezosTransactionResult, TezosTransactionCursor, BakerInfo, DelegationRewardInfo, DelegationInfo, TezosPayoutInfo, TezosDelegatorAction, TezosCryptoClient, TezosProtocolNetworkExtras, TezblockBlockExplorer, TezosProtocolNetwork, TezosProtocolConfig, TezosProtocolOptions, TezosFAProtocolConfig, TezosFA2ProtocolConfig, TezosBTCProtocolConfig, TezosETHtzProtocolConfig as TezosETHProtocolConfig, TezosUUSDProtocolConfig, TezosYOUProtocolConfig, TezosWrappedProtocolConfig, TezosKolibriUSDProtocolConfig, TezosStakerProtocolConfig, TezosUSDProtocolConfig, TezosCTezProtocolConfig, TezosPlentyProtocolConfig, TezosUDEFIProtocolConfig, TezosWRAPProtocolConfig, TezosQUIPUProtocolConfig, TezosFAProtocolOptions, TezosFA2ProtocolOptions, TezosNetwork, TezosSaplingProtocol, TezosShieldedTezProtocol, TezosSaplingProtocolOptions, TezosSaplingProtocolConfig, TezosShieldedTezProtocolConfig, TezosSaplingExternalMethodProvider, TezosSaplingTransaction, TezosUtils, TezosWrappedOperation, TezosAddress, RawTezosTransaction, TezosDomains };\nexport { IACMessageType, IACMessageDefinitionObject, IACMessageDefinitionObjectV3, AccountShareResponse, MessageSignRequest, MessageSignResponse, SignedTransaction, UnsignedTransaction, UnsignedAeternityTransaction, UnsignedBitcoinTransaction, UnsignedBitcoinSegwitTransaction, UnsignedCosmosTransaction, UnsignedEthereumTransaction, UnsignedTypedEthereumTransaction, UnsignedTezosTransaction, SignedAeternityTransaction, SignedBitcoinTransaction, SignedBitcoinSegwitTransaction, SignedCosmosTransaction, SignedEthereumTransaction, SignedTezosTransaction, Serializer, SerializerV3, Message, SerializedAirGapWallet };\nexport { Action, RepeatableAction, LinkedAction, SimpleAction, ImportAccountAction, ImportAccoutActionContext };\nexport { isNetworkEqual, getProtocolOptionsByIdentifier, addSupportedProtocol, getProtocolByIdentifier, getSubProtocolsByIdentifier, supportedProtocols, isProtocolSymbol, isMainProtocolSymbol, isSubProtocolSymbol, TypeNotSupported, SerializerVersionMismatch, ProtocolNotSupported, NetworkError, Domain, ProtocolVersionMismatch, isCoinlibReady, addSubProtocol, generateId, generateIdV2, TimeInterval, DelegateeDetails, DelegatorAction, DelegatorDetails, DelegatorReward, IAirGapSignedTransaction, IAirGapTransactionResult, AirGapWalletPriceService, IProtocolTransactionCursor, SubProtocolType, assertNever };\nexport { IACMessages, IACMessagesV2, AccountShareResponseV2 };\nexport { bufferFrom };\n"},{name:"@airgap/coinlib-core/networks.d.ts",dts:"interface Bip32 {\n    public: number;\n    private: number;\n}\nexport interface Network {\n    messagePrefix?: string;\n    bip32: Bip32;\n    pubKeyHash: number;\n    scriptHash?: number;\n    wif: number;\n    dustSoftThreshold?: number;\n    dustThreshold?: number;\n    feePerKb?: number;\n    ethereum?: boolean;\n}\ndeclare const networks: {\n    [key: string]: Network;\n};\nexport { networks };\n"}],i=(0,o.lazy)((function(){return Promise.all([t.e(532),t.e(2302)]).then(t.bind(t,2302))}));var c=function(e){var n,t=(0,s.If)().isDarkTheme;return o.createElement(o.Suspense,{fallback:o.createElement("div",null,"Loading")},o.createElement(i,(0,r.Z)({},e,{editorWillMount:function(t){n=t,t.editor.defineTheme("vs-dark",{base:"vs-dark",inherit:!0,rules:[{background:"121212"}],colors:{"editor.background":"#121212"}}),t.languages.typescript.typescriptDefaults.setCompilerOptions({target:t.languages.typescript.ScriptTarget.ES2017,allowNonTsExtensions:!0,moduleResolution:t.languages.typescript.ModuleResolutionKind.NodeJs,module:t.languages.typescript.ModuleKind.ESNext,typeRoots:["node_modules/@types"]}),a.forEach((function(e){var n="file:///node_modules/"+e.name;t.languages.typescript.typescriptDefaults.addExtraLib(e.dts,n)})),e.editorWillMount&&e.editorWillMount(t)},editorDidMount:function(t){t.setModel(n.editor.createModel(e.value,"typescript",n.Uri.parse("file:///main-"+Math.random()+".ts")))},theme:t?"vs-dark":"vs-light"})))}},12500:function(e,n,t){"use strict";var r=t(67294);n.Z=function(){if("undefined"==typeof window)return{width:999,height:999};var e=(0,r.useState)({width:window.innerWidth,height:window.innerHeight}),n=e[0],t=e[1];return(0,r.useEffect)((function(){function e(){t({width:window.innerWidth,height:window.innerHeight})}return window.addEventListener("resize",e),function(){return window.removeEventListener("resize",e)}}),[]),n}},78619:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return y}});var r=t(87462),o=t(15861),s=t(87757),a=t.n(s),i=t(67294),c=t(94184),l=t.n(c),d=t(92434),p=t(12500),m=t(44433),g="runbox__boR",u="row_BFIh",b=t(62405),f=t(71446);var y=function(){if("undefined"==typeof window)return null;var e=new URLSearchParams(window.location.search),n=e.has("code")?atob(e.get("code")):'import { TezosProtocol } from "@airgap/coinlib-core";\n\nconst mnemonic =\n"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";\n\nconst protocol = new TezosProtocol();\n\nconst publicKey = await protocol.getPublicKeyFromMnemonic(\nmnemonic,\nprotocol.standardDerivationPath\n);\nconst address = await protocol.getAddressFromPublicKey(publicKey);\n\nconsole.log("Address", address);\n',t=(0,i.useState)(n),s=t[0],c=t[1],y=(0,i.useState)(""),S=y[0],T=y[1],C=(0,i.useState)(b.T.INIT),A=C[0],E=C[1],P=(0,p.Z)(),x=100,h={xs:{width:P.width,height:200},lg:{width:.6*P.width,height:P.height-x}},k={xs:{width:P.width,height:P.height-x-h.xs.height},lg:{width:(.4-.05)*P.width,height:P.height}},L=function(){var e=(0,o.Z)(a().mark((function e(){return a().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(A!==b.T.STARTED){e.next=2;break}return e.abrupt("return");case 2:return e.next=4,N();case 4:return E(b.T.STARTED),e.next=7,(0,f.M)(s,T);case 7:E(b.T.ENDED);case 8:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}(),N=function(){var e=(0,o.Z)(a().mark((function e(){return a().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:T(""),E(b.T.INIT);case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}();return i.createElement(d.Z,{title:"AirGap",description:"AirGap Playground",noFooter:!0},i.createElement("div",{className:l()(g)},i.createElement("button",{onClick:L,className:"button button--primary margin-bottom--lg margin-right--xs"},"Run Code"),i.createElement("button",{onClick:N,className:"button button--secondary margin-bottom--lg margin-right--xs"},"Clear Output"),i.createElement("button",{onClick:function(){(0,f.s)(s)},className:"button button--secondary margin-bottom--lg margin-right--xs"},"Share Code (Copy to Clipboard)")),i.createElement("div",{className:l()(u)},i.createElement(m.Z,(0,r.Z)({},P.width>600?h.lg:h.xs,{language:"typescript",value:s,onChange:function(e){c(e)},options:{minimap:{enabled:!1},wordWrap:"on"}})),i.createElement(m.Z,(0,r.Z)({},P.width>600?k.lg:k.xs,{language:"bash",value:S,options:{readOnly:!0,minimap:{enabled:!1},wordWrap:"on"}}))))}},71446:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{M:function(){return runCoinlibCode},s:function(){return copyShareUrl}});var typescript__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(55423),typescript__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_0__);function replaceAll(e,n,t){return e.split(n).join(t)}var removeImports=function(e){var n=e.split("\n"),t=!0;return n.map((function(e){e.trim().startsWith("import")&&(t=!1);var n=t?e:void 0;return e.indexOf("@airgap/coinlib-core")>=0&&(t=!0),n})).filter((function(e){return!!e})).join("\n")},runCoinlibCode=function runCoinlibCode(rawCode,setOutput){var code=rawCode,coinlib=__webpack_require__(43650),output="",appendOutput=function(e){setOutput((output+="\n"+e).trim())},myLog=function(){for(var e,n=arguments.length,t=new Array(n),r=0;r<n;r++)t[r]=arguments[r];(e=console).log.apply(e,["CODE_RUNNER:"].concat(t)),appendOutput(t.map((function(e){return"object"==typeof e?JSON.stringify(e,null,2):e})).join(" "))},runnable;return code=replaceAll(code,"console.log(","progress("),code=removeImports(code),code=typescript__WEBPACK_IMPORTED_MODULE_0__.transpile("({\n      run: async (coinlib: any, progress: any): string => {\n        Object.keys(coinlib).forEach(key => {\n          window[key] = coinlib[key]\n        })\n        return (async () => {\n          window.fetch = () => Promise.reject('FETCH API DISABLED')\n          window.XMLHttpRequest = {}\n\n          "+code+";\n          if (typeof result !== 'undefined') {\n            return result\n          }\n        })()\n      })"),new Promise((function(resolve){try{runnable=eval(code),runnable.run(coinlib,myLog).then((function(e){e&&appendOutput("Returned:\n"+JSON.stringify(e,null,2)),resolve(e)})).catch((function(e){console.warn(e),appendOutput(JSON.stringify(e,null,2)),resolve(e)}))}catch(e){appendOutput(e),console.error(e),resolve(e)}}))},copyShareUrl=function(e){var n="https://"+window.location.host+"/playground?code="+btoa(e);navigator.clipboard.writeText(n).catch((function(e){return console.error("Failed to copy to url!",e)}))}},94184:function(e,n){var t;!function(){"use strict";var r={}.hasOwnProperty;function o(){for(var e=[],n=0;n<arguments.length;n++){var t=arguments[n];if(t){var s=typeof t;if("string"===s||"number"===s)e.push(t);else if(Array.isArray(t)){if(t.length){var a=o.apply(null,t);a&&e.push(a)}}else if("object"===s)if(t.toString===Object.prototype.toString)for(var i in t)r.call(t,i)&&t[i]&&e.push(i);else e.push(t.toString())}}return e.join(" ")}e.exports?(o.default=o,e.exports=o):void 0===(t=function(){return o}.apply(n,[]))||(e.exports=t)}()},13411:function(e){function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=function(){return[]},n.resolve=n,n.id=13411,e.exports=n},62183:function(){},13024:function(){},62715:function(){},13611:function(){},28353:function(){},1210:function(){},43454:function(){}}]);